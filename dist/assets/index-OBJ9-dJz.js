(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = n(r);
    fetch(r.href, s);
  }
})();
function G0(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var W0 = { exports: {} },
  tu = {},
  j0 = { exports: {} },
  je = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var qa = Symbol.for("react.element"),
  IS = Symbol.for("react.portal"),
  DS = Symbol.for("react.fragment"),
  NS = Symbol.for("react.strict_mode"),
  US = Symbol.for("react.profiler"),
  OS = Symbol.for("react.provider"),
  FS = Symbol.for("react.context"),
  kS = Symbol.for("react.forward_ref"),
  BS = Symbol.for("react.suspense"),
  zS = Symbol.for("react.memo"),
  HS = Symbol.for("react.lazy"),
  Rm = Symbol.iterator;
function VS(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Rm && t[Rm]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var X0 = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Y0 = Object.assign,
  K0 = {};
function Io(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = K0),
    (this.updater = n || X0);
}
Io.prototype.isReactComponent = {};
Io.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
Io.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function q0() {}
q0.prototype = Io.prototype;
function jh(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = K0),
    (this.updater = n || X0);
}
var Xh = (jh.prototype = new q0());
Xh.constructor = jh;
Y0(Xh, Io.prototype);
Xh.isPureReactComponent = !0;
var Cm = Array.isArray,
  $0 = Object.prototype.hasOwnProperty,
  Yh = { current: null },
  Z0 = { key: !0, ref: !0, __self: !0, __source: !0 };
function Q0(t, e, n) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      $0.call(e, i) && !Z0.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = n;
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
    r.children = l;
  }
  if (t && t.defaultProps)
    for (i in ((a = t.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: qa,
    type: t,
    key: s,
    ref: o,
    props: r,
    _owner: Yh.current,
  };
}
function GS(t, e) {
  return {
    $$typeof: qa,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function Kh(t) {
  return typeof t == "object" && t !== null && t.$$typeof === qa;
}
function WS(t) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    t.replace(/[=:]/g, function (n) {
      return e[n];
    })
  );
}
var Pm = /\/+/g;
function bu(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? WS("" + t.key)
    : e.toString(36);
}
function nc(t, e, n, i, r) {
  var s = typeof t;
  (s === "undefined" || s === "boolean") && (t = null);
  var o = !1;
  if (t === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case qa:
          case IS:
            o = !0;
        }
    }
  if (o)
    return (
      (o = t),
      (r = r(o)),
      (t = i === "" ? "." + bu(o, 0) : i),
      Cm(r)
        ? ((n = ""),
          t != null && (n = t.replace(Pm, "$&/") + "/"),
          nc(r, e, n, "", function (c) {
            return c;
          }))
        : r != null &&
          (Kh(r) &&
            (r = GS(
              r,
              n +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(Pm, "$&/") + "/") +
                t
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), Cm(t)))
    for (var a = 0; a < t.length; a++) {
      s = t[a];
      var l = i + bu(s, a);
      o += nc(s, e, n, l, r);
    }
  else if (((l = VS(t)), typeof l == "function"))
    for (t = l.call(t), a = 0; !(s = t.next()).done; )
      (s = s.value), (l = i + bu(s, a++)), (o += nc(s, e, n, l, r));
  else if (s === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function al(t, e, n) {
  if (t == null) return t;
  var i = [],
    r = 0;
  return (
    nc(t, i, "", "", function (s) {
      return e.call(n, s, r++);
    }),
    i
  );
}
function jS(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = n));
        },
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = n));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var un = { current: null },
  ic = { transition: null },
  XS = {
    ReactCurrentDispatcher: un,
    ReactCurrentBatchConfig: ic,
    ReactCurrentOwner: Yh,
  };
function J0() {
  throw Error("act(...) is not supported in production builds of React.");
}
je.Children = {
  map: al,
  forEach: function (t, e, n) {
    al(
      t,
      function () {
        e.apply(this, arguments);
      },
      n
    );
  },
  count: function (t) {
    var e = 0;
    return (
      al(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      al(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!Kh(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
je.Component = Io;
je.Fragment = DS;
je.Profiler = US;
je.PureComponent = jh;
je.StrictMode = NS;
je.Suspense = BS;
je.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = XS;
je.act = J0;
je.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var i = Y0({}, t.props),
    r = t.key,
    s = t.ref,
    o = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = Yh.current)),
      e.key !== void 0 && (r = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var a = t.type.defaultProps;
    for (l in e)
      $0.call(e, l) &&
        !Z0.hasOwnProperty(l) &&
        (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = n;
  else if (1 < l) {
    a = Array(l);
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
    i.children = a;
  }
  return { $$typeof: qa, type: t.type, key: r, ref: s, props: i, _owner: o };
};
je.createContext = function (t) {
  return (
    (t = {
      $$typeof: FS,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = { $$typeof: OS, _context: t }),
    (t.Consumer = t)
  );
};
je.createElement = Q0;
je.createFactory = function (t) {
  var e = Q0.bind(null, t);
  return (e.type = t), e;
};
je.createRef = function () {
  return { current: null };
};
je.forwardRef = function (t) {
  return { $$typeof: kS, render: t };
};
je.isValidElement = Kh;
je.lazy = function (t) {
  return { $$typeof: HS, _payload: { _status: -1, _result: t }, _init: jS };
};
je.memo = function (t, e) {
  return { $$typeof: zS, type: t, compare: e === void 0 ? null : e };
};
je.startTransition = function (t) {
  var e = ic.transition;
  ic.transition = {};
  try {
    t();
  } finally {
    ic.transition = e;
  }
};
je.unstable_act = J0;
je.useCallback = function (t, e) {
  return un.current.useCallback(t, e);
};
je.useContext = function (t) {
  return un.current.useContext(t);
};
je.useDebugValue = function () {};
je.useDeferredValue = function (t) {
  return un.current.useDeferredValue(t);
};
je.useEffect = function (t, e) {
  return un.current.useEffect(t, e);
};
je.useId = function () {
  return un.current.useId();
};
je.useImperativeHandle = function (t, e, n) {
  return un.current.useImperativeHandle(t, e, n);
};
je.useInsertionEffect = function (t, e) {
  return un.current.useInsertionEffect(t, e);
};
je.useLayoutEffect = function (t, e) {
  return un.current.useLayoutEffect(t, e);
};
je.useMemo = function (t, e) {
  return un.current.useMemo(t, e);
};
je.useReducer = function (t, e, n) {
  return un.current.useReducer(t, e, n);
};
je.useRef = function (t) {
  return un.current.useRef(t);
};
je.useState = function (t) {
  return un.current.useState(t);
};
je.useSyncExternalStore = function (t, e, n) {
  return un.current.useSyncExternalStore(t, e, n);
};
je.useTransition = function () {
  return un.current.useTransition();
};
je.version = "18.3.1";
j0.exports = je;
var Qt = j0.exports;
const qh = G0(Qt);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var YS = Qt,
  KS = Symbol.for("react.element"),
  qS = Symbol.for("react.fragment"),
  $S = Object.prototype.hasOwnProperty,
  ZS = YS.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  QS = { key: !0, ref: !0, __self: !0, __source: !0 };
function ev(t, e, n) {
  var i,
    r = {},
    s = null,
    o = null;
  n !== void 0 && (s = "" + n),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (i in e) $S.call(e, i) && !QS.hasOwnProperty(i) && (r[i] = e[i]);
  if (t && t.defaultProps)
    for (i in ((e = t.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: KS,
    type: t,
    key: s,
    ref: o,
    props: r,
    _owner: ZS.current,
  };
}
tu.Fragment = qS;
tu.jsx = ev;
tu.jsxs = ev;
W0.exports = tu;
var K = W0.exports,
  Wf = {},
  tv = { exports: {} },
  Cn = {},
  nv = { exports: {} },
  iv = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(L, Y) {
    var q = L.length;
    L.push(Y);
    e: for (; 0 < q; ) {
      var oe = (q - 1) >>> 1,
        pe = L[oe];
      if (0 < r(pe, Y)) (L[oe] = Y), (L[q] = pe), (q = oe);
      else break e;
    }
  }
  function n(L) {
    return L.length === 0 ? null : L[0];
  }
  function i(L) {
    if (L.length === 0) return null;
    var Y = L[0],
      q = L.pop();
    if (q !== Y) {
      L[0] = q;
      e: for (var oe = 0, pe = L.length, Ne = pe >>> 1; oe < Ne; ) {
        var j = 2 * (oe + 1) - 1,
          ie = L[j],
          ge = j + 1,
          ae = L[ge];
        if (0 > r(ie, q))
          ge < pe && 0 > r(ae, ie)
            ? ((L[oe] = ae), (L[ge] = q), (oe = ge))
            : ((L[oe] = ie), (L[j] = q), (oe = j));
        else if (ge < pe && 0 > r(ae, q)) (L[oe] = ae), (L[ge] = q), (oe = ge);
        else break e;
      }
    }
    return Y;
  }
  function r(L, Y) {
    var q = L.sortIndex - Y.sortIndex;
    return q !== 0 ? q : L.id - Y.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    t.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    t.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    f = null,
    d = 3,
    p = !1,
    g = !1,
    v = !1,
    m = typeof setTimeout == "function" ? setTimeout : null,
    h = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function y(L) {
    for (var Y = n(c); Y !== null; ) {
      if (Y.callback === null) i(c);
      else if (Y.startTime <= L)
        i(c), (Y.sortIndex = Y.expirationTime), e(l, Y);
      else break;
      Y = n(c);
    }
  }
  function x(L) {
    if (((v = !1), y(L), !g))
      if (n(l) !== null) (g = !0), V(C);
      else {
        var Y = n(c);
        Y !== null && Z(x, Y.startTime - L);
      }
  }
  function C(L, Y) {
    (g = !1), v && ((v = !1), h(A), (A = -1)), (p = !0);
    var q = d;
    try {
      for (
        y(Y), f = n(l);
        f !== null && (!(f.expirationTime > Y) || (L && !P()));

      ) {
        var oe = f.callback;
        if (typeof oe == "function") {
          (f.callback = null), (d = f.priorityLevel);
          var pe = oe(f.expirationTime <= Y);
          (Y = t.unstable_now()),
            typeof pe == "function" ? (f.callback = pe) : f === n(l) && i(l),
            y(Y);
        } else i(l);
        f = n(l);
      }
      if (f !== null) var Ne = !0;
      else {
        var j = n(c);
        j !== null && Z(x, j.startTime - Y), (Ne = !1);
      }
      return Ne;
    } finally {
      (f = null), (d = q), (p = !1);
    }
  }
  var R = !1,
    w = null,
    A = -1,
    E = 5,
    S = -1;
  function P() {
    return !(t.unstable_now() - S < E);
  }
  function G() {
    if (w !== null) {
      var L = t.unstable_now();
      S = L;
      var Y = !0;
      try {
        Y = w(!0, L);
      } finally {
        Y ? F() : ((R = !1), (w = null));
      }
    } else R = !1;
  }
  var F;
  if (typeof _ == "function")
    F = function () {
      _(G);
    };
  else if (typeof MessageChannel < "u") {
    var H = new MessageChannel(),
      X = H.port2;
    (H.port1.onmessage = G),
      (F = function () {
        X.postMessage(null);
      });
  } else
    F = function () {
      m(G, 0);
    };
  function V(L) {
    (w = L), R || ((R = !0), F());
  }
  function Z(L, Y) {
    A = m(function () {
      L(t.unstable_now());
    }, Y);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (L) {
      L.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      g || p || ((g = !0), V(C));
    }),
    (t.unstable_forceFrameRate = function (L) {
      0 > L || 125 < L
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (E = 0 < L ? Math.floor(1e3 / L) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return d;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (L) {
      switch (d) {
        case 1:
        case 2:
        case 3:
          var Y = 3;
          break;
        default:
          Y = d;
      }
      var q = d;
      d = Y;
      try {
        return L();
      } finally {
        d = q;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (L, Y) {
      switch (L) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          L = 3;
      }
      var q = d;
      d = L;
      try {
        return Y();
      } finally {
        d = q;
      }
    }),
    (t.unstable_scheduleCallback = function (L, Y, q) {
      var oe = t.unstable_now();
      switch (
        (typeof q == "object" && q !== null
          ? ((q = q.delay), (q = typeof q == "number" && 0 < q ? oe + q : oe))
          : (q = oe),
        L)
      ) {
        case 1:
          var pe = -1;
          break;
        case 2:
          pe = 250;
          break;
        case 5:
          pe = 1073741823;
          break;
        case 4:
          pe = 1e4;
          break;
        default:
          pe = 5e3;
      }
      return (
        (pe = q + pe),
        (L = {
          id: u++,
          callback: Y,
          priorityLevel: L,
          startTime: q,
          expirationTime: pe,
          sortIndex: -1,
        }),
        q > oe
          ? ((L.sortIndex = q),
            e(c, L),
            n(l) === null &&
              L === n(c) &&
              (v ? (h(A), (A = -1)) : (v = !0), Z(x, q - oe)))
          : ((L.sortIndex = pe), e(l, L), g || p || ((g = !0), V(C))),
        L
      );
    }),
    (t.unstable_shouldYield = P),
    (t.unstable_wrapCallback = function (L) {
      var Y = d;
      return function () {
        var q = d;
        d = Y;
        try {
          return L.apply(this, arguments);
        } finally {
          d = q;
        }
      };
    });
})(iv);
nv.exports = iv;
var JS = nv.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var eM = Qt,
  Rn = JS;
function ne(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1;
    n < arguments.length;
    n++
  )
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var rv = new Set(),
  Aa = {};
function _s(t, e) {
  ho(t, e), ho(t + "Capture", e);
}
function ho(t, e) {
  for (Aa[t] = e, t = 0; t < e.length; t++) rv.add(e[t]);
}
var ji = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  jf = Object.prototype.hasOwnProperty,
  tM =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Lm = {},
  Im = {};
function nM(t) {
  return jf.call(Im, t)
    ? !0
    : jf.call(Lm, t)
    ? !1
    : tM.test(t)
    ? (Im[t] = !0)
    : ((Lm[t] = !0), !1);
}
function iM(t, e, n, i) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function rM(t, e, n, i) {
  if (e === null || typeof e > "u" || iM(t, e, n, i)) return !0;
  if (i) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function fn(t, e, n, i, r, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var jt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    jt[t] = new fn(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  jt[e] = new fn(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  jt[t] = new fn(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  jt[t] = new fn(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    jt[t] = new fn(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  jt[t] = new fn(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  jt[t] = new fn(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  jt[t] = new fn(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  jt[t] = new fn(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var $h = /[\-:]([a-z])/g;
function Zh(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace($h, Zh);
    jt[e] = new fn(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace($h, Zh);
    jt[e] = new fn(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace($h, Zh);
  jt[e] = new fn(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  jt[t] = new fn(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
jt.xlinkHref = new fn(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  jt[t] = new fn(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function Qh(t, e, n, i) {
  var r = jt.hasOwnProperty(e) ? jt[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (rM(e, n, r, i) && (n = null),
    i || r === null
      ? nM(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
      : r.mustUseProperty
      ? (t[r.propertyName] = n === null ? (r.type === 3 ? !1 : "") : n)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        n === null
          ? t.removeAttribute(e)
          : ((r = r.type),
            (n = r === 3 || (r === 4 && n === !0) ? "" : "" + n),
            i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n))));
}
var Ji = eM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  ll = Symbol.for("react.element"),
  ks = Symbol.for("react.portal"),
  Bs = Symbol.for("react.fragment"),
  Jh = Symbol.for("react.strict_mode"),
  Xf = Symbol.for("react.profiler"),
  sv = Symbol.for("react.provider"),
  ov = Symbol.for("react.context"),
  ep = Symbol.for("react.forward_ref"),
  Yf = Symbol.for("react.suspense"),
  Kf = Symbol.for("react.suspense_list"),
  tp = Symbol.for("react.memo"),
  hr = Symbol.for("react.lazy"),
  av = Symbol.for("react.offscreen"),
  Dm = Symbol.iterator;
function Ho(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Dm && t[Dm]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var Et = Object.assign,
  Ru;
function ra(t) {
  if (Ru === void 0)
    try {
      throw Error();
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/);
      Ru = (e && e[1]) || "";
    }
  return (
    `
` +
    Ru +
    t
  );
}
var Cu = !1;
function Pu(t, e) {
  if (!t || Cu) return "";
  Cu = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var i = c;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          i = c;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        i = c;
      }
      t();
    }
  } catch (c) {
    if (c && i && typeof c.stack == "string") {
      for (
        var r = c.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var l =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", t.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (Cu = !1), (Error.prepareStackTrace = n);
  }
  return (t = t ? t.displayName || t.name : "") ? ra(t) : "";
}
function sM(t) {
  switch (t.tag) {
    case 5:
      return ra(t.type);
    case 16:
      return ra("Lazy");
    case 13:
      return ra("Suspense");
    case 19:
      return ra("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = Pu(t.type, !1)), t;
    case 11:
      return (t = Pu(t.type.render, !1)), t;
    case 1:
      return (t = Pu(t.type, !0)), t;
    default:
      return "";
  }
}
function qf(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case Bs:
      return "Fragment";
    case ks:
      return "Portal";
    case Xf:
      return "Profiler";
    case Jh:
      return "StrictMode";
    case Yf:
      return "Suspense";
    case Kf:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case ov:
        return (t.displayName || "Context") + ".Consumer";
      case sv:
        return (t._context.displayName || "Context") + ".Provider";
      case ep:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case tp:
        return (
          (e = t.displayName || null), e !== null ? e : qf(t.type) || "Memo"
        );
      case hr:
        (e = t._payload), (t = t._init);
        try {
          return qf(t(e));
        } catch {}
    }
  return null;
}
function oM(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return qf(e);
    case 8:
      return e === Jh ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Ir(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function lv(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function aM(t) {
  var e = lv(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    i = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var r = n.get,
      s = n.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          (i = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(t, e, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function cl(t) {
  t._valueTracker || (t._valueTracker = aM(t));
}
function cv(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    i = "";
  return (
    t && (i = lv(t) ? (t.checked ? "true" : "false") : t.value),
    (t = i),
    t !== n ? (e.setValue(t), !0) : !1
  );
}
function Ec(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function $f(t, e) {
  var n = e.checked;
  return Et({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  });
}
function Nm(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (n = Ir(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: i,
      initialValue: n,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function uv(t, e) {
  (e = e.checked), e != null && Qh(t, "checked", e, !1);
}
function Zf(t, e) {
  uv(t, e);
  var n = Ir(e.value),
    i = e.type;
  if (n != null)
    i === "number"
      ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
      : t.value !== "" + n && (t.value = "" + n);
  else if (i === "submit" || i === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? Qf(t, e.type, n)
    : e.hasOwnProperty("defaultValue") && Qf(t, e.type, Ir(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function Um(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (n = t.name),
    n !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== "" && (t.name = n);
}
function Qf(t, e, n) {
  (e !== "number" || Ec(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var sa = Array.isArray;
function eo(t, e, n, i) {
  if (((t = t.options), e)) {
    e = {};
    for (var r = 0; r < n.length; r++) e["$" + n[r]] = !0;
    for (n = 0; n < t.length; n++)
      (r = e.hasOwnProperty("$" + t[n].value)),
        t[n].selected !== r && (t[n].selected = r),
        r && i && (t[n].defaultSelected = !0);
  } else {
    for (n = "" + Ir(n), e = null, r = 0; r < t.length; r++) {
      if (t[r].value === n) {
        (t[r].selected = !0), i && (t[r].defaultSelected = !0);
        return;
      }
      e !== null || t[r].disabled || (e = t[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function Jf(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(ne(91));
  return Et({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function Om(t, e) {
  var n = e.value;
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(ne(92));
      if (sa(n)) {
        if (1 < n.length) throw Error(ne(93));
        n = n[0];
      }
      e = n;
    }
    e == null && (e = ""), (n = e);
  }
  t._wrapperState = { initialValue: Ir(n) };
}
function fv(t, e) {
  var n = Ir(e.value),
    i = Ir(e.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    i != null && (t.defaultValue = "" + i);
}
function Fm(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function dv(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function ed(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? dv(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var ul,
  hv = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, n, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, i, r);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        ul = ul || document.createElement("div"),
          ul.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = ul.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function ba(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var da = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  lM = ["Webkit", "ms", "Moz", "O"];
Object.keys(da).forEach(function (t) {
  lM.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (da[e] = da[t]);
  });
});
function pv(t, e, n) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : n || typeof e != "number" || e === 0 || (da.hasOwnProperty(t) && da[t])
    ? ("" + e).trim()
    : e + "px";
}
function mv(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var i = n.indexOf("--") === 0,
        r = pv(n, e[n], i);
      n === "float" && (n = "cssFloat"), i ? t.setProperty(n, r) : (t[n] = r);
    }
}
var cM = Et(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function td(t, e) {
  if (e) {
    if (cM[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(ne(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(ne(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(ne(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(ne(62));
  }
}
function nd(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var id = null;
function np(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var rd = null,
  to = null,
  no = null;
function km(t) {
  if ((t = Qa(t))) {
    if (typeof rd != "function") throw Error(ne(280));
    var e = t.stateNode;
    e && ((e = ou(e)), rd(t.stateNode, t.type, e));
  }
}
function gv(t) {
  to ? (no ? no.push(t) : (no = [t])) : (to = t);
}
function _v() {
  if (to) {
    var t = to,
      e = no;
    if (((no = to = null), km(t), e)) for (t = 0; t < e.length; t++) km(e[t]);
  }
}
function vv(t, e) {
  return t(e);
}
function yv() {}
var Lu = !1;
function xv(t, e, n) {
  if (Lu) return t(e, n);
  Lu = !0;
  try {
    return vv(t, e, n);
  } finally {
    (Lu = !1), (to !== null || no !== null) && (yv(), _v());
  }
}
function Ra(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var i = ou(n);
  if (i === null) return null;
  n = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((t = t.type),
        (i = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !i);
      break e;
    default:
      t = !1;
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(ne(231, e, typeof n));
  return n;
}
var sd = !1;
if (ji)
  try {
    var Vo = {};
    Object.defineProperty(Vo, "passive", {
      get: function () {
        sd = !0;
      },
    }),
      window.addEventListener("test", Vo, Vo),
      window.removeEventListener("test", Vo, Vo);
  } catch {
    sd = !1;
  }
function uM(t, e, n, i, r, s, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, c);
  } catch (u) {
    this.onError(u);
  }
}
var ha = !1,
  Tc = null,
  wc = !1,
  od = null,
  fM = {
    onError: function (t) {
      (ha = !0), (Tc = t);
    },
  };
function dM(t, e, n, i, r, s, o, a, l) {
  (ha = !1), (Tc = null), uM.apply(fM, arguments);
}
function hM(t, e, n, i, r, s, o, a, l) {
  if ((dM.apply(this, arguments), ha)) {
    if (ha) {
      var c = Tc;
      (ha = !1), (Tc = null);
    } else throw Error(ne(198));
    wc || ((wc = !0), (od = c));
  }
}
function vs(t) {
  var e = t,
    n = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? n : null;
}
function Sv(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function Bm(t) {
  if (vs(t) !== t) throw Error(ne(188));
}
function pM(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = vs(t)), e === null)) throw Error(ne(188));
    return e !== t ? null : t;
  }
  for (var n = t, i = e; ; ) {
    var r = n.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        n = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === n) return Bm(r), t;
        if (s === i) return Bm(r), e;
        s = s.sibling;
      }
      throw Error(ne(188));
    }
    if (n.return !== i.return) (n = r), (i = s);
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === n) {
          (o = !0), (n = r), (i = s);
          break;
        }
        if (a === i) {
          (o = !0), (i = r), (n = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === n) {
            (o = !0), (n = s), (i = r);
            break;
          }
          if (a === i) {
            (o = !0), (i = s), (n = r);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(ne(189));
      }
    }
    if (n.alternate !== i) throw Error(ne(190));
  }
  if (n.tag !== 3) throw Error(ne(188));
  return n.stateNode.current === n ? t : e;
}
function Mv(t) {
  return (t = pM(t)), t !== null ? Ev(t) : null;
}
function Ev(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = Ev(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var Tv = Rn.unstable_scheduleCallback,
  zm = Rn.unstable_cancelCallback,
  mM = Rn.unstable_shouldYield,
  gM = Rn.unstable_requestPaint,
  bt = Rn.unstable_now,
  _M = Rn.unstable_getCurrentPriorityLevel,
  ip = Rn.unstable_ImmediatePriority,
  wv = Rn.unstable_UserBlockingPriority,
  Ac = Rn.unstable_NormalPriority,
  vM = Rn.unstable_LowPriority,
  Av = Rn.unstable_IdlePriority,
  nu = null,
  mi = null;
function yM(t) {
  if (mi && typeof mi.onCommitFiberRoot == "function")
    try {
      mi.onCommitFiberRoot(nu, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var ei = Math.clz32 ? Math.clz32 : MM,
  xM = Math.log,
  SM = Math.LN2;
function MM(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((xM(t) / SM) | 0)) | 0;
}
var fl = 64,
  dl = 4194304;
function oa(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function bc(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var i = 0,
    r = t.suspendedLanes,
    s = t.pingedLanes,
    o = n & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = oa(a)) : ((s &= o), s !== 0 && (i = oa(s)));
  } else (o = n & ~r), o !== 0 ? (i = oa(o)) : s !== 0 && (i = oa(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= i; 0 < e; )
      (n = 31 - ei(e)), (r = 1 << n), (i |= t[n]), (e &= ~r);
  return i;
}
function EM(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function TM(t, e) {
  for (
    var n = t.suspendedLanes,
      i = t.pingedLanes,
      r = t.expirationTimes,
      s = t.pendingLanes;
    0 < s;

  ) {
    var o = 31 - ei(s),
      a = 1 << o,
      l = r[o];
    l === -1
      ? (!(a & n) || a & i) && (r[o] = EM(a, e))
      : l <= e && (t.expiredLanes |= a),
      (s &= ~a);
  }
}
function ad(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function bv() {
  var t = fl;
  return (fl <<= 1), !(fl & 4194240) && (fl = 64), t;
}
function Iu(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e;
}
function $a(t, e, n) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - ei(e)),
    (t[e] = n);
}
function wM(t, e) {
  var n = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var i = t.eventTimes;
  for (t = t.expirationTimes; 0 < n; ) {
    var r = 31 - ei(n),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (t[r] = -1), (n &= ~s);
  }
}
function rp(t, e) {
  var n = (t.entangledLanes |= e);
  for (t = t.entanglements; n; ) {
    var i = 31 - ei(n),
      r = 1 << i;
    (r & e) | (t[i] & e) && (t[i] |= e), (n &= ~r);
  }
}
var ot = 0;
function Rv(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var Cv,
  sp,
  Pv,
  Lv,
  Iv,
  ld = !1,
  hl = [],
  Mr = null,
  Er = null,
  Tr = null,
  Ca = new Map(),
  Pa = new Map(),
  gr = [],
  AM =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function Hm(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Mr = null;
      break;
    case "dragenter":
    case "dragleave":
      Er = null;
      break;
    case "mouseover":
    case "mouseout":
      Tr = null;
      break;
    case "pointerover":
    case "pointerout":
      Ca.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pa.delete(e.pointerId);
  }
}
function Go(t, e, n, i, r, s) {
  return t === null || t.nativeEvent !== s
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = Qa(e)), e !== null && sp(e)),
      t)
    : ((t.eventSystemFlags |= i),
      (e = t.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      t);
}
function bM(t, e, n, i, r) {
  switch (e) {
    case "focusin":
      return (Mr = Go(Mr, t, e, n, i, r)), !0;
    case "dragenter":
      return (Er = Go(Er, t, e, n, i, r)), !0;
    case "mouseover":
      return (Tr = Go(Tr, t, e, n, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return Ca.set(s, Go(Ca.get(s) || null, t, e, n, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), Pa.set(s, Go(Pa.get(s) || null, t, e, n, i, r)), !0
      );
  }
  return !1;
}
function Dv(t) {
  var e = es(t.target);
  if (e !== null) {
    var n = vs(e);
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = Sv(n)), e !== null)) {
          (t.blockedOn = e),
            Iv(t.priority, function () {
              Pv(n);
            });
          return;
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function rc(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = cd(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var i = new n.constructor(n.type, n);
      (id = i), n.target.dispatchEvent(i), (id = null);
    } else return (e = Qa(n)), e !== null && sp(e), (t.blockedOn = n), !1;
    e.shift();
  }
  return !0;
}
function Vm(t, e, n) {
  rc(t) && n.delete(e);
}
function RM() {
  (ld = !1),
    Mr !== null && rc(Mr) && (Mr = null),
    Er !== null && rc(Er) && (Er = null),
    Tr !== null && rc(Tr) && (Tr = null),
    Ca.forEach(Vm),
    Pa.forEach(Vm);
}
function Wo(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    ld ||
      ((ld = !0),
      Rn.unstable_scheduleCallback(Rn.unstable_NormalPriority, RM)));
}
function La(t) {
  function e(r) {
    return Wo(r, t);
  }
  if (0 < hl.length) {
    Wo(hl[0], t);
    for (var n = 1; n < hl.length; n++) {
      var i = hl[n];
      i.blockedOn === t && (i.blockedOn = null);
    }
  }
  for (
    Mr !== null && Wo(Mr, t),
      Er !== null && Wo(Er, t),
      Tr !== null && Wo(Tr, t),
      Ca.forEach(e),
      Pa.forEach(e),
      n = 0;
    n < gr.length;
    n++
  )
    (i = gr[n]), i.blockedOn === t && (i.blockedOn = null);
  for (; 0 < gr.length && ((n = gr[0]), n.blockedOn === null); )
    Dv(n), n.blockedOn === null && gr.shift();
}
var io = Ji.ReactCurrentBatchConfig,
  Rc = !0;
function CM(t, e, n, i) {
  var r = ot,
    s = io.transition;
  io.transition = null;
  try {
    (ot = 1), op(t, e, n, i);
  } finally {
    (ot = r), (io.transition = s);
  }
}
function PM(t, e, n, i) {
  var r = ot,
    s = io.transition;
  io.transition = null;
  try {
    (ot = 4), op(t, e, n, i);
  } finally {
    (ot = r), (io.transition = s);
  }
}
function op(t, e, n, i) {
  if (Rc) {
    var r = cd(t, e, n, i);
    if (r === null) Vu(t, e, i, Cc, n), Hm(t, i);
    else if (bM(r, t, e, n, i)) i.stopPropagation();
    else if ((Hm(t, i), e & 4 && -1 < AM.indexOf(t))) {
      for (; r !== null; ) {
        var s = Qa(r);
        if (
          (s !== null && Cv(s),
          (s = cd(t, e, n, i)),
          s === null && Vu(t, e, i, Cc, n),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else Vu(t, e, i, null, n);
  }
}
var Cc = null;
function cd(t, e, n, i) {
  if (((Cc = null), (t = np(i)), (t = es(t)), t !== null))
    if (((e = vs(t)), e === null)) t = null;
    else if (((n = e.tag), n === 13)) {
      if (((t = Sv(e)), t !== null)) return t;
      t = null;
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (Cc = t), null;
}
function Nv(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (_M()) {
        case ip:
          return 1;
        case wv:
          return 4;
        case Ac:
        case vM:
          return 16;
        case Av:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var yr = null,
  ap = null,
  sc = null;
function Uv() {
  if (sc) return sc;
  var t,
    e = ap,
    n = e.length,
    i,
    r = "value" in yr ? yr.value : yr.textContent,
    s = r.length;
  for (t = 0; t < n && e[t] === r[t]; t++);
  var o = n - t;
  for (i = 1; i <= o && e[n - i] === r[s - i]; i++);
  return (sc = r.slice(t, 1 < i ? 1 - i : void 0));
}
function oc(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function pl() {
  return !0;
}
function Gm() {
  return !1;
}
function Pn(t) {
  function e(n, i, r, s, o) {
    (this._reactName = n),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in t)
      t.hasOwnProperty(a) && ((n = t[a]), (this[a] = n ? n(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? pl
        : Gm),
      (this.isPropagationStopped = Gm),
      this
    );
  }
  return (
    Et(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = pl));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = pl));
      },
      persist: function () {},
      isPersistent: pl,
    }),
    e
  );
}
var Do = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  lp = Pn(Do),
  Za = Et({}, Do, { view: 0, detail: 0 }),
  LM = Pn(Za),
  Du,
  Nu,
  jo,
  iu = Et({}, Za, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: cp,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== jo &&
            (jo && t.type === "mousemove"
              ? ((Du = t.screenX - jo.screenX), (Nu = t.screenY - jo.screenY))
              : (Nu = Du = 0),
            (jo = t)),
          Du);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : Nu;
    },
  }),
  Wm = Pn(iu),
  IM = Et({}, iu, { dataTransfer: 0 }),
  DM = Pn(IM),
  NM = Et({}, Za, { relatedTarget: 0 }),
  Uu = Pn(NM),
  UM = Et({}, Do, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  OM = Pn(UM),
  FM = Et({}, Do, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  kM = Pn(FM),
  BM = Et({}, Do, { data: 0 }),
  jm = Pn(BM),
  zM = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  HM = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  VM = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function GM(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = VM[t]) ? !!e[t] : !1;
}
function cp() {
  return GM;
}
var WM = Et({}, Za, {
    key: function (t) {
      if (t.key) {
        var e = zM[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = oc(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? HM[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: cp,
    charCode: function (t) {
      return t.type === "keypress" ? oc(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? oc(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  jM = Pn(WM),
  XM = Et({}, iu, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Xm = Pn(XM),
  YM = Et({}, Za, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: cp,
  }),
  KM = Pn(YM),
  qM = Et({}, Do, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  $M = Pn(qM),
  ZM = Et({}, iu, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  QM = Pn(ZM),
  JM = [9, 13, 27, 32],
  up = ji && "CompositionEvent" in window,
  pa = null;
ji && "documentMode" in document && (pa = document.documentMode);
var eE = ji && "TextEvent" in window && !pa,
  Ov = ji && (!up || (pa && 8 < pa && 11 >= pa)),
  Ym = " ",
  Km = !1;
function Fv(t, e) {
  switch (t) {
    case "keyup":
      return JM.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function kv(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var zs = !1;
function tE(t, e) {
  switch (t) {
    case "compositionend":
      return kv(e);
    case "keypress":
      return e.which !== 32 ? null : ((Km = !0), Ym);
    case "textInput":
      return (t = e.data), t === Ym && Km ? null : t;
    default:
      return null;
  }
}
function nE(t, e) {
  if (zs)
    return t === "compositionend" || (!up && Fv(t, e))
      ? ((t = Uv()), (sc = ap = yr = null), (zs = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return Ov && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var iE = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function qm(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!iE[t.type] : e === "textarea";
}
function Bv(t, e, n, i) {
  gv(i),
    (e = Pc(e, "onChange")),
    0 < e.length &&
      ((n = new lp("onChange", "change", null, n, i)),
      t.push({ event: n, listeners: e }));
}
var ma = null,
  Ia = null;
function rE(t) {
  $v(t, 0);
}
function ru(t) {
  var e = Gs(t);
  if (cv(e)) return t;
}
function sE(t, e) {
  if (t === "change") return e;
}
var zv = !1;
if (ji) {
  var Ou;
  if (ji) {
    var Fu = "oninput" in document;
    if (!Fu) {
      var $m = document.createElement("div");
      $m.setAttribute("oninput", "return;"),
        (Fu = typeof $m.oninput == "function");
    }
    Ou = Fu;
  } else Ou = !1;
  zv = Ou && (!document.documentMode || 9 < document.documentMode);
}
function Zm() {
  ma && (ma.detachEvent("onpropertychange", Hv), (Ia = ma = null));
}
function Hv(t) {
  if (t.propertyName === "value" && ru(Ia)) {
    var e = [];
    Bv(e, Ia, t, np(t)), xv(rE, e);
  }
}
function oE(t, e, n) {
  t === "focusin"
    ? (Zm(), (ma = e), (Ia = n), ma.attachEvent("onpropertychange", Hv))
    : t === "focusout" && Zm();
}
function aE(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return ru(Ia);
}
function lE(t, e) {
  if (t === "click") return ru(e);
}
function cE(t, e) {
  if (t === "input" || t === "change") return ru(e);
}
function uE(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var ii = typeof Object.is == "function" ? Object.is : uE;
function Da(t, e) {
  if (ii(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var n = Object.keys(t),
    i = Object.keys(e);
  if (n.length !== i.length) return !1;
  for (i = 0; i < n.length; i++) {
    var r = n[i];
    if (!jf.call(e, r) || !ii(t[r], e[r])) return !1;
  }
  return !0;
}
function Qm(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function Jm(t, e) {
  var n = Qm(t);
  t = 0;
  for (var i; n; ) {
    if (n.nodeType === 3) {
      if (((i = t + n.textContent.length), t <= e && i >= e))
        return { node: n, offset: e - t };
      t = i;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = Qm(n);
  }
}
function Vv(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? Vv(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function Gv() {
  for (var t = window, e = Ec(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) t = e.contentWindow;
    else break;
    e = Ec(t.document);
  }
  return e;
}
function fp(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function fE(t) {
  var e = Gv(),
    n = t.focusedElem,
    i = t.selectionRange;
  if (
    e !== n &&
    n &&
    n.ownerDocument &&
    Vv(n.ownerDocument.documentElement, n)
  ) {
    if (i !== null && fp(n)) {
      if (
        ((e = i.start),
        (t = i.end),
        t === void 0 && (t = e),
        "selectionStart" in n)
      )
        (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var r = n.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !t.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = Jm(n, s));
        var o = Jm(n, i);
        r &&
          o &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== r.node ||
            t.anchorOffset !== r.offset ||
            t.focusNode !== o.node ||
            t.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          t.removeAllRanges(),
          s > i
            ? (t.addRange(e), t.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), t.addRange(e)));
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
      (t = e[n]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var dE = ji && "documentMode" in document && 11 >= document.documentMode,
  Hs = null,
  ud = null,
  ga = null,
  fd = !1;
function eg(t, e, n) {
  var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  fd ||
    Hs == null ||
    Hs !== Ec(i) ||
    ((i = Hs),
    "selectionStart" in i && fp(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (ga && Da(ga, i)) ||
      ((ga = i),
      (i = Pc(ud, "onSelect")),
      0 < i.length &&
        ((e = new lp("onSelect", "select", null, e, n)),
        t.push({ event: e, listeners: i }),
        (e.target = Hs))));
}
function ml(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit" + t] = "webkit" + e),
    (n["Moz" + t] = "moz" + e),
    n
  );
}
var Vs = {
    animationend: ml("Animation", "AnimationEnd"),
    animationiteration: ml("Animation", "AnimationIteration"),
    animationstart: ml("Animation", "AnimationStart"),
    transitionend: ml("Transition", "TransitionEnd"),
  },
  ku = {},
  Wv = {};
ji &&
  ((Wv = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Vs.animationend.animation,
    delete Vs.animationiteration.animation,
    delete Vs.animationstart.animation),
  "TransitionEvent" in window || delete Vs.transitionend.transition);
function su(t) {
  if (ku[t]) return ku[t];
  if (!Vs[t]) return t;
  var e = Vs[t],
    n;
  for (n in e) if (e.hasOwnProperty(n) && n in Wv) return (ku[t] = e[n]);
  return t;
}
var jv = su("animationend"),
  Xv = su("animationiteration"),
  Yv = su("animationstart"),
  Kv = su("transitionend"),
  qv = new Map(),
  tg =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function kr(t, e) {
  qv.set(t, e), _s(e, [t]);
}
for (var Bu = 0; Bu < tg.length; Bu++) {
  var zu = tg[Bu],
    hE = zu.toLowerCase(),
    pE = zu[0].toUpperCase() + zu.slice(1);
  kr(hE, "on" + pE);
}
kr(jv, "onAnimationEnd");
kr(Xv, "onAnimationIteration");
kr(Yv, "onAnimationStart");
kr("dblclick", "onDoubleClick");
kr("focusin", "onFocus");
kr("focusout", "onBlur");
kr(Kv, "onTransitionEnd");
ho("onMouseEnter", ["mouseout", "mouseover"]);
ho("onMouseLeave", ["mouseout", "mouseover"]);
ho("onPointerEnter", ["pointerout", "pointerover"]);
ho("onPointerLeave", ["pointerout", "pointerover"]);
_s(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
_s(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
_s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
_s(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
_s(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
_s(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var aa =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  mE = new Set("cancel close invalid load scroll toggle".split(" ").concat(aa));
function ng(t, e, n) {
  var i = t.type || "unknown-event";
  (t.currentTarget = n), hM(i, e, void 0, t), (t.currentTarget = null);
}
function $v(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var i = t[n],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            l = a.instance,
            c = a.currentTarget;
          if (((a = a.listener), l !== s && r.isPropagationStopped())) break e;
          ng(r, a, c), (s = l);
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== s && r.isPropagationStopped())
          )
            break e;
          ng(r, a, c), (s = l);
        }
    }
  }
  if (wc) throw ((t = od), (wc = !1), (od = null), t);
}
function mt(t, e) {
  var n = e[gd];
  n === void 0 && (n = e[gd] = new Set());
  var i = t + "__bubble";
  n.has(i) || (Zv(e, t, 2, !1), n.add(i));
}
function Hu(t, e, n) {
  var i = 0;
  e && (i |= 4), Zv(n, t, i, e);
}
var gl = "_reactListening" + Math.random().toString(36).slice(2);
function Na(t) {
  if (!t[gl]) {
    (t[gl] = !0),
      rv.forEach(function (n) {
        n !== "selectionchange" && (mE.has(n) || Hu(n, !1, t), Hu(n, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[gl] || ((e[gl] = !0), Hu("selectionchange", !1, e));
  }
}
function Zv(t, e, n, i) {
  switch (Nv(e)) {
    case 1:
      var r = CM;
      break;
    case 4:
      r = PM;
      break;
    default:
      r = op;
  }
  (n = r.bind(null, e, n, t)),
    (r = void 0),
    !sd ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? t.addEventListener(e, n, { capture: !0, passive: r })
        : t.addEventListener(e, n, !0)
      : r !== void 0
      ? t.addEventListener(e, n, { passive: r })
      : t.addEventListener(e, n, !1);
}
function Vu(t, e, n, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === r || (l.nodeType === 8 && l.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = es(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  xv(function () {
    var c = s,
      u = np(n),
      f = [];
    e: {
      var d = qv.get(t);
      if (d !== void 0) {
        var p = lp,
          g = t;
        switch (t) {
          case "keypress":
            if (oc(n) === 0) break e;
          case "keydown":
          case "keyup":
            p = jM;
            break;
          case "focusin":
            (g = "focus"), (p = Uu);
            break;
          case "focusout":
            (g = "blur"), (p = Uu);
            break;
          case "beforeblur":
          case "afterblur":
            p = Uu;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = Wm;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = DM;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = KM;
            break;
          case jv:
          case Xv:
          case Yv:
            p = OM;
            break;
          case Kv:
            p = $M;
            break;
          case "scroll":
            p = LM;
            break;
          case "wheel":
            p = QM;
            break;
          case "copy":
          case "cut":
          case "paste":
            p = kM;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = Xm;
        }
        var v = (e & 4) !== 0,
          m = !v && t === "scroll",
          h = v ? (d !== null ? d + "Capture" : null) : d;
        v = [];
        for (var _ = c, y; _ !== null; ) {
          y = _;
          var x = y.stateNode;
          if (
            (y.tag === 5 &&
              x !== null &&
              ((y = x),
              h !== null && ((x = Ra(_, h)), x != null && v.push(Ua(_, x, y)))),
            m)
          )
            break;
          _ = _.return;
        }
        0 < v.length &&
          ((d = new p(d, g, null, n, u)), f.push({ event: d, listeners: v }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((d = t === "mouseover" || t === "pointerover"),
          (p = t === "mouseout" || t === "pointerout"),
          d &&
            n !== id &&
            (g = n.relatedTarget || n.fromElement) &&
            (es(g) || g[Xi]))
        )
          break e;
        if (
          (p || d) &&
          ((d =
            u.window === u
              ? u
              : (d = u.ownerDocument)
              ? d.defaultView || d.parentWindow
              : window),
          p
            ? ((g = n.relatedTarget || n.toElement),
              (p = c),
              (g = g ? es(g) : null),
              g !== null &&
                ((m = vs(g)), g !== m || (g.tag !== 5 && g.tag !== 6)) &&
                (g = null))
            : ((p = null), (g = c)),
          p !== g)
        ) {
          if (
            ((v = Wm),
            (x = "onMouseLeave"),
            (h = "onMouseEnter"),
            (_ = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((v = Xm),
              (x = "onPointerLeave"),
              (h = "onPointerEnter"),
              (_ = "pointer")),
            (m = p == null ? d : Gs(p)),
            (y = g == null ? d : Gs(g)),
            (d = new v(x, _ + "leave", p, n, u)),
            (d.target = m),
            (d.relatedTarget = y),
            (x = null),
            es(u) === c &&
              ((v = new v(h, _ + "enter", g, n, u)),
              (v.target = y),
              (v.relatedTarget = m),
              (x = v)),
            (m = x),
            p && g)
          )
            t: {
              for (v = p, h = g, _ = 0, y = v; y; y = Ms(y)) _++;
              for (y = 0, x = h; x; x = Ms(x)) y++;
              for (; 0 < _ - y; ) (v = Ms(v)), _--;
              for (; 0 < y - _; ) (h = Ms(h)), y--;
              for (; _--; ) {
                if (v === h || (h !== null && v === h.alternate)) break t;
                (v = Ms(v)), (h = Ms(h));
              }
              v = null;
            }
          else v = null;
          p !== null && ig(f, d, p, v, !1),
            g !== null && m !== null && ig(f, m, g, v, !0);
        }
      }
      e: {
        if (
          ((d = c ? Gs(c) : window),
          (p = d.nodeName && d.nodeName.toLowerCase()),
          p === "select" || (p === "input" && d.type === "file"))
        )
          var C = sE;
        else if (qm(d))
          if (zv) C = cE;
          else {
            C = aE;
            var R = oE;
          }
        else
          (p = d.nodeName) &&
            p.toLowerCase() === "input" &&
            (d.type === "checkbox" || d.type === "radio") &&
            (C = lE);
        if (C && (C = C(t, c))) {
          Bv(f, C, n, u);
          break e;
        }
        R && R(t, d, c),
          t === "focusout" &&
            (R = d._wrapperState) &&
            R.controlled &&
            d.type === "number" &&
            Qf(d, "number", d.value);
      }
      switch (((R = c ? Gs(c) : window), t)) {
        case "focusin":
          (qm(R) || R.contentEditable === "true") &&
            ((Hs = R), (ud = c), (ga = null));
          break;
        case "focusout":
          ga = ud = Hs = null;
          break;
        case "mousedown":
          fd = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (fd = !1), eg(f, n, u);
          break;
        case "selectionchange":
          if (dE) break;
        case "keydown":
        case "keyup":
          eg(f, n, u);
      }
      var w;
      if (up)
        e: {
          switch (t) {
            case "compositionstart":
              var A = "onCompositionStart";
              break e;
            case "compositionend":
              A = "onCompositionEnd";
              break e;
            case "compositionupdate":
              A = "onCompositionUpdate";
              break e;
          }
          A = void 0;
        }
      else
        zs
          ? Fv(t, n) && (A = "onCompositionEnd")
          : t === "keydown" && n.keyCode === 229 && (A = "onCompositionStart");
      A &&
        (Ov &&
          n.locale !== "ko" &&
          (zs || A !== "onCompositionStart"
            ? A === "onCompositionEnd" && zs && (w = Uv())
            : ((yr = u),
              (ap = "value" in yr ? yr.value : yr.textContent),
              (zs = !0))),
        (R = Pc(c, A)),
        0 < R.length &&
          ((A = new jm(A, t, null, n, u)),
          f.push({ event: A, listeners: R }),
          w ? (A.data = w) : ((w = kv(n)), w !== null && (A.data = w)))),
        (w = eE ? tE(t, n) : nE(t, n)) &&
          ((c = Pc(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new jm("onBeforeInput", "beforeinput", null, n, u)),
            f.push({ event: u, listeners: c }),
            (u.data = w)));
    }
    $v(f, e);
  });
}
function Ua(t, e, n) {
  return { instance: t, listener: e, currentTarget: n };
}
function Pc(t, e) {
  for (var n = e + "Capture", i = []; t !== null; ) {
    var r = t,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = Ra(t, n)),
      s != null && i.unshift(Ua(t, s, r)),
      (s = Ra(t, e)),
      s != null && i.push(Ua(t, s, r))),
      (t = t.return);
  }
  return i;
}
function Ms(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function ig(t, e, n, i, r) {
  for (var s = e._reactName, o = []; n !== null && n !== i; ) {
    var a = n,
      l = a.alternate,
      c = a.stateNode;
    if (l !== null && l === i) break;
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      r
        ? ((l = Ra(n, s)), l != null && o.unshift(Ua(n, l, a)))
        : r || ((l = Ra(n, s)), l != null && o.push(Ua(n, l, a)))),
      (n = n.return);
  }
  o.length !== 0 && t.push({ event: e, listeners: o });
}
var gE = /\r\n?/g,
  _E = /\u0000|\uFFFD/g;
function rg(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      gE,
      `
`
    )
    .replace(_E, "");
}
function _l(t, e, n) {
  if (((e = rg(e)), rg(t) !== e && n)) throw Error(ne(425));
}
function Lc() {}
var dd = null,
  hd = null;
function pd(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var md = typeof setTimeout == "function" ? setTimeout : void 0,
  vE = typeof clearTimeout == "function" ? clearTimeout : void 0,
  sg = typeof Promise == "function" ? Promise : void 0,
  yE =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof sg < "u"
      ? function (t) {
          return sg.resolve(null).then(t).catch(xE);
        }
      : md;
function xE(t) {
  setTimeout(function () {
    throw t;
  });
}
function Gu(t, e) {
  var n = e,
    i = 0;
  do {
    var r = n.nextSibling;
    if ((t.removeChild(n), r && r.nodeType === 8))
      if (((n = r.data), n === "/$")) {
        if (i === 0) {
          t.removeChild(r), La(e);
          return;
        }
        i--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || i++;
    n = r;
  } while (n);
  La(e);
}
function wr(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function og(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--;
      } else n === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var No = Math.random().toString(36).slice(2),
  ci = "__reactFiber$" + No,
  Oa = "__reactProps$" + No,
  Xi = "__reactContainer$" + No,
  gd = "__reactEvents$" + No,
  SE = "__reactListeners$" + No,
  ME = "__reactHandles$" + No;
function es(t) {
  var e = t[ci];
  if (e) return e;
  for (var n = t.parentNode; n; ) {
    if ((e = n[Xi] || n[ci])) {
      if (
        ((n = e.alternate),
        e.child !== null || (n !== null && n.child !== null))
      )
        for (t = og(t); t !== null; ) {
          if ((n = t[ci])) return n;
          t = og(t);
        }
      return e;
    }
    (t = n), (n = t.parentNode);
  }
  return null;
}
function Qa(t) {
  return (
    (t = t[ci] || t[Xi]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function Gs(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(ne(33));
}
function ou(t) {
  return t[Oa] || null;
}
var _d = [],
  Ws = -1;
function Br(t) {
  return { current: t };
}
function gt(t) {
  0 > Ws || ((t.current = _d[Ws]), (_d[Ws] = null), Ws--);
}
function ft(t, e) {
  Ws++, (_d[Ws] = t.current), (t.current = e);
}
var Dr = {},
  Jt = Br(Dr),
  _n = Br(!1),
  ls = Dr;
function po(t, e) {
  var n = t.type.contextTypes;
  if (!n) return Dr;
  var i = t.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in n) r[s] = e[s];
  return (
    i &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function vn(t) {
  return (t = t.childContextTypes), t != null;
}
function Ic() {
  gt(_n), gt(Jt);
}
function ag(t, e, n) {
  if (Jt.current !== Dr) throw Error(ne(168));
  ft(Jt, e), ft(_n, n);
}
function Qv(t, e, n) {
  var i = t.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return n;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(ne(108, oM(t) || "Unknown", r));
  return Et({}, n, i);
}
function Dc(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || Dr),
    (ls = Jt.current),
    ft(Jt, t),
    ft(_n, _n.current),
    !0
  );
}
function lg(t, e, n) {
  var i = t.stateNode;
  if (!i) throw Error(ne(169));
  n
    ? ((t = Qv(t, e, ls)),
      (i.__reactInternalMemoizedMergedChildContext = t),
      gt(_n),
      gt(Jt),
      ft(Jt, t))
    : gt(_n),
    ft(_n, n);
}
var Ui = null,
  au = !1,
  Wu = !1;
function Jv(t) {
  Ui === null ? (Ui = [t]) : Ui.push(t);
}
function EE(t) {
  (au = !0), Jv(t);
}
function zr() {
  if (!Wu && Ui !== null) {
    Wu = !0;
    var t = 0,
      e = ot;
    try {
      var n = Ui;
      for (ot = 1; t < n.length; t++) {
        var i = n[t];
        do i = i(!0);
        while (i !== null);
      }
      (Ui = null), (au = !1);
    } catch (r) {
      throw (Ui !== null && (Ui = Ui.slice(t + 1)), Tv(ip, zr), r);
    } finally {
      (ot = e), (Wu = !1);
    }
  }
  return null;
}
var js = [],
  Xs = 0,
  Nc = null,
  Uc = 0,
  On = [],
  Fn = 0,
  cs = null,
  ki = 1,
  Bi = "";
function qr(t, e) {
  (js[Xs++] = Uc), (js[Xs++] = Nc), (Nc = t), (Uc = e);
}
function ey(t, e, n) {
  (On[Fn++] = ki), (On[Fn++] = Bi), (On[Fn++] = cs), (cs = t);
  var i = ki;
  t = Bi;
  var r = 32 - ei(i) - 1;
  (i &= ~(1 << r)), (n += 1);
  var s = 32 - ei(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    (s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (ki = (1 << (32 - ei(e) + r)) | (n << r) | i),
      (Bi = s + t);
  } else (ki = (1 << s) | (n << r) | i), (Bi = t);
}
function dp(t) {
  t.return !== null && (qr(t, 1), ey(t, 1, 0));
}
function hp(t) {
  for (; t === Nc; )
    (Nc = js[--Xs]), (js[Xs] = null), (Uc = js[--Xs]), (js[Xs] = null);
  for (; t === cs; )
    (cs = On[--Fn]),
      (On[Fn] = null),
      (Bi = On[--Fn]),
      (On[Fn] = null),
      (ki = On[--Fn]),
      (On[Fn] = null);
}
var bn = null,
  wn = null,
  vt = !1,
  Zn = null;
function ty(t, e) {
  var n = kn(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function cg(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return (
        (e =
          e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), (bn = t), (wn = wr(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (bn = t), (wn = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n = cs !== null ? { id: ki, overflow: Bi } : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = kn(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            (bn = t),
            (wn = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function vd(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function yd(t) {
  if (vt) {
    var e = wn;
    if (e) {
      var n = e;
      if (!cg(t, e)) {
        if (vd(t)) throw Error(ne(418));
        e = wr(n.nextSibling);
        var i = bn;
        e && cg(t, e)
          ? ty(i, n)
          : ((t.flags = (t.flags & -4097) | 2), (vt = !1), (bn = t));
      }
    } else {
      if (vd(t)) throw Error(ne(418));
      (t.flags = (t.flags & -4097) | 2), (vt = !1), (bn = t);
    }
  }
}
function ug(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  bn = t;
}
function vl(t) {
  if (t !== bn) return !1;
  if (!vt) return ug(t), (vt = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !pd(t.type, t.memoizedProps))),
    e && (e = wn))
  ) {
    if (vd(t)) throw (ny(), Error(ne(418)));
    for (; e; ) ty(t, e), (e = wr(e.nextSibling));
  }
  if ((ug(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(ne(317));
    e: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              wn = wr(t.nextSibling);
              break e;
            }
            e--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      wn = null;
    }
  } else wn = bn ? wr(t.stateNode.nextSibling) : null;
  return !0;
}
function ny() {
  for (var t = wn; t; ) t = wr(t.nextSibling);
}
function mo() {
  (wn = bn = null), (vt = !1);
}
function pp(t) {
  Zn === null ? (Zn = [t]) : Zn.push(t);
}
var TE = Ji.ReactCurrentBatchConfig;
function Xo(t, e, n) {
  if (
    ((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(ne(309));
        var i = n.stateNode;
      }
      if (!i) throw Error(ne(147, t));
      var r = i,
        s = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof t != "string") throw Error(ne(284));
    if (!n._owner) throw Error(ne(290, t));
  }
  return t;
}
function yl(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      ne(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function fg(t) {
  var e = t._init;
  return e(t._payload);
}
function iy(t) {
  function e(h, _) {
    if (t) {
      var y = h.deletions;
      y === null ? ((h.deletions = [_]), (h.flags |= 16)) : y.push(_);
    }
  }
  function n(h, _) {
    if (!t) return null;
    for (; _ !== null; ) e(h, _), (_ = _.sibling);
    return null;
  }
  function i(h, _) {
    for (h = new Map(); _ !== null; )
      _.key !== null ? h.set(_.key, _) : h.set(_.index, _), (_ = _.sibling);
    return h;
  }
  function r(h, _) {
    return (h = Cr(h, _)), (h.index = 0), (h.sibling = null), h;
  }
  function s(h, _, y) {
    return (
      (h.index = y),
      t
        ? ((y = h.alternate),
          y !== null
            ? ((y = y.index), y < _ ? ((h.flags |= 2), _) : y)
            : ((h.flags |= 2), _))
        : ((h.flags |= 1048576), _)
    );
  }
  function o(h) {
    return t && h.alternate === null && (h.flags |= 2), h;
  }
  function a(h, _, y, x) {
    return _ === null || _.tag !== 6
      ? ((_ = Zu(y, h.mode, x)), (_.return = h), _)
      : ((_ = r(_, y)), (_.return = h), _);
  }
  function l(h, _, y, x) {
    var C = y.type;
    return C === Bs
      ? u(h, _, y.props.children, x, y.key)
      : _ !== null &&
        (_.elementType === C ||
          (typeof C == "object" &&
            C !== null &&
            C.$$typeof === hr &&
            fg(C) === _.type))
      ? ((x = r(_, y.props)), (x.ref = Xo(h, _, y)), (x.return = h), x)
      : ((x = hc(y.type, y.key, y.props, null, h.mode, x)),
        (x.ref = Xo(h, _, y)),
        (x.return = h),
        x);
  }
  function c(h, _, y, x) {
    return _ === null ||
      _.tag !== 4 ||
      _.stateNode.containerInfo !== y.containerInfo ||
      _.stateNode.implementation !== y.implementation
      ? ((_ = Qu(y, h.mode, x)), (_.return = h), _)
      : ((_ = r(_, y.children || [])), (_.return = h), _);
  }
  function u(h, _, y, x, C) {
    return _ === null || _.tag !== 7
      ? ((_ = as(y, h.mode, x, C)), (_.return = h), _)
      : ((_ = r(_, y)), (_.return = h), _);
  }
  function f(h, _, y) {
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return (_ = Zu("" + _, h.mode, y)), (_.return = h), _;
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case ll:
          return (
            (y = hc(_.type, _.key, _.props, null, h.mode, y)),
            (y.ref = Xo(h, null, _)),
            (y.return = h),
            y
          );
        case ks:
          return (_ = Qu(_, h.mode, y)), (_.return = h), _;
        case hr:
          var x = _._init;
          return f(h, x(_._payload), y);
      }
      if (sa(_) || Ho(_))
        return (_ = as(_, h.mode, y, null)), (_.return = h), _;
      yl(h, _);
    }
    return null;
  }
  function d(h, _, y, x) {
    var C = _ !== null ? _.key : null;
    if ((typeof y == "string" && y !== "") || typeof y == "number")
      return C !== null ? null : a(h, _, "" + y, x);
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case ll:
          return y.key === C ? l(h, _, y, x) : null;
        case ks:
          return y.key === C ? c(h, _, y, x) : null;
        case hr:
          return (C = y._init), d(h, _, C(y._payload), x);
      }
      if (sa(y) || Ho(y)) return C !== null ? null : u(h, _, y, x, null);
      yl(h, y);
    }
    return null;
  }
  function p(h, _, y, x, C) {
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return (h = h.get(y) || null), a(_, h, "" + x, C);
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case ll:
          return (h = h.get(x.key === null ? y : x.key) || null), l(_, h, x, C);
        case ks:
          return (h = h.get(x.key === null ? y : x.key) || null), c(_, h, x, C);
        case hr:
          var R = x._init;
          return p(h, _, y, R(x._payload), C);
      }
      if (sa(x) || Ho(x)) return (h = h.get(y) || null), u(_, h, x, C, null);
      yl(_, x);
    }
    return null;
  }
  function g(h, _, y, x) {
    for (
      var C = null, R = null, w = _, A = (_ = 0), E = null;
      w !== null && A < y.length;
      A++
    ) {
      w.index > A ? ((E = w), (w = null)) : (E = w.sibling);
      var S = d(h, w, y[A], x);
      if (S === null) {
        w === null && (w = E);
        break;
      }
      t && w && S.alternate === null && e(h, w),
        (_ = s(S, _, A)),
        R === null ? (C = S) : (R.sibling = S),
        (R = S),
        (w = E);
    }
    if (A === y.length) return n(h, w), vt && qr(h, A), C;
    if (w === null) {
      for (; A < y.length; A++)
        (w = f(h, y[A], x)),
          w !== null &&
            ((_ = s(w, _, A)), R === null ? (C = w) : (R.sibling = w), (R = w));
      return vt && qr(h, A), C;
    }
    for (w = i(h, w); A < y.length; A++)
      (E = p(w, h, A, y[A], x)),
        E !== null &&
          (t && E.alternate !== null && w.delete(E.key === null ? A : E.key),
          (_ = s(E, _, A)),
          R === null ? (C = E) : (R.sibling = E),
          (R = E));
    return (
      t &&
        w.forEach(function (P) {
          return e(h, P);
        }),
      vt && qr(h, A),
      C
    );
  }
  function v(h, _, y, x) {
    var C = Ho(y);
    if (typeof C != "function") throw Error(ne(150));
    if (((y = C.call(y)), y == null)) throw Error(ne(151));
    for (
      var R = (C = null), w = _, A = (_ = 0), E = null, S = y.next();
      w !== null && !S.done;
      A++, S = y.next()
    ) {
      w.index > A ? ((E = w), (w = null)) : (E = w.sibling);
      var P = d(h, w, S.value, x);
      if (P === null) {
        w === null && (w = E);
        break;
      }
      t && w && P.alternate === null && e(h, w),
        (_ = s(P, _, A)),
        R === null ? (C = P) : (R.sibling = P),
        (R = P),
        (w = E);
    }
    if (S.done) return n(h, w), vt && qr(h, A), C;
    if (w === null) {
      for (; !S.done; A++, S = y.next())
        (S = f(h, S.value, x)),
          S !== null &&
            ((_ = s(S, _, A)), R === null ? (C = S) : (R.sibling = S), (R = S));
      return vt && qr(h, A), C;
    }
    for (w = i(h, w); !S.done; A++, S = y.next())
      (S = p(w, h, A, S.value, x)),
        S !== null &&
          (t && S.alternate !== null && w.delete(S.key === null ? A : S.key),
          (_ = s(S, _, A)),
          R === null ? (C = S) : (R.sibling = S),
          (R = S));
    return (
      t &&
        w.forEach(function (G) {
          return e(h, G);
        }),
      vt && qr(h, A),
      C
    );
  }
  function m(h, _, y, x) {
    if (
      (typeof y == "object" &&
        y !== null &&
        y.type === Bs &&
        y.key === null &&
        (y = y.props.children),
      typeof y == "object" && y !== null)
    ) {
      switch (y.$$typeof) {
        case ll:
          e: {
            for (var C = y.key, R = _; R !== null; ) {
              if (R.key === C) {
                if (((C = y.type), C === Bs)) {
                  if (R.tag === 7) {
                    n(h, R.sibling),
                      (_ = r(R, y.props.children)),
                      (_.return = h),
                      (h = _);
                    break e;
                  }
                } else if (
                  R.elementType === C ||
                  (typeof C == "object" &&
                    C !== null &&
                    C.$$typeof === hr &&
                    fg(C) === R.type)
                ) {
                  n(h, R.sibling),
                    (_ = r(R, y.props)),
                    (_.ref = Xo(h, R, y)),
                    (_.return = h),
                    (h = _);
                  break e;
                }
                n(h, R);
                break;
              } else e(h, R);
              R = R.sibling;
            }
            y.type === Bs
              ? ((_ = as(y.props.children, h.mode, x, y.key)),
                (_.return = h),
                (h = _))
              : ((x = hc(y.type, y.key, y.props, null, h.mode, x)),
                (x.ref = Xo(h, _, y)),
                (x.return = h),
                (h = x));
          }
          return o(h);
        case ks:
          e: {
            for (R = y.key; _ !== null; ) {
              if (_.key === R)
                if (
                  _.tag === 4 &&
                  _.stateNode.containerInfo === y.containerInfo &&
                  _.stateNode.implementation === y.implementation
                ) {
                  n(h, _.sibling),
                    (_ = r(_, y.children || [])),
                    (_.return = h),
                    (h = _);
                  break e;
                } else {
                  n(h, _);
                  break;
                }
              else e(h, _);
              _ = _.sibling;
            }
            (_ = Qu(y, h.mode, x)), (_.return = h), (h = _);
          }
          return o(h);
        case hr:
          return (R = y._init), m(h, _, R(y._payload), x);
      }
      if (sa(y)) return g(h, _, y, x);
      if (Ho(y)) return v(h, _, y, x);
      yl(h, y);
    }
    return (typeof y == "string" && y !== "") || typeof y == "number"
      ? ((y = "" + y),
        _ !== null && _.tag === 6
          ? (n(h, _.sibling), (_ = r(_, y)), (_.return = h), (h = _))
          : (n(h, _), (_ = Zu(y, h.mode, x)), (_.return = h), (h = _)),
        o(h))
      : n(h, _);
  }
  return m;
}
var go = iy(!0),
  ry = iy(!1),
  Oc = Br(null),
  Fc = null,
  Ys = null,
  mp = null;
function gp() {
  mp = Ys = Fc = null;
}
function _p(t) {
  var e = Oc.current;
  gt(Oc), (t._currentValue = e);
}
function xd(t, e, n) {
  for (; t !== null; ) {
    var i = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      t === n)
    )
      break;
    t = t.return;
  }
}
function ro(t, e) {
  (Fc = t),
    (mp = Ys = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && (mn = !0), (t.firstContext = null));
}
function Hn(t) {
  var e = t._currentValue;
  if (mp !== t)
    if (((t = { context: t, memoizedValue: e, next: null }), Ys === null)) {
      if (Fc === null) throw Error(ne(308));
      (Ys = t), (Fc.dependencies = { lanes: 0, firstContext: t });
    } else Ys = Ys.next = t;
  return e;
}
var ts = null;
function vp(t) {
  ts === null ? (ts = [t]) : ts.push(t);
}
function sy(t, e, n, i) {
  var r = e.interleaved;
  return (
    r === null ? ((n.next = n), vp(e)) : ((n.next = r.next), (r.next = n)),
    (e.interleaved = n),
    Yi(t, i)
  );
}
function Yi(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return);
  return n.tag === 3 ? n.stateNode : null;
}
var pr = !1;
function yp(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function oy(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function Vi(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Ar(t, e, n) {
  var i = t.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), Qe & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      Yi(t, n)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), vp(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    Yi(t, n)
  );
}
function ac(t, e, n) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= t.pendingLanes), (n |= i), (e.lanes = n), rp(t, n);
  }
}
function dg(t, e) {
  var n = t.updateQueue,
    i = t.alternate;
  if (i !== null && ((i = i.updateQueue), n === i)) {
    var r = null,
      s = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var o = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        s === null ? (r = s = o) : (s = s.next = o), (n = n.next);
      } while (n !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (n = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (t.updateQueue = n);
    return;
  }
  (t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e);
}
function kc(t, e, n, i) {
  var r = t.updateQueue;
  pr = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var l = a,
      c = l.next;
    (l.next = null), o === null ? (s = c) : (o.next = c), (o = l);
    var u = t.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== o &&
        (a === null ? (u.firstBaseUpdate = c) : (a.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var f = r.baseState;
    (o = 0), (u = c = l = null), (a = s);
    do {
      var d = a.lane,
        p = a.eventTime;
      if ((i & d) === d) {
        u !== null &&
          (u = u.next =
            {
              eventTime: p,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var g = t,
            v = a;
          switch (((d = e), (p = n), v.tag)) {
            case 1:
              if (((g = v.payload), typeof g == "function")) {
                f = g.call(p, f, d);
                break e;
              }
              f = g;
              break e;
            case 3:
              g.flags = (g.flags & -65537) | 128;
            case 0:
              if (
                ((g = v.payload),
                (d = typeof g == "function" ? g.call(p, f, d) : g),
                d == null)
              )
                break e;
              f = Et({}, f, d);
              break e;
            case 2:
              pr = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((t.flags |= 64),
          (d = r.effects),
          d === null ? (r.effects = [a]) : d.push(a));
      } else
        (p = {
          eventTime: p,
          lane: d,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = p), (l = f)) : (u = u.next = p),
          (o |= d);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (d = a),
          (a = d.next),
          (d.next = null),
          (r.lastBaseUpdate = d),
          (r.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = f),
      (r.baseState = l),
      (r.firstBaseUpdate = c),
      (r.lastBaseUpdate = u),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (o |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (fs |= o), (t.lanes = o), (t.memoizedState = f);
  }
}
function hg(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var i = t[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = n), typeof r != "function"))
          throw Error(ne(191, r));
        r.call(i);
      }
    }
}
var Ja = {},
  gi = Br(Ja),
  Fa = Br(Ja),
  ka = Br(Ja);
function ns(t) {
  if (t === Ja) throw Error(ne(174));
  return t;
}
function xp(t, e) {
  switch ((ft(ka, e), ft(Fa, t), ft(gi, Ja), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : ed(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = ed(e, t));
  }
  gt(gi), ft(gi, e);
}
function _o() {
  gt(gi), gt(Fa), gt(ka);
}
function ay(t) {
  ns(ka.current);
  var e = ns(gi.current),
    n = ed(e, t.type);
  e !== n && (ft(Fa, t), ft(gi, n));
}
function Sp(t) {
  Fa.current === t && (gt(gi), gt(Fa));
}
var xt = Br(0);
function Bc(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var ju = [];
function Mp() {
  for (var t = 0; t < ju.length; t++)
    ju[t]._workInProgressVersionPrimary = null;
  ju.length = 0;
}
var lc = Ji.ReactCurrentDispatcher,
  Xu = Ji.ReactCurrentBatchConfig,
  us = 0,
  St = null,
  Lt = null,
  Ot = null,
  zc = !1,
  _a = !1,
  Ba = 0,
  wE = 0;
function Yt() {
  throw Error(ne(321));
}
function Ep(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!ii(t[n], e[n])) return !1;
  return !0;
}
function Tp(t, e, n, i, r, s) {
  if (
    ((us = s),
    (St = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (lc.current = t === null || t.memoizedState === null ? CE : PE),
    (t = n(i, r)),
    _a)
  ) {
    s = 0;
    do {
      if (((_a = !1), (Ba = 0), 25 <= s)) throw Error(ne(301));
      (s += 1),
        (Ot = Lt = null),
        (e.updateQueue = null),
        (lc.current = LE),
        (t = n(i, r));
    } while (_a);
  }
  if (
    ((lc.current = Hc),
    (e = Lt !== null && Lt.next !== null),
    (us = 0),
    (Ot = Lt = St = null),
    (zc = !1),
    e)
  )
    throw Error(ne(300));
  return t;
}
function wp() {
  var t = Ba !== 0;
  return (Ba = 0), t;
}
function oi() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Ot === null ? (St.memoizedState = Ot = t) : (Ot = Ot.next = t), Ot;
}
function Vn() {
  if (Lt === null) {
    var t = St.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = Lt.next;
  var e = Ot === null ? St.memoizedState : Ot.next;
  if (e !== null) (Ot = e), (Lt = t);
  else {
    if (t === null) throw Error(ne(310));
    (Lt = t),
      (t = {
        memoizedState: Lt.memoizedState,
        baseState: Lt.baseState,
        baseQueue: Lt.baseQueue,
        queue: Lt.queue,
        next: null,
      }),
      Ot === null ? (St.memoizedState = Ot = t) : (Ot = Ot.next = t);
  }
  return Ot;
}
function za(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function Yu(t) {
  var e = Vn(),
    n = e.queue;
  if (n === null) throw Error(ne(311));
  n.lastRenderedReducer = t;
  var i = Lt,
    r = i.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      (r.next = s.next), (s.next = o);
    }
    (i.baseQueue = r = s), (n.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var a = (o = null),
      l = null,
      c = s;
    do {
      var u = c.lane;
      if ((us & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (i = c.hasEagerState ? c.eagerState : t(i, c.action));
      else {
        var f = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((a = l = f), (o = i)) : (l = l.next = f),
          (St.lanes |= u),
          (fs |= u);
      }
      c = c.next;
    } while (c !== null && c !== s);
    l === null ? (o = i) : (l.next = a),
      ii(i, e.memoizedState) || (mn = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = l),
      (n.lastRenderedState = i);
  }
  if (((t = n.interleaved), t !== null)) {
    r = t;
    do (s = r.lane), (St.lanes |= s), (fs |= s), (r = r.next);
    while (r !== t);
  } else r === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch];
}
function Ku(t) {
  var e = Vn(),
    n = e.queue;
  if (n === null) throw Error(ne(311));
  n.lastRenderedReducer = t;
  var i = n.dispatch,
    r = n.pending,
    s = e.memoizedState;
  if (r !== null) {
    n.pending = null;
    var o = (r = r.next);
    do (s = t(s, o.action)), (o = o.next);
    while (o !== r);
    ii(s, e.memoizedState) || (mn = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (n.lastRenderedState = s);
  }
  return [s, i];
}
function ly() {}
function cy(t, e) {
  var n = St,
    i = Vn(),
    r = e(),
    s = !ii(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (mn = !0)),
    (i = i.queue),
    Ap(dy.bind(null, n, i, t), [t]),
    i.getSnapshot !== e || s || (Ot !== null && Ot.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      Ha(9, fy.bind(null, n, i, r, e), void 0, null),
      Bt === null)
    )
      throw Error(ne(349));
    us & 30 || uy(n, e, r);
  }
  return r;
}
function uy(t, e, n) {
  (t.flags |= 16384),
    (t = { getSnapshot: e, value: n }),
    (e = St.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (St.updateQueue = e),
        (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function fy(t, e, n, i) {
  (e.value = n), (e.getSnapshot = i), hy(e) && py(t);
}
function dy(t, e, n) {
  return n(function () {
    hy(e) && py(t);
  });
}
function hy(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !ii(t, n);
  } catch {
    return !0;
  }
}
function py(t) {
  var e = Yi(t, 1);
  e !== null && ti(e, t, 1, -1);
}
function pg(t) {
  var e = oi();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: za,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = RE.bind(null, St, t)),
    [e.memoizedState, t]
  );
}
function Ha(t, e, n, i) {
  return (
    (t = { tag: t, create: e, destroy: n, deps: i, next: null }),
    (e = St.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (St.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((i = n.next), (n.next = t), (t.next = i), (e.lastEffect = t))),
    t
  );
}
function my() {
  return Vn().memoizedState;
}
function cc(t, e, n, i) {
  var r = oi();
  (St.flags |= t),
    (r.memoizedState = Ha(1 | e, n, void 0, i === void 0 ? null : i));
}
function lu(t, e, n, i) {
  var r = Vn();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Lt !== null) {
    var o = Lt.memoizedState;
    if (((s = o.destroy), i !== null && Ep(i, o.deps))) {
      r.memoizedState = Ha(e, n, s, i);
      return;
    }
  }
  (St.flags |= t), (r.memoizedState = Ha(1 | e, n, s, i));
}
function mg(t, e) {
  return cc(8390656, 8, t, e);
}
function Ap(t, e) {
  return lu(2048, 8, t, e);
}
function gy(t, e) {
  return lu(4, 2, t, e);
}
function _y(t, e) {
  return lu(4, 4, t, e);
}
function vy(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function yy(t, e, n) {
  return (
    (n = n != null ? n.concat([t]) : null), lu(4, 4, vy.bind(null, e, t), n)
  );
}
function bp() {}
function xy(t, e) {
  var n = Vn();
  e = e === void 0 ? null : e;
  var i = n.memoizedState;
  return i !== null && e !== null && Ep(e, i[1])
    ? i[0]
    : ((n.memoizedState = [t, e]), t);
}
function Sy(t, e) {
  var n = Vn();
  e = e === void 0 ? null : e;
  var i = n.memoizedState;
  return i !== null && e !== null && Ep(e, i[1])
    ? i[0]
    : ((t = t()), (n.memoizedState = [t, e]), t);
}
function My(t, e, n) {
  return us & 21
    ? (ii(n, e) || ((n = bv()), (St.lanes |= n), (fs |= n), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), (mn = !0)), (t.memoizedState = n));
}
function AE(t, e) {
  var n = ot;
  (ot = n !== 0 && 4 > n ? n : 4), t(!0);
  var i = Xu.transition;
  Xu.transition = {};
  try {
    t(!1), e();
  } finally {
    (ot = n), (Xu.transition = i);
  }
}
function Ey() {
  return Vn().memoizedState;
}
function bE(t, e, n) {
  var i = Rr(t);
  if (
    ((n = {
      lane: i,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    Ty(t))
  )
    wy(e, n);
  else if (((n = sy(t, e, n, i)), n !== null)) {
    var r = an();
    ti(n, t, i, r), Ay(n, e, i);
  }
}
function RE(t, e, n) {
  var i = Rr(t),
    r = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (Ty(t)) wy(e, r);
  else {
    var s = t.alternate;
    if (
      t.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, n);
        if (((r.hasEagerState = !0), (r.eagerState = a), ii(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((r.next = r), vp(e))
            : ((r.next = l.next), (l.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (n = sy(t, e, r, i)),
      n !== null && ((r = an()), ti(n, t, i, r), Ay(n, e, i));
  }
}
function Ty(t) {
  var e = t.alternate;
  return t === St || (e !== null && e === St);
}
function wy(t, e) {
  _a = zc = !0;
  var n = t.pending;
  n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)),
    (t.pending = e);
}
function Ay(t, e, n) {
  if (n & 4194240) {
    var i = e.lanes;
    (i &= t.pendingLanes), (n |= i), (e.lanes = n), rp(t, n);
  }
}
var Hc = {
    readContext: Hn,
    useCallback: Yt,
    useContext: Yt,
    useEffect: Yt,
    useImperativeHandle: Yt,
    useInsertionEffect: Yt,
    useLayoutEffect: Yt,
    useMemo: Yt,
    useReducer: Yt,
    useRef: Yt,
    useState: Yt,
    useDebugValue: Yt,
    useDeferredValue: Yt,
    useTransition: Yt,
    useMutableSource: Yt,
    useSyncExternalStore: Yt,
    useId: Yt,
    unstable_isNewReconciler: !1,
  },
  CE = {
    readContext: Hn,
    useCallback: function (t, e) {
      return (oi().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: Hn,
    useEffect: mg,
    useImperativeHandle: function (t, e, n) {
      return (
        (n = n != null ? n.concat([t]) : null),
        cc(4194308, 4, vy.bind(null, e, t), n)
      );
    },
    useLayoutEffect: function (t, e) {
      return cc(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return cc(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var n = oi();
      return (
        (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, n) {
      var i = oi();
      return (
        (e = n !== void 0 ? n(e) : e),
        (i.memoizedState = i.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (i.queue = t),
        (t = t.dispatch = bE.bind(null, St, t)),
        [i.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = oi();
      return (t = { current: t }), (e.memoizedState = t);
    },
    useState: pg,
    useDebugValue: bp,
    useDeferredValue: function (t) {
      return (oi().memoizedState = t);
    },
    useTransition: function () {
      var t = pg(!1),
        e = t[0];
      return (t = AE.bind(null, t[1])), (oi().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var i = St,
        r = oi();
      if (vt) {
        if (n === void 0) throw Error(ne(407));
        n = n();
      } else {
        if (((n = e()), Bt === null)) throw Error(ne(349));
        us & 30 || uy(i, e, n);
      }
      r.memoizedState = n;
      var s = { value: n, getSnapshot: e };
      return (
        (r.queue = s),
        mg(dy.bind(null, i, s, t), [t]),
        (i.flags |= 2048),
        Ha(9, fy.bind(null, i, s, n, e), void 0, null),
        n
      );
    },
    useId: function () {
      var t = oi(),
        e = Bt.identifierPrefix;
      if (vt) {
        var n = Bi,
          i = ki;
        (n = (i & ~(1 << (32 - ei(i) - 1))).toString(32) + n),
          (e = ":" + e + "R" + n),
          (n = Ba++),
          0 < n && (e += "H" + n.toString(32)),
          (e += ":");
      } else (n = wE++), (e = ":" + e + "r" + n.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  PE = {
    readContext: Hn,
    useCallback: xy,
    useContext: Hn,
    useEffect: Ap,
    useImperativeHandle: yy,
    useInsertionEffect: gy,
    useLayoutEffect: _y,
    useMemo: Sy,
    useReducer: Yu,
    useRef: my,
    useState: function () {
      return Yu(za);
    },
    useDebugValue: bp,
    useDeferredValue: function (t) {
      var e = Vn();
      return My(e, Lt.memoizedState, t);
    },
    useTransition: function () {
      var t = Yu(za)[0],
        e = Vn().memoizedState;
      return [t, e];
    },
    useMutableSource: ly,
    useSyncExternalStore: cy,
    useId: Ey,
    unstable_isNewReconciler: !1,
  },
  LE = {
    readContext: Hn,
    useCallback: xy,
    useContext: Hn,
    useEffect: Ap,
    useImperativeHandle: yy,
    useInsertionEffect: gy,
    useLayoutEffect: _y,
    useMemo: Sy,
    useReducer: Ku,
    useRef: my,
    useState: function () {
      return Ku(za);
    },
    useDebugValue: bp,
    useDeferredValue: function (t) {
      var e = Vn();
      return Lt === null ? (e.memoizedState = t) : My(e, Lt.memoizedState, t);
    },
    useTransition: function () {
      var t = Ku(za)[0],
        e = Vn().memoizedState;
      return [t, e];
    },
    useMutableSource: ly,
    useSyncExternalStore: cy,
    useId: Ey,
    unstable_isNewReconciler: !1,
  };
function qn(t, e) {
  if (t && t.defaultProps) {
    (e = Et({}, e)), (t = t.defaultProps);
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e;
  }
  return e;
}
function Sd(t, e, n, i) {
  (e = t.memoizedState),
    (n = n(i, e)),
    (n = n == null ? e : Et({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n);
}
var cu = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? vs(t) === t : !1;
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals;
    var i = an(),
      r = Rr(t),
      s = Vi(i, r);
    (s.payload = e),
      n != null && (s.callback = n),
      (e = Ar(t, s, r)),
      e !== null && (ti(e, t, r, i), ac(e, t, r));
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals;
    var i = an(),
      r = Rr(t),
      s = Vi(i, r);
    (s.tag = 1),
      (s.payload = e),
      n != null && (s.callback = n),
      (e = Ar(t, s, r)),
      e !== null && (ti(e, t, r, i), ac(e, t, r));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var n = an(),
      i = Rr(t),
      r = Vi(n, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = Ar(t, r, i)),
      e !== null && (ti(e, t, i, n), ac(e, t, i));
  },
};
function gg(t, e, n, i, r, s, o) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Da(n, i) || !Da(r, s)
      : !0
  );
}
function by(t, e, n) {
  var i = !1,
    r = Dr,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = Hn(s))
      : ((r = vn(e) ? ls : Jt.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? po(t, r) : Dr)),
    (e = new e(n, s)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = cu),
    (t.stateNode = e),
    (e._reactInternals = t),
    i &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = r),
      (t.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function _g(t, e, n, i) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(n, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(n, i),
    e.state !== t && cu.enqueueReplaceState(e, e.state, null);
}
function Md(t, e, n, i) {
  var r = t.stateNode;
  (r.props = n), (r.state = t.memoizedState), (r.refs = {}), yp(t);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = Hn(s))
    : ((s = vn(e) ? ls : Jt.current), (r.context = po(t, s))),
    (r.state = t.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (Sd(t, e, s, n), (r.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && cu.enqueueReplaceState(r, r.state, null),
      kc(t, n, r, i),
      (r.state = t.memoizedState)),
    typeof r.componentDidMount == "function" && (t.flags |= 4194308);
}
function vo(t, e) {
  try {
    var n = "",
      i = e;
    do (n += sM(i)), (i = i.return);
    while (i);
    var r = n;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: t, source: e, stack: r, digest: null };
}
function qu(t, e, n) {
  return { value: t, source: null, stack: n ?? null, digest: e ?? null };
}
function Ed(t, e) {
  try {
    console.error(e.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var IE = typeof WeakMap == "function" ? WeakMap : Map;
function Ry(t, e, n) {
  (n = Vi(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var i = e.value;
  return (
    (n.callback = function () {
      Gc || ((Gc = !0), (Dd = i)), Ed(t, e);
    }),
    n
  );
}
function Cy(t, e, n) {
  (n = Vi(-1, n)), (n.tag = 3);
  var i = t.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (n.payload = function () {
      return i(r);
    }),
      (n.callback = function () {
        Ed(t, e);
      });
  }
  var s = t.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (n.callback = function () {
        Ed(t, e),
          typeof i != "function" &&
            (br === null ? (br = new Set([this])) : br.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    n
  );
}
function vg(t, e, n) {
  var i = t.pingCache;
  if (i === null) {
    i = t.pingCache = new IE();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(n) || (r.add(n), (t = XE.bind(null, t, e, n)), e.then(t, t));
}
function yg(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function xg(t, e, n, i, r) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = r), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((e = Vi(-1, 1)), (e.tag = 2), Ar(n, e, 1))),
          (n.lanes |= 1)),
      t);
}
var DE = Ji.ReactCurrentOwner,
  mn = !1;
function sn(t, e, n, i) {
  e.child = t === null ? ry(e, null, n, i) : go(e, t.child, n, i);
}
function Sg(t, e, n, i, r) {
  n = n.render;
  var s = e.ref;
  return (
    ro(e, r),
    (i = Tp(t, e, n, i, s, r)),
    (n = wp()),
    t !== null && !mn
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~r),
        Ki(t, e, r))
      : (vt && n && dp(e), (e.flags |= 1), sn(t, e, i, r), e.child)
  );
}
function Mg(t, e, n, i, r) {
  if (t === null) {
    var s = n.type;
    return typeof s == "function" &&
      !Up(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), Py(t, e, s, i, r))
      : ((t = hc(n.type, null, i, e, e.mode, r)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((s = t.child), !(t.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : Da), n(o, i) && t.ref === e.ref)
    )
      return Ki(t, e, r);
  }
  return (
    (e.flags |= 1),
    (t = Cr(s, i)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function Py(t, e, n, i, r) {
  if (t !== null) {
    var s = t.memoizedProps;
    if (Da(s, i) && t.ref === e.ref)
      if (((mn = !1), (e.pendingProps = i = s), (t.lanes & r) !== 0))
        t.flags & 131072 && (mn = !0);
      else return (e.lanes = t.lanes), Ki(t, e, r);
  }
  return Td(t, e, n, i, r);
}
function Ly(t, e, n) {
  var i = e.pendingProps,
    r = i.children,
    s = t !== null ? t.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        ft(qs, Tn),
        (Tn |= n);
    else {
      if (!(n & 1073741824))
        return (
          (t = s !== null ? s.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          ft(qs, Tn),
          (Tn |= t),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : n),
        ft(qs, Tn),
        (Tn |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | n), (e.memoizedState = null)) : (i = n),
      ft(qs, Tn),
      (Tn |= i);
  return sn(t, e, r, n), e.child;
}
function Iy(t, e) {
  var n = e.ref;
  ((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Td(t, e, n, i, r) {
  var s = vn(n) ? ls : Jt.current;
  return (
    (s = po(e, s)),
    ro(e, r),
    (n = Tp(t, e, n, i, s, r)),
    (i = wp()),
    t !== null && !mn
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~r),
        Ki(t, e, r))
      : (vt && i && dp(e), (e.flags |= 1), sn(t, e, n, r), e.child)
  );
}
function Eg(t, e, n, i, r) {
  if (vn(n)) {
    var s = !0;
    Dc(e);
  } else s = !1;
  if ((ro(e, r), e.stateNode === null))
    uc(t, e), by(e, n, i), Md(e, n, i, r), (i = !0);
  else if (t === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      c = n.contextType;
    typeof c == "object" && c !== null
      ? (c = Hn(c))
      : ((c = vn(n) ? ls : Jt.current), (c = po(e, c)));
    var u = n.getDerivedStateFromProps,
      f =
        typeof u == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    f ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || l !== c) && _g(e, o, i, c)),
      (pr = !1);
    var d = e.memoizedState;
    (o.state = d),
      kc(e, i, o, r),
      (l = e.memoizedState),
      a !== i || d !== l || _n.current || pr
        ? (typeof u == "function" && (Sd(e, n, u, i), (l = e.memoizedState)),
          (a = pr || gg(e, n, a, i, d, l, c))
            ? (f ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = l)),
          (o.props = i),
          (o.state = l),
          (o.context = c),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (o = e.stateNode),
      oy(t, e),
      (a = e.memoizedProps),
      (c = e.type === e.elementType ? a : qn(e.type, a)),
      (o.props = c),
      (f = e.pendingProps),
      (d = o.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = Hn(l))
        : ((l = vn(n) ? ls : Jt.current), (l = po(e, l)));
    var p = n.getDerivedStateFromProps;
    (u =
      typeof p == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== f || d !== l) && _g(e, o, i, l)),
      (pr = !1),
      (d = e.memoizedState),
      (o.state = d),
      kc(e, i, o, r);
    var g = e.memoizedState;
    a !== f || d !== g || _n.current || pr
      ? (typeof p == "function" && (Sd(e, n, p, i), (g = e.memoizedState)),
        (c = pr || gg(e, n, c, i, d, g, l) || !1)
          ? (u ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, g, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, g, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === t.memoizedProps && d === t.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === t.memoizedProps && d === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = g)),
        (o.props = i),
        (o.state = g),
        (o.context = l),
        (i = c))
      : (typeof o.componentDidUpdate != "function" ||
          (a === t.memoizedProps && d === t.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === t.memoizedProps && d === t.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return wd(t, e, n, i, s, r);
}
function wd(t, e, n, i, r, s) {
  Iy(t, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && lg(e, n, !1), Ki(t, e, s);
  (i = e.stateNode), (DE.current = e);
  var a =
    o && typeof n.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    t !== null && o
      ? ((e.child = go(e, t.child, null, s)), (e.child = go(e, null, a, s)))
      : sn(t, e, a, s),
    (e.memoizedState = i.state),
    r && lg(e, n, !0),
    e.child
  );
}
function Dy(t) {
  var e = t.stateNode;
  e.pendingContext
    ? ag(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && ag(t, e.context, !1),
    xp(t, e.containerInfo);
}
function Tg(t, e, n, i, r) {
  return mo(), pp(r), (e.flags |= 256), sn(t, e, n, i), e.child;
}
var Ad = { dehydrated: null, treeContext: null, retryLane: 0 };
function bd(t) {
  return { baseLanes: t, cachePool: null, transitions: null };
}
function Ny(t, e, n) {
  var i = e.pendingProps,
    r = xt.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (r |= 1),
    ft(xt, r & 1),
    t === null)
  )
    return (
      yd(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (t = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = du(o, i, 0, null)),
              (t = as(t, i, n, null)),
              (s.return = e),
              (t.return = e),
              (s.sibling = t),
              (e.child = s),
              (e.child.memoizedState = bd(n)),
              (e.memoizedState = Ad),
              t)
            : Rp(e, o))
    );
  if (((r = t.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return NE(t, e, o, i, a, r, n);
  if (s) {
    (s = i.fallback), (o = e.mode), (r = t.child), (a = r.sibling);
    var l = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = l),
          (e.deletions = null))
        : ((i = Cr(r, l)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = Cr(a, s)) : ((s = as(s, o, n, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = t.child.memoizedState),
      (o =
        o === null
          ? bd(n)
          : {
              baseLanes: o.baseLanes | n,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = t.childLanes & ~n),
      (e.memoizedState = Ad),
      i
    );
  }
  return (
    (s = t.child),
    (t = s.sibling),
    (i = Cr(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = n),
    (i.return = e),
    (i.sibling = null),
    t !== null &&
      ((n = e.deletions),
      n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function Rp(t, e) {
  return (
    (e = du({ mode: "visible", children: e }, t.mode, 0, null)),
    (e.return = t),
    (t.child = e)
  );
}
function xl(t, e, n, i) {
  return (
    i !== null && pp(i),
    go(e, t.child, null, n),
    (t = Rp(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function NE(t, e, n, i, r, s, o) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (i = qu(Error(ne(422)))), xl(t, e, o, i))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((s = i.fallback),
        (r = e.mode),
        (i = du({ mode: "visible", children: i.children }, r, 0, null)),
        (s = as(s, r, o, null)),
        (s.flags |= 2),
        (i.return = e),
        (s.return = e),
        (i.sibling = s),
        (e.child = i),
        e.mode & 1 && go(e, t.child, null, o),
        (e.child.memoizedState = bd(o)),
        (e.memoizedState = Ad),
        s);
  if (!(e.mode & 1)) return xl(t, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (s = Error(ne(419))), (i = qu(s, i, void 0)), xl(t, e, o, i)
    );
  }
  if (((a = (o & t.childLanes) !== 0), mn || a)) {
    if (((i = Bt), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), Yi(t, r), ti(i, t, r, -1));
    }
    return Np(), (i = qu(Error(ne(421)))), xl(t, e, o, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = YE.bind(null, t)),
      (r._reactRetry = e),
      null)
    : ((t = s.treeContext),
      (wn = wr(r.nextSibling)),
      (bn = e),
      (vt = !0),
      (Zn = null),
      t !== null &&
        ((On[Fn++] = ki),
        (On[Fn++] = Bi),
        (On[Fn++] = cs),
        (ki = t.id),
        (Bi = t.overflow),
        (cs = e)),
      (e = Rp(e, i.children)),
      (e.flags |= 4096),
      e);
}
function wg(t, e, n) {
  t.lanes |= e;
  var i = t.alternate;
  i !== null && (i.lanes |= e), xd(t.return, e, n);
}
function $u(t, e, n, i, r) {
  var s = t.memoizedState;
  s === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: n,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = n),
      (s.tailMode = r));
}
function Uy(t, e, n) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((sn(t, e, i.children, n), (i = xt.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      e: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && wg(t, n, e);
        else if (t.tag === 19) wg(t, n, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break e;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    i &= 1;
  }
  if ((ft(xt, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (n = e.child, r = null; n !== null; )
          (t = n.alternate),
            t !== null && Bc(t) === null && (r = n),
            (n = n.sibling);
        (n = r),
          n === null
            ? ((r = e.child), (e.child = null))
            : ((r = n.sibling), (n.sibling = null)),
          $u(e, !1, r, n, s);
        break;
      case "backwards":
        for (n = null, r = e.child, e.child = null; r !== null; ) {
          if (((t = r.alternate), t !== null && Bc(t) === null)) {
            e.child = r;
            break;
          }
          (t = r.sibling), (r.sibling = n), (n = r), (r = t);
        }
        $u(e, !0, n, null, s);
        break;
      case "together":
        $u(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function uc(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Ki(t, e, n) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (fs |= e.lanes),
    !(n & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(ne(153));
  if (e.child !== null) {
    for (
      t = e.child, n = Cr(t, t.pendingProps), e.child = n, n.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (n = n.sibling = Cr(t, t.pendingProps)), (n.return = e);
    n.sibling = null;
  }
  return e.child;
}
function UE(t, e, n) {
  switch (e.tag) {
    case 3:
      Dy(e), mo();
      break;
    case 5:
      ay(e);
      break;
    case 1:
      vn(e.type) && Dc(e);
      break;
    case 4:
      xp(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      ft(Oc, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (ft(xt, xt.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
          ? Ny(t, e, n)
          : (ft(xt, xt.current & 1),
            (t = Ki(t, e, n)),
            t !== null ? t.sibling : null);
      ft(xt, xt.current & 1);
      break;
    case 19:
      if (((i = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (i) return Uy(t, e, n);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        ft(xt, xt.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), Ly(t, e, n);
  }
  return Ki(t, e, n);
}
var Oy, Rd, Fy, ky;
Oy = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === e) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
Rd = function () {};
Fy = function (t, e, n, i) {
  var r = t.memoizedProps;
  if (r !== i) {
    (t = e.stateNode), ns(gi.current);
    var s = null;
    switch (n) {
      case "input":
        (r = $f(t, r)), (i = $f(t, i)), (s = []);
        break;
      case "select":
        (r = Et({}, r, { value: void 0 })),
          (i = Et({}, i, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (r = Jf(t, r)), (i = Jf(t, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (t.onclick = Lc);
    }
    td(n, i);
    var o;
    n = null;
    for (c in r)
      if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
        if (c === "style") {
          var a = r[c];
          for (o in a) a.hasOwnProperty(o) && (n || (n = {}), (n[o] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (Aa.hasOwnProperty(c)
              ? s || (s = [])
              : (s = s || []).push(c, null));
    for (c in i) {
      var l = i[c];
      if (
        ((a = r != null ? r[c] : void 0),
        i.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (n || (n = {}), (n[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (n || (n = {}), (n[o] = l[o]));
          } else n || (s || (s = []), s.push(c, n)), (n = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (Aa.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && mt("scroll", t),
                  s || a === l || (s = []))
                : (s = s || []).push(c, l));
    }
    n && (s = s || []).push("style", n);
    var c = s;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
ky = function (t, e, n, i) {
  n !== i && (e.flags |= 4);
};
function Yo(t, e) {
  if (!vt)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var n = null; e !== null; )
          e.alternate !== null && (n = e), (e = e.sibling);
        n === null ? (t.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = t.tail;
        for (var i = null; n !== null; )
          n.alternate !== null && (i = n), (n = n.sibling);
        i === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (i.sibling = null);
    }
}
function Kt(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    i = 0;
  if (e)
    for (var r = t.child; r !== null; )
      (n |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = t),
        (r = r.sibling);
  else
    for (r = t.child; r !== null; )
      (n |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = t),
        (r = r.sibling);
  return (t.subtreeFlags |= i), (t.childLanes = n), e;
}
function OE(t, e, n) {
  var i = e.pendingProps;
  switch ((hp(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Kt(e), null;
    case 1:
      return vn(e.type) && Ic(), Kt(e), null;
    case 3:
      return (
        (i = e.stateNode),
        _o(),
        gt(_n),
        gt(Jt),
        Mp(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (t === null || t.child === null) &&
          (vl(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Zn !== null && (Od(Zn), (Zn = null)))),
        Rd(t, e),
        Kt(e),
        null
      );
    case 5:
      Sp(e);
      var r = ns(ka.current);
      if (((n = e.type), t !== null && e.stateNode != null))
        Fy(t, e, n, i, r),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(ne(166));
          return Kt(e), null;
        }
        if (((t = ns(gi.current)), vl(e))) {
          (i = e.stateNode), (n = e.type);
          var s = e.memoizedProps;
          switch (((i[ci] = e), (i[Oa] = s), (t = (e.mode & 1) !== 0), n)) {
            case "dialog":
              mt("cancel", i), mt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              mt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < aa.length; r++) mt(aa[r], i);
              break;
            case "source":
              mt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              mt("error", i), mt("load", i);
              break;
            case "details":
              mt("toggle", i);
              break;
            case "input":
              Nm(i, s), mt("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!s.multiple }),
                mt("invalid", i);
              break;
            case "textarea":
              Om(i, s), mt("invalid", i);
          }
          td(n, s), (r = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      _l(i.textContent, a, t),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      _l(i.textContent, a, t),
                    (r = ["children", "" + a]))
                : Aa.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  mt("scroll", i);
            }
          switch (n) {
            case "input":
              cl(i), Um(i, s, !0);
              break;
            case "textarea":
              cl(i), Fm(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = Lc);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (o = r.nodeType === 9 ? r : r.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = dv(n)),
            t === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((t = o.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof i.is == "string"
                ? (t = o.createElement(n, { is: i.is }))
                : ((t = o.createElement(n)),
                  n === "select" &&
                    ((o = t),
                    i.multiple
                      ? (o.multiple = !0)
                      : i.size && (o.size = i.size)))
              : (t = o.createElementNS(t, n)),
            (t[ci] = e),
            (t[Oa] = i),
            Oy(t, e, !1, !1),
            (e.stateNode = t);
          e: {
            switch (((o = nd(n, i)), n)) {
              case "dialog":
                mt("cancel", t), mt("close", t), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                mt("load", t), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < aa.length; r++) mt(aa[r], t);
                r = i;
                break;
              case "source":
                mt("error", t), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                mt("error", t), mt("load", t), (r = i);
                break;
              case "details":
                mt("toggle", t), (r = i);
                break;
              case "input":
                Nm(t, i), (r = $f(t, i)), mt("invalid", t);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (t._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = Et({}, i, { value: void 0 })),
                  mt("invalid", t);
                break;
              case "textarea":
                Om(t, i), (r = Jf(t, i)), mt("invalid", t);
                break;
              default:
                r = i;
            }
            td(n, r), (a = r);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? mv(t, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && hv(t, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (n !== "textarea" || l !== "") && ba(t, l)
                    : typeof l == "number" && ba(t, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (Aa.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && mt("scroll", t)
                      : l != null && Qh(t, s, l, o));
              }
            switch (n) {
              case "input":
                cl(t), Um(t, i, !1);
                break;
              case "textarea":
                cl(t), Fm(t);
                break;
              case "option":
                i.value != null && t.setAttribute("value", "" + Ir(i.value));
                break;
              case "select":
                (t.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? eo(t, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      eo(t, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (t.onclick = Lc);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return Kt(e), null;
    case 6:
      if (t && e.stateNode != null) ky(t, e, t.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(ne(166));
        if (((n = ns(ka.current)), ns(gi.current), vl(e))) {
          if (
            ((i = e.stateNode),
            (n = e.memoizedProps),
            (i[ci] = e),
            (s = i.nodeValue !== n) && ((t = bn), t !== null))
          )
            switch (t.tag) {
              case 3:
                _l(i.nodeValue, n, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  _l(i.nodeValue, n, (t.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i)),
            (i[ci] = e),
            (e.stateNode = i);
      }
      return Kt(e), null;
    case 13:
      if (
        (gt(xt),
        (i = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (vt && wn !== null && e.mode & 1 && !(e.flags & 128))
          ny(), mo(), (e.flags |= 98560), (s = !1);
        else if (((s = vl(e)), i !== null && i.dehydrated !== null)) {
          if (t === null) {
            if (!s) throw Error(ne(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(ne(317));
            s[ci] = e;
          } else
            mo(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          Kt(e), (s = !1);
        } else Zn !== null && (Od(Zn), (Zn = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((i = i !== null),
          i !== (t !== null && t.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || xt.current & 1 ? It === 0 && (It = 3) : Np())),
          e.updateQueue !== null && (e.flags |= 4),
          Kt(e),
          null);
    case 4:
      return (
        _o(), Rd(t, e), t === null && Na(e.stateNode.containerInfo), Kt(e), null
      );
    case 10:
      return _p(e.type._context), Kt(e), null;
    case 17:
      return vn(e.type) && Ic(), Kt(e), null;
    case 19:
      if ((gt(xt), (s = e.memoizedState), s === null)) return Kt(e), null;
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) Yo(s, !1);
        else {
          if (It !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((o = Bc(t)), o !== null)) {
                for (
                  e.flags |= 128,
                    Yo(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = n,
                    n = e.child;
                  n !== null;

                )
                  (s = n),
                    (t = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = t),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (t = o.dependencies),
                        (s.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (n = n.sibling);
                return ft(xt, (xt.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          s.tail !== null &&
            bt() > yo &&
            ((e.flags |= 128), (i = !0), Yo(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((t = Bc(o)), t !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              Yo(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !vt)
            )
              return Kt(e), null;
          } else
            2 * bt() - s.renderingStartTime > yo &&
              n !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Yo(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((n = s.last),
            n !== null ? (n.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = bt()),
          (e.sibling = null),
          (n = xt.current),
          ft(xt, i ? (n & 1) | 2 : n & 1),
          e)
        : (Kt(e), null);
    case 22:
    case 23:
      return (
        Dp(),
        (i = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? Tn & 1073741824 && (Kt(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : Kt(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(ne(156, e.tag));
}
function FE(t, e) {
  switch ((hp(e), e.tag)) {
    case 1:
      return (
        vn(e.type) && Ic(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        _o(),
        gt(_n),
        gt(Jt),
        Mp(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return Sp(e), null;
    case 13:
      if (
        (gt(xt), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(ne(340));
        mo();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return gt(xt), null;
    case 4:
      return _o(), null;
    case 10:
      return _p(e.type._context), null;
    case 22:
    case 23:
      return Dp(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Sl = !1,
  Zt = !1,
  kE = typeof WeakSet == "function" ? WeakSet : Set,
  me = null;
function Ks(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (i) {
        wt(t, e, i);
      }
    else n.current = null;
}
function Cd(t, e, n) {
  try {
    n();
  } catch (i) {
    wt(t, e, i);
  }
}
var Ag = !1;
function BE(t, e) {
  if (((dd = Rc), (t = Gv()), fp(t))) {
    if ("selectionStart" in t)
      var n = { start: t.selectionStart, end: t.selectionEnd };
    else
      e: {
        n = ((n = t.ownerDocument) && n.defaultView) || window;
        var i = n.getSelection && n.getSelection();
        if (i && i.rangeCount !== 0) {
          n = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            n.nodeType, s.nodeType;
          } catch {
            n = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            f = t,
            d = null;
          t: for (;;) {
            for (
              var p;
              f !== n || (r !== 0 && f.nodeType !== 3) || (a = o + r),
                f !== s || (i !== 0 && f.nodeType !== 3) || (l = o + i),
                f.nodeType === 3 && (o += f.nodeValue.length),
                (p = f.firstChild) !== null;

            )
              (d = f), (f = p);
            for (;;) {
              if (f === t) break t;
              if (
                (d === n && ++c === r && (a = o),
                d === s && ++u === i && (l = o),
                (p = f.nextSibling) !== null)
              )
                break;
              (f = d), (d = f.parentNode);
            }
            f = p;
          }
          n = a === -1 || l === -1 ? null : { start: a, end: l };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    hd = { focusedElem: t, selectionRange: n }, Rc = !1, me = e;
    me !== null;

  )
    if (((e = me), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (me = t);
    else
      for (; me !== null; ) {
        e = me;
        try {
          var g = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (g !== null) {
                  var v = g.memoizedProps,
                    m = g.memoizedState,
                    h = e.stateNode,
                    _ = h.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? v : qn(e.type, v),
                      m
                    );
                  h.__reactInternalSnapshotBeforeUpdate = _;
                }
                break;
              case 3:
                var y = e.stateNode.containerInfo;
                y.nodeType === 1
                  ? (y.textContent = "")
                  : y.nodeType === 9 &&
                    y.documentElement &&
                    y.removeChild(y.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(ne(163));
            }
        } catch (x) {
          wt(e, e.return, x);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (me = t);
          break;
        }
        me = e.return;
      }
  return (g = Ag), (Ag = !1), g;
}
function va(t, e, n) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & t) === t) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && Cd(e, n, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function uu(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var n = (e = e.next);
    do {
      if ((n.tag & t) === t) {
        var i = n.create;
        n.destroy = i();
      }
      n = n.next;
    } while (n !== e);
  }
}
function Pd(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function By(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), By(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[ci], delete e[Oa], delete e[gd], delete e[SE], delete e[ME])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function zy(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function bg(t) {
  e: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || zy(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function Ld(t, e, n) {
  var i = t.tag;
  if (i === 5 || i === 6)
    (t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = Lc));
  else if (i !== 4 && ((t = t.child), t !== null))
    for (Ld(t, e, n), t = t.sibling; t !== null; ) Ld(t, e, n), (t = t.sibling);
}
function Id(t, e, n) {
  var i = t.tag;
  if (i === 5 || i === 6)
    (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (i !== 4 && ((t = t.child), t !== null))
    for (Id(t, e, n), t = t.sibling; t !== null; ) Id(t, e, n), (t = t.sibling);
}
var Vt = null,
  $n = !1;
function rr(t, e, n) {
  for (n = n.child; n !== null; ) Hy(t, e, n), (n = n.sibling);
}
function Hy(t, e, n) {
  if (mi && typeof mi.onCommitFiberUnmount == "function")
    try {
      mi.onCommitFiberUnmount(nu, n);
    } catch {}
  switch (n.tag) {
    case 5:
      Zt || Ks(n, e);
    case 6:
      var i = Vt,
        r = $n;
      (Vt = null),
        rr(t, e, n),
        (Vt = i),
        ($n = r),
        Vt !== null &&
          ($n
            ? ((t = Vt),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : Vt.removeChild(n.stateNode));
      break;
    case 18:
      Vt !== null &&
        ($n
          ? ((t = Vt),
            (n = n.stateNode),
            t.nodeType === 8
              ? Gu(t.parentNode, n)
              : t.nodeType === 1 && Gu(t, n),
            La(t))
          : Gu(Vt, n.stateNode));
      break;
    case 4:
      (i = Vt),
        (r = $n),
        (Vt = n.stateNode.containerInfo),
        ($n = !0),
        rr(t, e, n),
        (Vt = i),
        ($n = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Zt &&
        ((i = n.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Cd(n, e, o),
            (r = r.next);
        } while (r !== i);
      }
      rr(t, e, n);
      break;
    case 1:
      if (
        !Zt &&
        (Ks(n, e),
        (i = n.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = n.memoizedProps),
            (i.state = n.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          wt(n, e, a);
        }
      rr(t, e, n);
      break;
    case 21:
      rr(t, e, n);
      break;
    case 22:
      n.mode & 1
        ? ((Zt = (i = Zt) || n.memoizedState !== null), rr(t, e, n), (Zt = i))
        : rr(t, e, n);
      break;
    default:
      rr(t, e, n);
  }
}
function Rg(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new kE()),
      e.forEach(function (i) {
        var r = KE.bind(null, t, i);
        n.has(i) || (n.add(i), i.then(r, r));
      });
  }
}
function jn(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var i = 0; i < n.length; i++) {
      var r = n[i];
      try {
        var s = t,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Vt = a.stateNode), ($n = !1);
              break e;
            case 3:
              (Vt = a.stateNode.containerInfo), ($n = !0);
              break e;
            case 4:
              (Vt = a.stateNode.containerInfo), ($n = !0);
              break e;
          }
          a = a.return;
        }
        if (Vt === null) throw Error(ne(160));
        Hy(s, o, r), (Vt = null), ($n = !1);
        var l = r.alternate;
        l !== null && (l.return = null), (r.return = null);
      } catch (c) {
        wt(r, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) Vy(e, t), (e = e.sibling);
}
function Vy(t, e) {
  var n = t.alternate,
    i = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((jn(e, t), si(t), i & 4)) {
        try {
          va(3, t, t.return), uu(3, t);
        } catch (v) {
          wt(t, t.return, v);
        }
        try {
          va(5, t, t.return);
        } catch (v) {
          wt(t, t.return, v);
        }
      }
      break;
    case 1:
      jn(e, t), si(t), i & 512 && n !== null && Ks(n, n.return);
      break;
    case 5:
      if (
        (jn(e, t),
        si(t),
        i & 512 && n !== null && Ks(n, n.return),
        t.flags & 32)
      ) {
        var r = t.stateNode;
        try {
          ba(r, "");
        } catch (v) {
          wt(t, t.return, v);
        }
      }
      if (i & 4 && ((r = t.stateNode), r != null)) {
        var s = t.memoizedProps,
          o = n !== null ? n.memoizedProps : s,
          a = t.type,
          l = t.updateQueue;
        if (((t.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && uv(r, s),
              nd(a, o);
            var c = nd(a, s);
            for (o = 0; o < l.length; o += 2) {
              var u = l[o],
                f = l[o + 1];
              u === "style"
                ? mv(r, f)
                : u === "dangerouslySetInnerHTML"
                ? hv(r, f)
                : u === "children"
                ? ba(r, f)
                : Qh(r, u, f, c);
            }
            switch (a) {
              case "input":
                Zf(r, s);
                break;
              case "textarea":
                fv(r, s);
                break;
              case "select":
                var d = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var p = s.value;
                p != null
                  ? eo(r, !!s.multiple, p, !1)
                  : d !== !!s.multiple &&
                    (s.defaultValue != null
                      ? eo(r, !!s.multiple, s.defaultValue, !0)
                      : eo(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[Oa] = s;
          } catch (v) {
            wt(t, t.return, v);
          }
      }
      break;
    case 6:
      if ((jn(e, t), si(t), i & 4)) {
        if (t.stateNode === null) throw Error(ne(162));
        (r = t.stateNode), (s = t.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (v) {
          wt(t, t.return, v);
        }
      }
      break;
    case 3:
      if (
        (jn(e, t), si(t), i & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          La(e.containerInfo);
        } catch (v) {
          wt(t, t.return, v);
        }
      break;
    case 4:
      jn(e, t), si(t);
      break;
    case 13:
      jn(e, t),
        si(t),
        (r = t.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (Lp = bt())),
        i & 4 && Rg(t);
      break;
    case 22:
      if (
        ((u = n !== null && n.memoizedState !== null),
        t.mode & 1 ? ((Zt = (c = Zt) || u), jn(e, t), (Zt = c)) : jn(e, t),
        si(t),
        i & 8192)
      ) {
        if (
          ((c = t.memoizedState !== null),
          (t.stateNode.isHidden = c) && !u && t.mode & 1)
        )
          for (me = t, u = t.child; u !== null; ) {
            for (f = me = u; me !== null; ) {
              switch (((d = me), (p = d.child), d.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  va(4, d, d.return);
                  break;
                case 1:
                  Ks(d, d.return);
                  var g = d.stateNode;
                  if (typeof g.componentWillUnmount == "function") {
                    (i = d), (n = d.return);
                    try {
                      (e = i),
                        (g.props = e.memoizedProps),
                        (g.state = e.memoizedState),
                        g.componentWillUnmount();
                    } catch (v) {
                      wt(i, n, v);
                    }
                  }
                  break;
                case 5:
                  Ks(d, d.return);
                  break;
                case 22:
                  if (d.memoizedState !== null) {
                    Pg(f);
                    continue;
                  }
              }
              p !== null ? ((p.return = d), (me = p)) : Pg(f);
            }
            u = u.sibling;
          }
        e: for (u = null, f = t; ; ) {
          if (f.tag === 5) {
            if (u === null) {
              u = f;
              try {
                (r = f.stateNode),
                  c
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = f.stateNode),
                      (l = f.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = pv("display", o)));
              } catch (v) {
                wt(t, t.return, v);
              }
            }
          } else if (f.tag === 6) {
            if (u === null)
              try {
                f.stateNode.nodeValue = c ? "" : f.memoizedProps;
              } catch (v) {
                wt(t, t.return, v);
              }
          } else if (
            ((f.tag !== 22 && f.tag !== 23) ||
              f.memoizedState === null ||
              f === t) &&
            f.child !== null
          ) {
            (f.child.return = f), (f = f.child);
            continue;
          }
          if (f === t) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === t) break e;
            u === f && (u = null), (f = f.return);
          }
          u === f && (u = null), (f.sibling.return = f.return), (f = f.sibling);
        }
      }
      break;
    case 19:
      jn(e, t), si(t), i & 4 && Rg(t);
      break;
    case 21:
      break;
    default:
      jn(e, t), si(t);
  }
}
function si(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var n = t.return; n !== null; ) {
          if (zy(n)) {
            var i = n;
            break e;
          }
          n = n.return;
        }
        throw Error(ne(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (ba(r, ""), (i.flags &= -33));
          var s = bg(t);
          Id(t, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = bg(t);
          Ld(t, a, o);
          break;
        default:
          throw Error(ne(161));
      }
    } catch (l) {
      wt(t, t.return, l);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function zE(t, e, n) {
  (me = t), Gy(t);
}
function Gy(t, e, n) {
  for (var i = (t.mode & 1) !== 0; me !== null; ) {
    var r = me,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || Sl;
      if (!o) {
        var a = r.alternate,
          l = (a !== null && a.memoizedState !== null) || Zt;
        a = Sl;
        var c = Zt;
        if (((Sl = o), (Zt = l) && !c))
          for (me = r; me !== null; )
            (o = me),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? Lg(r)
                : l !== null
                ? ((l.return = o), (me = l))
                : Lg(r);
        for (; s !== null; ) (me = s), Gy(s), (s = s.sibling);
        (me = r), (Sl = a), (Zt = c);
      }
      Cg(t);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (me = s)) : Cg(t);
  }
}
function Cg(t) {
  for (; me !== null; ) {
    var e = me;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Zt || uu(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !Zt)
                if (n === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? n.memoizedProps
                      : qn(e.type, n.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    n.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && hg(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode;
                      break;
                    case 1:
                      n = e.child.stateNode;
                  }
                hg(e, o, n);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (n === null && e.flags & 4) {
                n = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var f = u.dehydrated;
                    f !== null && La(f);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(ne(163));
          }
        Zt || (e.flags & 512 && Pd(e));
      } catch (d) {
        wt(e, e.return, d);
      }
    }
    if (e === t) {
      me = null;
      break;
    }
    if (((n = e.sibling), n !== null)) {
      (n.return = e.return), (me = n);
      break;
    }
    me = e.return;
  }
}
function Pg(t) {
  for (; me !== null; ) {
    var e = me;
    if (e === t) {
      me = null;
      break;
    }
    var n = e.sibling;
    if (n !== null) {
      (n.return = e.return), (me = n);
      break;
    }
    me = e.return;
  }
}
function Lg(t) {
  for (; me !== null; ) {
    var e = me;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            uu(4, e);
          } catch (l) {
            wt(e, n, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              wt(e, r, l);
            }
          }
          var s = e.return;
          try {
            Pd(e);
          } catch (l) {
            wt(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            Pd(e);
          } catch (l) {
            wt(e, o, l);
          }
      }
    } catch (l) {
      wt(e, e.return, l);
    }
    if (e === t) {
      me = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (me = a);
      break;
    }
    me = e.return;
  }
}
var HE = Math.ceil,
  Vc = Ji.ReactCurrentDispatcher,
  Cp = Ji.ReactCurrentOwner,
  zn = Ji.ReactCurrentBatchConfig,
  Qe = 0,
  Bt = null,
  Ct = null,
  Wt = 0,
  Tn = 0,
  qs = Br(0),
  It = 0,
  Va = null,
  fs = 0,
  fu = 0,
  Pp = 0,
  ya = null,
  pn = null,
  Lp = 0,
  yo = 1 / 0,
  Di = null,
  Gc = !1,
  Dd = null,
  br = null,
  Ml = !1,
  xr = null,
  Wc = 0,
  xa = 0,
  Nd = null,
  fc = -1,
  dc = 0;
function an() {
  return Qe & 6 ? bt() : fc !== -1 ? fc : (fc = bt());
}
function Rr(t) {
  return t.mode & 1
    ? Qe & 2 && Wt !== 0
      ? Wt & -Wt
      : TE.transition !== null
      ? (dc === 0 && (dc = bv()), dc)
      : ((t = ot),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : Nv(t.type))),
        t)
    : 1;
}
function ti(t, e, n, i) {
  if (50 < xa) throw ((xa = 0), (Nd = null), Error(ne(185)));
  $a(t, n, i),
    (!(Qe & 2) || t !== Bt) &&
      (t === Bt && (!(Qe & 2) && (fu |= n), It === 4 && _r(t, Wt)),
      yn(t, i),
      n === 1 && Qe === 0 && !(e.mode & 1) && ((yo = bt() + 500), au && zr()));
}
function yn(t, e) {
  var n = t.callbackNode;
  TM(t, e);
  var i = bc(t, t === Bt ? Wt : 0);
  if (i === 0)
    n !== null && zm(n), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = i & -i), t.callbackPriority !== e)) {
    if ((n != null && zm(n), e === 1))
      t.tag === 0 ? EE(Ig.bind(null, t)) : Jv(Ig.bind(null, t)),
        yE(function () {
          !(Qe & 6) && zr();
        }),
        (n = null);
    else {
      switch (Rv(i)) {
        case 1:
          n = ip;
          break;
        case 4:
          n = wv;
          break;
        case 16:
          n = Ac;
          break;
        case 536870912:
          n = Av;
          break;
        default:
          n = Ac;
      }
      n = Zy(n, Wy.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = n);
  }
}
function Wy(t, e) {
  if (((fc = -1), (dc = 0), Qe & 6)) throw Error(ne(327));
  var n = t.callbackNode;
  if (so() && t.callbackNode !== n) return null;
  var i = bc(t, t === Bt ? Wt : 0);
  if (i === 0) return null;
  if (i & 30 || i & t.expiredLanes || e) e = jc(t, i);
  else {
    e = i;
    var r = Qe;
    Qe |= 2;
    var s = Xy();
    (Bt !== t || Wt !== e) && ((Di = null), (yo = bt() + 500), os(t, e));
    do
      try {
        WE();
        break;
      } catch (a) {
        jy(t, a);
      }
    while (!0);
    gp(),
      (Vc.current = s),
      (Qe = r),
      Ct !== null ? (e = 0) : ((Bt = null), (Wt = 0), (e = It));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = ad(t)), r !== 0 && ((i = r), (e = Ud(t, r)))), e === 1)
    )
      throw ((n = Va), os(t, 0), _r(t, i), yn(t, bt()), n);
    if (e === 6) _r(t, i);
    else {
      if (
        ((r = t.current.alternate),
        !(i & 30) &&
          !VE(r) &&
          ((e = jc(t, i)),
          e === 2 && ((s = ad(t)), s !== 0 && ((i = s), (e = Ud(t, s)))),
          e === 1))
      )
        throw ((n = Va), os(t, 0), _r(t, i), yn(t, bt()), n);
      switch (((t.finishedWork = r), (t.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(ne(345));
        case 2:
          $r(t, pn, Di);
          break;
        case 3:
          if (
            (_r(t, i), (i & 130023424) === i && ((e = Lp + 500 - bt()), 10 < e))
          ) {
            if (bc(t, 0) !== 0) break;
            if (((r = t.suspendedLanes), (r & i) !== i)) {
              an(), (t.pingedLanes |= t.suspendedLanes & r);
              break;
            }
            t.timeoutHandle = md($r.bind(null, t, pn, Di), e);
            break;
          }
          $r(t, pn, Di);
          break;
        case 4:
          if ((_r(t, i), (i & 4194240) === i)) break;
          for (e = t.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - ei(i);
            (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
          }
          if (
            ((i = r),
            (i = bt() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * HE(i / 1960)) - i),
            10 < i)
          ) {
            t.timeoutHandle = md($r.bind(null, t, pn, Di), i);
            break;
          }
          $r(t, pn, Di);
          break;
        case 5:
          $r(t, pn, Di);
          break;
        default:
          throw Error(ne(329));
      }
    }
  }
  return yn(t, bt()), t.callbackNode === n ? Wy.bind(null, t) : null;
}
function Ud(t, e) {
  var n = ya;
  return (
    t.current.memoizedState.isDehydrated && (os(t, e).flags |= 256),
    (t = jc(t, e)),
    t !== 2 && ((e = pn), (pn = n), e !== null && Od(e)),
    t
  );
}
function Od(t) {
  pn === null ? (pn = t) : pn.push.apply(pn, t);
}
function VE(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var i = 0; i < n.length; i++) {
          var r = n[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!ii(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null))
      (n.return = e), (e = n);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function _r(t, e) {
  for (
    e &= ~Pp,
      e &= ~fu,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - ei(e),
      i = 1 << n;
    (t[n] = -1), (e &= ~i);
  }
}
function Ig(t) {
  if (Qe & 6) throw Error(ne(327));
  so();
  var e = bc(t, 0);
  if (!(e & 1)) return yn(t, bt()), null;
  var n = jc(t, e);
  if (t.tag !== 0 && n === 2) {
    var i = ad(t);
    i !== 0 && ((e = i), (n = Ud(t, i)));
  }
  if (n === 1) throw ((n = Va), os(t, 0), _r(t, e), yn(t, bt()), n);
  if (n === 6) throw Error(ne(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    $r(t, pn, Di),
    yn(t, bt()),
    null
  );
}
function Ip(t, e) {
  var n = Qe;
  Qe |= 1;
  try {
    return t(e);
  } finally {
    (Qe = n), Qe === 0 && ((yo = bt() + 500), au && zr());
  }
}
function ds(t) {
  xr !== null && xr.tag === 0 && !(Qe & 6) && so();
  var e = Qe;
  Qe |= 1;
  var n = zn.transition,
    i = ot;
  try {
    if (((zn.transition = null), (ot = 1), t)) return t();
  } finally {
    (ot = i), (zn.transition = n), (Qe = e), !(Qe & 6) && zr();
  }
}
function Dp() {
  (Tn = qs.current), gt(qs);
}
function os(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var n = t.timeoutHandle;
  if ((n !== -1 && ((t.timeoutHandle = -1), vE(n)), Ct !== null))
    for (n = Ct.return; n !== null; ) {
      var i = n;
      switch ((hp(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && Ic();
          break;
        case 3:
          _o(), gt(_n), gt(Jt), Mp();
          break;
        case 5:
          Sp(i);
          break;
        case 4:
          _o();
          break;
        case 13:
          gt(xt);
          break;
        case 19:
          gt(xt);
          break;
        case 10:
          _p(i.type._context);
          break;
        case 22:
        case 23:
          Dp();
      }
      n = n.return;
    }
  if (
    ((Bt = t),
    (Ct = t = Cr(t.current, null)),
    (Wt = Tn = e),
    (It = 0),
    (Va = null),
    (Pp = fu = fs = 0),
    (pn = ya = null),
    ts !== null)
  ) {
    for (e = 0; e < ts.length; e++)
      if (((n = ts[e]), (i = n.interleaved), i !== null)) {
        n.interleaved = null;
        var r = i.next,
          s = n.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = r), (i.next = o);
        }
        n.pending = i;
      }
    ts = null;
  }
  return t;
}
function jy(t, e) {
  do {
    var n = Ct;
    try {
      if ((gp(), (lc.current = Hc), zc)) {
        for (var i = St.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        zc = !1;
      }
      if (
        ((us = 0),
        (Ot = Lt = St = null),
        (_a = !1),
        (Ba = 0),
        (Cp.current = null),
        n === null || n.return === null)
      ) {
        (It = 1), (Va = e), (Ct = null);
        break;
      }
      e: {
        var s = t,
          o = n.return,
          a = n,
          l = e;
        if (
          ((e = Wt),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = a,
            f = u.tag;
          if (!(u.mode & 1) && (f === 0 || f === 11 || f === 15)) {
            var d = u.alternate;
            d
              ? ((u.updateQueue = d.updateQueue),
                (u.memoizedState = d.memoizedState),
                (u.lanes = d.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var p = yg(o);
          if (p !== null) {
            (p.flags &= -257),
              xg(p, o, a, s, e),
              p.mode & 1 && vg(s, c, e),
              (e = p),
              (l = c);
            var g = e.updateQueue;
            if (g === null) {
              var v = new Set();
              v.add(l), (e.updateQueue = v);
            } else g.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              vg(s, c, e), Np();
              break e;
            }
            l = Error(ne(426));
          }
        } else if (vt && a.mode & 1) {
          var m = yg(o);
          if (m !== null) {
            !(m.flags & 65536) && (m.flags |= 256),
              xg(m, o, a, s, e),
              pp(vo(l, a));
            break e;
          }
        }
        (s = l = vo(l, a)),
          It !== 4 && (It = 2),
          ya === null ? (ya = [s]) : ya.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var h = Ry(s, l, e);
              dg(s, h);
              break e;
            case 1:
              a = l;
              var _ = s.type,
                y = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof _.getDerivedStateFromError == "function" ||
                  (y !== null &&
                    typeof y.componentDidCatch == "function" &&
                    (br === null || !br.has(y))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var x = Cy(s, a, e);
                dg(s, x);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      Ky(n);
    } catch (C) {
      (e = C), Ct === n && n !== null && (Ct = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function Xy() {
  var t = Vc.current;
  return (Vc.current = Hc), t === null ? Hc : t;
}
function Np() {
  (It === 0 || It === 3 || It === 2) && (It = 4),
    Bt === null || (!(fs & 268435455) && !(fu & 268435455)) || _r(Bt, Wt);
}
function jc(t, e) {
  var n = Qe;
  Qe |= 2;
  var i = Xy();
  (Bt !== t || Wt !== e) && ((Di = null), os(t, e));
  do
    try {
      GE();
      break;
    } catch (r) {
      jy(t, r);
    }
  while (!0);
  if ((gp(), (Qe = n), (Vc.current = i), Ct !== null)) throw Error(ne(261));
  return (Bt = null), (Wt = 0), It;
}
function GE() {
  for (; Ct !== null; ) Yy(Ct);
}
function WE() {
  for (; Ct !== null && !mM(); ) Yy(Ct);
}
function Yy(t) {
  var e = $y(t.alternate, t, Tn);
  (t.memoizedProps = t.pendingProps),
    e === null ? Ky(t) : (Ct = e),
    (Cp.current = null);
}
function Ky(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((n = FE(n, e)), n !== null)) {
        (n.flags &= 32767), (Ct = n);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (It = 6), (Ct = null);
        return;
      }
    } else if (((n = OE(n, e, Tn)), n !== null)) {
      Ct = n;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Ct = e;
      return;
    }
    Ct = e = t;
  } while (e !== null);
  It === 0 && (It = 5);
}
function $r(t, e, n) {
  var i = ot,
    r = zn.transition;
  try {
    (zn.transition = null), (ot = 1), jE(t, e, n, i);
  } finally {
    (zn.transition = r), (ot = i);
  }
  return null;
}
function jE(t, e, n, i) {
  do so();
  while (xr !== null);
  if (Qe & 6) throw Error(ne(327));
  n = t.finishedWork;
  var r = t.finishedLanes;
  if (n === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current))
    throw Error(ne(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var s = n.lanes | n.childLanes;
  if (
    (wM(t, s),
    t === Bt && ((Ct = Bt = null), (Wt = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Ml ||
      ((Ml = !0),
      Zy(Ac, function () {
        return so(), null;
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    (s = zn.transition), (zn.transition = null);
    var o = ot;
    ot = 1;
    var a = Qe;
    (Qe |= 4),
      (Cp.current = null),
      BE(t, n),
      Vy(n, t),
      fE(hd),
      (Rc = !!dd),
      (hd = dd = null),
      (t.current = n),
      zE(n),
      gM(),
      (Qe = a),
      (ot = o),
      (zn.transition = s);
  } else t.current = n;
  if (
    (Ml && ((Ml = !1), (xr = t), (Wc = r)),
    (s = t.pendingLanes),
    s === 0 && (br = null),
    yM(n.stateNode),
    yn(t, bt()),
    e !== null)
  )
    for (i = t.onRecoverableError, n = 0; n < e.length; n++)
      (r = e[n]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (Gc) throw ((Gc = !1), (t = Dd), (Dd = null), t);
  return (
    Wc & 1 && t.tag !== 0 && so(),
    (s = t.pendingLanes),
    s & 1 ? (t === Nd ? xa++ : ((xa = 0), (Nd = t))) : (xa = 0),
    zr(),
    null
  );
}
function so() {
  if (xr !== null) {
    var t = Rv(Wc),
      e = zn.transition,
      n = ot;
    try {
      if (((zn.transition = null), (ot = 16 > t ? 16 : t), xr === null))
        var i = !1;
      else {
        if (((t = xr), (xr = null), (Wc = 0), Qe & 6)) throw Error(ne(331));
        var r = Qe;
        for (Qe |= 4, me = t.current; me !== null; ) {
          var s = me,
            o = s.child;
          if (me.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l];
                for (me = c; me !== null; ) {
                  var u = me;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      va(8, u, s);
                  }
                  var f = u.child;
                  if (f !== null) (f.return = u), (me = f);
                  else
                    for (; me !== null; ) {
                      u = me;
                      var d = u.sibling,
                        p = u.return;
                      if ((By(u), u === c)) {
                        me = null;
                        break;
                      }
                      if (d !== null) {
                        (d.return = p), (me = d);
                        break;
                      }
                      me = p;
                    }
                }
              }
              var g = s.alternate;
              if (g !== null) {
                var v = g.child;
                if (v !== null) {
                  g.child = null;
                  do {
                    var m = v.sibling;
                    (v.sibling = null), (v = m);
                  } while (v !== null);
                }
              }
              me = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (me = o);
          else
            e: for (; me !== null; ) {
              if (((s = me), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    va(9, s, s.return);
                }
              var h = s.sibling;
              if (h !== null) {
                (h.return = s.return), (me = h);
                break e;
              }
              me = s.return;
            }
        }
        var _ = t.current;
        for (me = _; me !== null; ) {
          o = me;
          var y = o.child;
          if (o.subtreeFlags & 2064 && y !== null) (y.return = o), (me = y);
          else
            e: for (o = _; me !== null; ) {
              if (((a = me), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      uu(9, a);
                  }
                } catch (C) {
                  wt(a, a.return, C);
                }
              if (a === o) {
                me = null;
                break e;
              }
              var x = a.sibling;
              if (x !== null) {
                (x.return = a.return), (me = x);
                break e;
              }
              me = a.return;
            }
        }
        if (
          ((Qe = r), zr(), mi && typeof mi.onPostCommitFiberRoot == "function")
        )
          try {
            mi.onPostCommitFiberRoot(nu, t);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (ot = n), (zn.transition = e);
    }
  }
  return !1;
}
function Dg(t, e, n) {
  (e = vo(n, e)),
    (e = Ry(t, e, 1)),
    (t = Ar(t, e, 1)),
    (e = an()),
    t !== null && ($a(t, 1, e), yn(t, e));
}
function wt(t, e, n) {
  if (t.tag === 3) Dg(t, t, n);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        Dg(e, t, n);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (br === null || !br.has(i)))
        ) {
          (t = vo(n, t)),
            (t = Cy(e, t, 1)),
            (e = Ar(e, t, 1)),
            (t = an()),
            e !== null && ($a(e, 1, t), yn(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function XE(t, e, n) {
  var i = t.pingCache;
  i !== null && i.delete(e),
    (e = an()),
    (t.pingedLanes |= t.suspendedLanes & n),
    Bt === t &&
      (Wt & n) === n &&
      (It === 4 || (It === 3 && (Wt & 130023424) === Wt && 500 > bt() - Lp)
        ? os(t, 0)
        : (Pp |= n)),
    yn(t, e);
}
function qy(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = dl), (dl <<= 1), !(dl & 130023424) && (dl = 4194304))
      : (e = 1));
  var n = an();
  (t = Yi(t, e)), t !== null && ($a(t, e, n), yn(t, n));
}
function YE(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), qy(t, n);
}
function KE(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var i = t.stateNode,
        r = t.memoizedState;
      r !== null && (n = r.retryLane);
      break;
    case 19:
      i = t.stateNode;
      break;
    default:
      throw Error(ne(314));
  }
  i !== null && i.delete(e), qy(t, n);
}
var $y;
$y = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || _n.current) mn = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return (mn = !1), UE(t, e, n);
      mn = !!(t.flags & 131072);
    }
  else (mn = !1), vt && e.flags & 1048576 && ey(e, Uc, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      uc(t, e), (t = e.pendingProps);
      var r = po(e, Jt.current);
      ro(e, n), (r = Tp(null, e, i, t, r, n));
      var s = wp();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            vn(i) ? ((s = !0), Dc(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            yp(e),
            (r.updater = cu),
            (e.stateNode = r),
            (r._reactInternals = e),
            Md(e, i, t, n),
            (e = wd(null, e, i, !0, s, n)))
          : ((e.tag = 0), vt && s && dp(e), sn(null, e, r, n), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (uc(t, e),
          (t = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = $E(i)),
          (t = qn(i, t)),
          r)
        ) {
          case 0:
            e = Td(null, e, i, t, n);
            break e;
          case 1:
            e = Eg(null, e, i, t, n);
            break e;
          case 11:
            e = Sg(null, e, i, t, n);
            break e;
          case 14:
            e = Mg(null, e, i, qn(i.type, t), n);
            break e;
        }
        throw Error(ne(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : qn(i, r)),
        Td(t, e, i, r, n)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : qn(i, r)),
        Eg(t, e, i, r, n)
      );
    case 3:
      e: {
        if ((Dy(e), t === null)) throw Error(ne(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          oy(t, e),
          kc(e, i, null, n);
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = vo(Error(ne(423)), e)), (e = Tg(t, e, i, n, r));
            break e;
          } else if (i !== r) {
            (r = vo(Error(ne(424)), e)), (e = Tg(t, e, i, n, r));
            break e;
          } else
            for (
              wn = wr(e.stateNode.containerInfo.firstChild),
                bn = e,
                vt = !0,
                Zn = null,
                n = ry(e, null, i, n),
                e.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((mo(), i === r)) {
            e = Ki(t, e, n);
            break e;
          }
          sn(t, e, i, n);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        ay(e),
        t === null && yd(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = t !== null ? t.memoizedProps : null),
        (o = r.children),
        pd(i, r) ? (o = null) : s !== null && pd(i, s) && (e.flags |= 32),
        Iy(t, e),
        sn(t, e, o, n),
        e.child
      );
    case 6:
      return t === null && yd(e), null;
    case 13:
      return Ny(t, e, n);
    case 4:
      return (
        xp(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        t === null ? (e.child = go(e, null, i, n)) : sn(t, e, i, n),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : qn(i, r)),
        Sg(t, e, i, r, n)
      );
    case 7:
      return sn(t, e, e.pendingProps, n), e.child;
    case 8:
      return sn(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return sn(t, e, e.pendingProps.children, n), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          ft(Oc, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (ii(s.value, o)) {
            if (s.children === r.children && !_n.current) {
              e = Ki(t, e, n);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === i) {
                    if (s.tag === 1) {
                      (l = Vi(-1, n & -n)), (l.tag = 2);
                      var c = s.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (s.lanes |= n),
                      (l = s.alternate),
                      l !== null && (l.lanes |= n),
                      xd(s.return, n, e),
                      (a.lanes |= n);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(ne(341));
                (o.lanes |= n),
                  (a = o.alternate),
                  a !== null && (a.lanes |= n),
                  xd(o, n, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        sn(t, e, r.children, n), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        ro(e, n),
        (r = Hn(r)),
        (i = i(r)),
        (e.flags |= 1),
        sn(t, e, i, n),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = qn(i, e.pendingProps)),
        (r = qn(i.type, r)),
        Mg(t, e, i, r, n)
      );
    case 15:
      return Py(t, e, e.type, e.pendingProps, n);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : qn(i, r)),
        uc(t, e),
        (e.tag = 1),
        vn(i) ? ((t = !0), Dc(e)) : (t = !1),
        ro(e, n),
        by(e, i, r),
        Md(e, i, r, n),
        wd(null, e, i, !0, t, n)
      );
    case 19:
      return Uy(t, e, n);
    case 22:
      return Ly(t, e, n);
  }
  throw Error(ne(156, e.tag));
};
function Zy(t, e) {
  return Tv(t, e);
}
function qE(t, e, n, i) {
  (this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function kn(t, e, n, i) {
  return new qE(t, e, n, i);
}
function Up(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function $E(t) {
  if (typeof t == "function") return Up(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === ep)) return 11;
    if (t === tp) return 14;
  }
  return 2;
}
function Cr(t, e) {
  var n = t.alternate;
  return (
    n === null
      ? ((n = kn(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  );
}
function hc(t, e, n, i, r, s) {
  var o = 2;
  if (((i = t), typeof t == "function")) Up(t) && (o = 1);
  else if (typeof t == "string") o = 5;
  else
    e: switch (t) {
      case Bs:
        return as(n.children, r, s, e);
      case Jh:
        (o = 8), (r |= 8);
        break;
      case Xf:
        return (
          (t = kn(12, n, e, r | 2)), (t.elementType = Xf), (t.lanes = s), t
        );
      case Yf:
        return (t = kn(13, n, e, r)), (t.elementType = Yf), (t.lanes = s), t;
      case Kf:
        return (t = kn(19, n, e, r)), (t.elementType = Kf), (t.lanes = s), t;
      case av:
        return du(n, r, s, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case sv:
              o = 10;
              break e;
            case ov:
              o = 9;
              break e;
            case ep:
              o = 11;
              break e;
            case tp:
              o = 14;
              break e;
            case hr:
              (o = 16), (i = null);
              break e;
          }
        throw Error(ne(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = kn(o, n, e, r)), (e.elementType = t), (e.type = i), (e.lanes = s), e
  );
}
function as(t, e, n, i) {
  return (t = kn(7, t, i, e)), (t.lanes = n), t;
}
function du(t, e, n, i) {
  return (
    (t = kn(22, t, i, e)),
    (t.elementType = av),
    (t.lanes = n),
    (t.stateNode = { isHidden: !1 }),
    t
  );
}
function Zu(t, e, n) {
  return (t = kn(6, t, null, e)), (t.lanes = n), t;
}
function Qu(t, e, n) {
  return (
    (e = kn(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function ZE(t, e, n, i, r) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Iu(0)),
    (this.expirationTimes = Iu(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Iu(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function Op(t, e, n, i, r, s, o, a, l) {
  return (
    (t = new ZE(t, e, n, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = kn(3, null, null, e)),
    (t.current = s),
    (s.stateNode = t),
    (s.memoizedState = {
      element: i,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    yp(s),
    t
  );
}
function QE(t, e, n) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: ks,
    key: i == null ? null : "" + i,
    children: t,
    containerInfo: e,
    implementation: n,
  };
}
function Qy(t) {
  if (!t) return Dr;
  t = t._reactInternals;
  e: {
    if (vs(t) !== t || t.tag !== 1) throw Error(ne(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (vn(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(ne(171));
  }
  if (t.tag === 1) {
    var n = t.type;
    if (vn(n)) return Qv(t, n, e);
  }
  return e;
}
function Jy(t, e, n, i, r, s, o, a, l) {
  return (
    (t = Op(n, i, !0, t, r, s, o, a, l)),
    (t.context = Qy(null)),
    (n = t.current),
    (i = an()),
    (r = Rr(n)),
    (s = Vi(i, r)),
    (s.callback = e ?? null),
    Ar(n, s, r),
    (t.current.lanes = r),
    $a(t, r, i),
    yn(t, i),
    t
  );
}
function hu(t, e, n, i) {
  var r = e.current,
    s = an(),
    o = Rr(r);
  return (
    (n = Qy(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = Vi(s, o)),
    (e.payload = { element: t }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (t = Ar(r, e, o)),
    t !== null && (ti(t, r, o, s), ac(t, r, o)),
    o
  );
}
function Xc(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function Ng(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e;
  }
}
function Fp(t, e) {
  Ng(t, e), (t = t.alternate) && Ng(t, e);
}
function JE() {
  return null;
}
var ex =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function kp(t) {
  this._internalRoot = t;
}
pu.prototype.render = kp.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(ne(409));
  hu(t, e, null, null);
};
pu.prototype.unmount = kp.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    ds(function () {
      hu(null, t, null, null);
    }),
      (e[Xi] = null);
  }
};
function pu(t) {
  this._internalRoot = t;
}
pu.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = Lv();
    t = { blockedOn: null, target: t, priority: e };
    for (var n = 0; n < gr.length && e !== 0 && e < gr[n].priority; n++);
    gr.splice(n, 0, t), n === 0 && Dv(t);
  }
};
function Bp(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function mu(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function Ug() {}
function e1(t, e, n, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var c = Xc(o);
        s.call(c);
      };
    }
    var o = Jy(e, i, t, 0, null, !1, !1, "", Ug);
    return (
      (t._reactRootContainer = o),
      (t[Xi] = o.current),
      Na(t.nodeType === 8 ? t.parentNode : t),
      ds(),
      o
    );
  }
  for (; (r = t.lastChild); ) t.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var c = Xc(l);
      a.call(c);
    };
  }
  var l = Op(t, 0, !1, null, null, !1, !1, "", Ug);
  return (
    (t._reactRootContainer = l),
    (t[Xi] = l.current),
    Na(t.nodeType === 8 ? t.parentNode : t),
    ds(function () {
      hu(e, l, n, i);
    }),
    l
  );
}
function gu(t, e, n, i, r) {
  var s = n._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var l = Xc(o);
        a.call(l);
      };
    }
    hu(e, o, t, r);
  } else o = e1(n, e, t, r, i);
  return Xc(o);
}
Cv = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = oa(e.pendingLanes);
        n !== 0 &&
          (rp(e, n | 1), yn(e, bt()), !(Qe & 6) && ((yo = bt() + 500), zr()));
      }
      break;
    case 13:
      ds(function () {
        var i = Yi(t, 1);
        if (i !== null) {
          var r = an();
          ti(i, t, 1, r);
        }
      }),
        Fp(t, 1);
  }
};
sp = function (t) {
  if (t.tag === 13) {
    var e = Yi(t, 134217728);
    if (e !== null) {
      var n = an();
      ti(e, t, 134217728, n);
    }
    Fp(t, 134217728);
  }
};
Pv = function (t) {
  if (t.tag === 13) {
    var e = Rr(t),
      n = Yi(t, e);
    if (n !== null) {
      var i = an();
      ti(n, t, e, i);
    }
    Fp(t, e);
  }
};
Lv = function () {
  return ot;
};
Iv = function (t, e) {
  var n = ot;
  try {
    return (ot = t), e();
  } finally {
    ot = n;
  }
};
rd = function (t, e, n) {
  switch (e) {
    case "input":
      if ((Zf(t, n), (e = n.name), n.type === "radio" && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < n.length;
          e++
        ) {
          var i = n[e];
          if (i !== t && i.form === t.form) {
            var r = ou(i);
            if (!r) throw Error(ne(90));
            cv(i), Zf(i, r);
          }
        }
      }
      break;
    case "textarea":
      fv(t, n);
      break;
    case "select":
      (e = n.value), e != null && eo(t, !!n.multiple, e, !1);
  }
};
vv = Ip;
yv = ds;
var t1 = { usingClientEntryPoint: !1, Events: [Qa, Gs, ou, gv, _v, Ip] },
  Ko = {
    findFiberByHostInstance: es,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  n1 = {
    bundleType: Ko.bundleType,
    version: Ko.version,
    rendererPackageName: Ko.rendererPackageName,
    rendererConfig: Ko.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Ji.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = Mv(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: Ko.findFiberByHostInstance || JE,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var El = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!El.isDisabled && El.supportsFiber)
    try {
      (nu = El.inject(n1)), (mi = El);
    } catch {}
}
Cn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = t1;
Cn.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Bp(e)) throw Error(ne(200));
  return QE(t, e, null, n);
};
Cn.createRoot = function (t, e) {
  if (!Bp(t)) throw Error(ne(299));
  var n = !1,
    i = "",
    r = ex;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = Op(t, 1, !1, null, null, n, !1, i, r)),
    (t[Xi] = e.current),
    Na(t.nodeType === 8 ? t.parentNode : t),
    new kp(e)
  );
};
Cn.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(ne(188))
      : ((t = Object.keys(t).join(",")), Error(ne(268, t)));
  return (t = Mv(e)), (t = t === null ? null : t.stateNode), t;
};
Cn.flushSync = function (t) {
  return ds(t);
};
Cn.hydrate = function (t, e, n) {
  if (!mu(e)) throw Error(ne(200));
  return gu(null, t, e, !0, n);
};
Cn.hydrateRoot = function (t, e, n) {
  if (!Bp(t)) throw Error(ne(405));
  var i = (n != null && n.hydratedSources) || null,
    r = !1,
    s = "",
    o = ex;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (r = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    (e = Jy(e, null, t, 1, n ?? null, r, !1, s, o)),
    (t[Xi] = e.current),
    Na(t),
    i)
  )
    for (t = 0; t < i.length; t++)
      (n = i[t]),
        (r = n._getVersion),
        (r = r(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, r])
          : e.mutableSourceEagerHydrationData.push(n, r);
  return new pu(e);
};
Cn.render = function (t, e, n) {
  if (!mu(e)) throw Error(ne(200));
  return gu(null, t, e, !1, n);
};
Cn.unmountComponentAtNode = function (t) {
  if (!mu(t)) throw Error(ne(40));
  return t._reactRootContainer
    ? (ds(function () {
        gu(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[Xi] = null);
        });
      }),
      !0)
    : !1;
};
Cn.unstable_batchedUpdates = Ip;
Cn.unstable_renderSubtreeIntoContainer = function (t, e, n, i) {
  if (!mu(n)) throw Error(ne(200));
  if (t == null || t._reactInternals === void 0) throw Error(ne(38));
  return gu(t, e, n, !1, i);
};
Cn.version = "18.3.1-next-f1338f8080-20240426";
function tx() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(tx);
    } catch (t) {
      console.error(t);
    }
}
tx(), (tv.exports = Cn);
var i1 = tv.exports,
  Og = i1;
(Wf.createRoot = Og.createRoot), (Wf.hydrateRoot = Og.hydrateRoot);
function r1({ data: t }) {
  return K.jsxs("div", {
    className: "coinBlock",
    children: [
      K.jsx("img", { src: t.image, alt: t.name }),
      K.jsx("h4", { children: t.name }),
      K.jsxs("h5", {
        children: ["Current Price: ", t.current_price.toPrecision(6), ""],
      }),
      K.jsx("h5", { children: "24h Stats:" }),
      K.jsxs("ul", {
        children: [
          K.jsxs("li", {
            children: [
              "Change",
              " ",
              K.jsxs("span", {
                className:
                  t.price_change_percentage_24h > 0 ? "priceUp" : "priceDown",
                children: [t.price_change_percentage_24h.toPrecision(3), "%"],
              }),
            ],
          }),
          K.jsxs("li", { children: ["Highest ", t.high_24h, ""] }),
          K.jsxs("li", { children: ["Lowest ", t.low_24h, ""] }),
        ],
      }),
    ],
  });
}
function s1({ searchedCoin: t }) {
  const [e, n] = Qt.useState(null),
    [i, r] = Qt.useState(!0),
    [s, o] = Qt.useState(null),
    l =
      "https://api.coingecko.com/api/v3/coins/markets?vs_currency=eur&x_cg_demo_api_key=CG-zEk8F4YMVVXTAT3xLKPDmn4R",
    c = { method: "GET", headers: { accept: "application/json" } };
  return (
    Qt.useEffect(() => {
      async function u() {
        try {
          const d = await (await fetch(l, c)).json(),
            p = t
              ? d.filter(
                  (g) =>
                    g.name.toLowerCase().includes(t.toLowerCase()) ||
                    g.symbol.toLowerCase().includes(t.toLowerCase())
                )
              : d;
          n(p), r(!1);
        } catch (f) {
          o(f), r(!1), console.error(f);
        }
      }
      u();
    }, [l, c, t]),
    i
      ? K.jsx("div", {
          className: "coinContainer",
          children: [...Array(12)].map((u, f) =>
            K.jsx(
              "div",
              {
                className: "coinBlock coinLoaderPosition",
                children: K.jsx("div", { className: "coinLoader" }),
              },
              f
            )
          ),
        })
      : s
      ? K.jsx("div", { className: "coinError" })
      : K.jsx("div", {
          className: "coinContainer",
          children: e.map((u) => K.jsx(r1, { data: u }, u.id)),
        })
  );
}
function o1({ onSearch: t }) {
  const [e, n] = Qt.useState("");
  async function i() {
    let s = document.querySelector(".searchBlock");
    await new Promise((o) => setTimeout(o, 200)),
      s.classList.toggle("searchCoinToggle");
  }
  function r() {
    t(e), n("");
  }
  return K.jsxs(K.Fragment, {
    children: [
      K.jsxs("div", {
        className: "searchBlock",
        children: [
          K.jsx("h4", {
            className: "searchCoinText",
            children:
              "Type in your coin of interest! If you want to see all coins, search with empty field.",
          }),
          K.jsx("input", {
            value: e,
            onChange: (s) => n(s.target.value),
            type: "text",
            placeholder: "Bitcoin...",
            onKeyDown: (s) => (s.key === "Enter" ? r() : null),
          }),
          K.jsx("button", {
            onClick: r,
            className: "custom-button search-button",
            children: "Search",
          }),
        ],
      }),
      K.jsx("div", { onClick: i, className: "searchTriangle" }),
    ],
  });
}
function a1() {
  async function t() {
    let e = document.querySelector(".newsSearch");
    await new Promise((n) => setTimeout(n, 200)),
      e.classList.toggle("searchNewsToggle");
  }
  return K.jsxs(K.Fragment, {
    children: [
      K.jsxs("div", {
        className: "searchBlock newsSearch",
        children: [
          K.jsx("h4", { children: "Enter your keyword to search!" }),
          K.jsx("input", { type: "text", placeholder: "Crpyto..." }),
          K.jsx("button", {
            className: "custom-button search-button",
            children: "Search",
          }),
        ],
      }),
      K.jsx("div", { onClick: t, className: "searchTriangle newsToggle" }),
    ],
  });
}
/*!
 * Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */ function l1(t, e, n) {
  return (
    (e = u1(e)) in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function Fg(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(t, r).enumerable;
      })),
      n.push.apply(n, i);
  }
  return n;
}
function te(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? Fg(Object(n), !0).forEach(function (i) {
          l1(t, i, n[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : Fg(Object(n)).forEach(function (i) {
          Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i));
        });
  }
  return t;
}
function c1(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(t, e || "default");
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function u1(t) {
  var e = c1(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
const kg = () => {};
let zp = {},
  nx = {},
  ix = null,
  rx = { mark: kg, measure: kg };
try {
  typeof window < "u" && (zp = window),
    typeof document < "u" && (nx = document),
    typeof MutationObserver < "u" && (ix = MutationObserver),
    typeof performance < "u" && (rx = performance);
} catch {}
const { userAgent: Bg = "" } = zp.navigator || {},
  Nr = zp,
  _t = nx,
  zg = ix,
  Tl = rx;
Nr.document;
const er =
    !!_t.documentElement &&
    !!_t.head &&
    typeof _t.addEventListener == "function" &&
    typeof _t.createElement == "function",
  sx = ~Bg.indexOf("MSIE") || ~Bg.indexOf("Trident/");
var f1 = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/,
  d1 =
    /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i,
  ox = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands",
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin",
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin",
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin",
    },
  },
  h1 = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary",
  },
  ax = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"],
  en = "classic",
  _u = "duotone",
  p1 = "sharp",
  m1 = "sharp-duotone",
  lx = [en, _u, p1, m1],
  g1 = {
    classic: { 900: "fas", 400: "far", normal: "far", 300: "fal", 100: "fat" },
    duotone: { 900: "fad", 400: "fadr", 300: "fadl", 100: "fadt" },
    sharp: { 900: "fass", 400: "fasr", 300: "fasl", 100: "fast" },
    "sharp-duotone": { 900: "fasds", 400: "fasdr", 300: "fasdl", 100: "fasdt" },
  },
  _1 = {
    "Font Awesome 6 Free": { 900: "fas", 400: "far" },
    "Font Awesome 6 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat",
    },
    "Font Awesome 6 Brands": { 400: "fab", normal: "fab" },
    "Font Awesome 6 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt",
    },
    "Font Awesome 6 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast",
    },
    "Font Awesome 6 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt",
    },
  },
  v1 = new Map([
    [
      "classic",
      {
        defaultShortPrefixId: "fas",
        defaultStyleId: "solid",
        styleIds: ["solid", "regular", "light", "thin", "brands"],
        futureStyleIds: [],
        defaultFontWeight: 900,
      },
    ],
    [
      "sharp",
      {
        defaultShortPrefixId: "fass",
        defaultStyleId: "solid",
        styleIds: ["solid", "regular", "light", "thin"],
        futureStyleIds: [],
        defaultFontWeight: 900,
      },
    ],
    [
      "duotone",
      {
        defaultShortPrefixId: "fad",
        defaultStyleId: "solid",
        styleIds: ["solid", "regular", "light", "thin"],
        futureStyleIds: [],
        defaultFontWeight: 900,
      },
    ],
    [
      "sharp-duotone",
      {
        defaultShortPrefixId: "fasds",
        defaultStyleId: "solid",
        styleIds: ["solid", "regular", "light", "thin"],
        futureStyleIds: [],
        defaultFontWeight: 900,
      },
    ],
  ]),
  y1 = {
    classic: {
      solid: "fas",
      regular: "far",
      light: "fal",
      thin: "fat",
      brands: "fab",
    },
    duotone: { solid: "fad", regular: "fadr", light: "fadl", thin: "fadt" },
    sharp: { solid: "fass", regular: "fasr", light: "fasl", thin: "fast" },
    "sharp-duotone": {
      solid: "fasds",
      regular: "fasdr",
      light: "fasdl",
      thin: "fasdt",
    },
  },
  x1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"],
  Hg = {
    kit: { fak: "kit", "fa-kit": "kit" },
    "kit-duotone": { fakd: "kit-duotone", "fa-kit-duotone": "kit-duotone" },
  },
  S1 = ["kit"],
  M1 = {
    kit: { "fa-kit": "fak" },
    "kit-duotone": { "fa-kit-duotone": "fakd" },
  },
  E1 = ["fak", "fakd"],
  T1 = { kit: { fak: "fa-kit" }, "kit-duotone": { fakd: "fa-kit-duotone" } },
  Vg = { kit: { kit: "fak" }, "kit-duotone": { "kit-duotone": "fakd" } },
  wl = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary",
  },
  w1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"],
  A1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"],
  b1 = {
    "Font Awesome Kit": { 400: "fak", normal: "fak" },
    "Font Awesome Kit Duotone": { 400: "fakd", normal: "fakd" },
  },
  R1 = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat",
    },
    duotone: { "fa-regular": "fadr", "fa-light": "fadl", "fa-thin": "fadt" },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast",
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt",
    },
  },
  C1 = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
  },
  Fd = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin",
    },
    duotone: { fadr: "fa-regular", fadl: "fa-light", fadt: "fa-thin" },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin",
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin",
    },
  },
  P1 = [
    "fa-solid",
    "fa-regular",
    "fa-light",
    "fa-thin",
    "fa-duotone",
    "fa-brands",
  ],
  kd = [
    "fa",
    "fas",
    "far",
    "fal",
    "fat",
    "fad",
    "fadr",
    "fadl",
    "fadt",
    "fab",
    "fass",
    "fasr",
    "fasl",
    "fast",
    "fasds",
    "fasdr",
    "fasdl",
    "fasdt",
    ...w1,
    ...P1,
  ],
  L1 = ["solid", "regular", "light", "thin", "duotone", "brands"],
  cx = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  I1 = cx.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
  D1 = [
    ...Object.keys(C1),
    ...L1,
    "2xs",
    "xs",
    "sm",
    "lg",
    "xl",
    "2xl",
    "beat",
    "border",
    "fade",
    "beat-fade",
    "bounce",
    "flip-both",
    "flip-horizontal",
    "flip-vertical",
    "flip",
    "fw",
    "inverse",
    "layers-counter",
    "layers-text",
    "layers",
    "li",
    "pull-left",
    "pull-right",
    "pulse",
    "rotate-180",
    "rotate-270",
    "rotate-90",
    "rotate-by",
    "shake",
    "spin-pulse",
    "spin-reverse",
    "spin",
    "stack-1x",
    "stack-2x",
    "stack",
    "ul",
    wl.GROUP,
    wl.SWAP_OPACITY,
    wl.PRIMARY,
    wl.SECONDARY,
  ]
    .concat(cx.map((t) => "".concat(t, "x")))
    .concat(I1.map((t) => "w-".concat(t))),
  N1 = {
    "Font Awesome 5 Free": { 900: "fas", 400: "far" },
    "Font Awesome 5 Pro": { 900: "fas", 400: "far", normal: "far", 300: "fal" },
    "Font Awesome 5 Brands": { 400: "fab", normal: "fab" },
    "Font Awesome 5 Duotone": { 900: "fad" },
  };
const qi = "___FONT_AWESOME___",
  Bd = 16,
  ux = "fa",
  fx = "svg-inline--fa",
  hs = "data-fa-i2svg",
  zd = "data-fa-pseudo-element",
  U1 = "data-fa-pseudo-element-pending",
  Hp = "data-prefix",
  Vp = "data-icon",
  Gg = "fontawesome-i2svg",
  O1 = "async",
  F1 = ["HTML", "HEAD", "STYLE", "SCRIPT"],
  dx = (() => {
    try {
      return !0;
    } catch {
      return !1;
    }
  })();
function el(t) {
  return new Proxy(t, {
    get(e, n) {
      return n in e ? e[n] : e[en];
    },
  });
}
const hx = te({}, ox);
hx[en] = te(
  te(te(te({}, { "fa-duotone": "duotone" }), ox[en]), Hg.kit),
  Hg["kit-duotone"]
);
const k1 = el(hx),
  Hd = te({}, y1);
Hd[en] = te(
  te(te(te({}, { duotone: "fad" }), Hd[en]), Vg.kit),
  Vg["kit-duotone"]
);
const Wg = el(Hd),
  Vd = te({}, Fd);
Vd[en] = te(te({}, Vd[en]), T1.kit);
const Gp = el(Vd),
  Gd = te({}, R1);
Gd[en] = te(te({}, Gd[en]), M1.kit);
el(Gd);
const B1 = f1,
  px = "fa-layers-text",
  z1 = d1,
  H1 = te({}, g1);
el(H1);
const V1 = [
    "class",
    "data-prefix",
    "data-icon",
    "data-fa-transform",
    "data-fa-mask",
  ],
  Ju = h1,
  G1 = [...S1, ...D1],
  Sa = Nr.FontAwesomeConfig || {};
function W1(t) {
  var e = _t.querySelector("script[" + t + "]");
  if (e) return e.getAttribute(t);
}
function j1(t) {
  return t === "" ? !0 : t === "false" ? !1 : t === "true" ? !0 : t;
}
_t &&
  typeof _t.querySelector == "function" &&
  [
    ["data-family-prefix", "familyPrefix"],
    ["data-css-prefix", "cssPrefix"],
    ["data-family-default", "familyDefault"],
    ["data-style-default", "styleDefault"],
    ["data-replacement-class", "replacementClass"],
    ["data-auto-replace-svg", "autoReplaceSvg"],
    ["data-auto-add-css", "autoAddCss"],
    ["data-auto-a11y", "autoA11y"],
    ["data-search-pseudo-elements", "searchPseudoElements"],
    ["data-observe-mutations", "observeMutations"],
    ["data-mutate-approach", "mutateApproach"],
    ["data-keep-original-source", "keepOriginalSource"],
    ["data-measure-performance", "measurePerformance"],
    ["data-show-missing-icons", "showMissingIcons"],
  ].forEach((e) => {
    let [n, i] = e;
    const r = j1(W1(n));
    r != null && (Sa[i] = r);
  });
const mx = {
  styleDefault: "solid",
  familyDefault: en,
  cssPrefix: ux,
  replacementClass: fx,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0,
};
Sa.familyPrefix && (Sa.cssPrefix = Sa.familyPrefix);
const xo = te(te({}, mx), Sa);
xo.autoReplaceSvg || (xo.observeMutations = !1);
const Ee = {};
Object.keys(mx).forEach((t) => {
  Object.defineProperty(Ee, t, {
    enumerable: !0,
    set: function (e) {
      (xo[t] = e), Ma.forEach((n) => n(Ee));
    },
    get: function () {
      return xo[t];
    },
  });
});
Object.defineProperty(Ee, "familyPrefix", {
  enumerable: !0,
  set: function (t) {
    (xo.cssPrefix = t), Ma.forEach((e) => e(Ee));
  },
  get: function () {
    return xo.cssPrefix;
  },
});
Nr.FontAwesomeConfig = Ee;
const Ma = [];
function X1(t) {
  return (
    Ma.push(t),
    () => {
      Ma.splice(Ma.indexOf(t), 1);
    }
  );
}
const sr = Bd,
  fi = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 };
function Y1(t) {
  if (!t || !er) return;
  const e = _t.createElement("style");
  e.setAttribute("type", "text/css"), (e.innerHTML = t);
  const n = _t.head.childNodes;
  let i = null;
  for (let r = n.length - 1; r > -1; r--) {
    const s = n[r],
      o = (s.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(o) > -1 && (i = s);
  }
  return _t.head.insertBefore(e, i), t;
}
const K1 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function Ga() {
  let t = 12,
    e = "";
  for (; t-- > 0; ) e += K1[(Math.random() * 62) | 0];
  return e;
}
function Uo(t) {
  const e = [];
  for (let n = (t || []).length >>> 0; n--; ) e[n] = t[n];
  return e;
}
function Wp(t) {
  return t.classList
    ? Uo(t.classList)
    : (t.getAttribute("class") || "").split(" ").filter((e) => e);
}
function gx(t) {
  return ""
    .concat(t)
    .replace(/&/g, "&amp;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}
function q1(t) {
  return Object.keys(t || {})
    .reduce((e, n) => e + "".concat(n, '="').concat(gx(t[n]), '" '), "")
    .trim();
}
function vu(t) {
  return Object.keys(t || {}).reduce(
    (e, n) => e + "".concat(n, ": ").concat(t[n].trim(), ";"),
    ""
  );
}
function jp(t) {
  return (
    t.size !== fi.size ||
    t.x !== fi.x ||
    t.y !== fi.y ||
    t.rotate !== fi.rotate ||
    t.flipX ||
    t.flipY
  );
}
function $1(t) {
  let { transform: e, containerWidth: n, iconWidth: i } = t;
  const r = { transform: "translate(".concat(n / 2, " 256)") },
    s = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "),
    o = "scale("
      .concat((e.size / 16) * (e.flipX ? -1 : 1), ", ")
      .concat((e.size / 16) * (e.flipY ? -1 : 1), ") "),
    a = "rotate(".concat(e.rotate, " 0 0)"),
    l = { transform: "".concat(s, " ").concat(o, " ").concat(a) },
    c = { transform: "translate(".concat((i / 2) * -1, " -256)") };
  return { outer: r, inner: l, path: c };
}
function Z1(t) {
  let {
      transform: e,
      width: n = Bd,
      height: i = Bd,
      startCentered: r = !1,
    } = t,
    s = "";
  return (
    r && sx
      ? (s += "translate("
          .concat(e.x / sr - n / 2, "em, ")
          .concat(e.y / sr - i / 2, "em) "))
      : r
      ? (s += "translate(calc(-50% + "
          .concat(e.x / sr, "em), calc(-50% + ")
          .concat(e.y / sr, "em)) "))
      : (s += "translate(".concat(e.x / sr, "em, ").concat(e.y / sr, "em) ")),
    (s += "scale("
      .concat((e.size / sr) * (e.flipX ? -1 : 1), ", ")
      .concat((e.size / sr) * (e.flipY ? -1 : 1), ") ")),
    (s += "rotate(".concat(e.rotate, "deg) ")),
    s
  );
}
var Q1 = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function _x() {
  const t = ux,
    e = fx,
    n = Ee.cssPrefix,
    i = Ee.replacementClass;
  let r = Q1;
  if (n !== t || i !== e) {
    const s = new RegExp("\\.".concat(t, "\\-"), "g"),
      o = new RegExp("\\--".concat(t, "\\-"), "g"),
      a = new RegExp("\\.".concat(e), "g");
    r = r
      .replace(s, ".".concat(n, "-"))
      .replace(o, "--".concat(n, "-"))
      .replace(a, ".".concat(i));
  }
  return r;
}
let jg = !1;
function ef() {
  Ee.autoAddCss && !jg && (Y1(_x()), (jg = !0));
}
var J1 = {
  mixout() {
    return { dom: { css: _x, insertCss: ef } };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        ef();
      },
      beforeI2svg() {
        ef();
      },
    };
  },
};
const $i = Nr || {};
$i[qi] || ($i[qi] = {});
$i[qi].styles || ($i[qi].styles = {});
$i[qi].hooks || ($i[qi].hooks = {});
$i[qi].shims || ($i[qi].shims = []);
var di = $i[qi];
const vx = [],
  yx = function () {
    _t.removeEventListener("DOMContentLoaded", yx),
      (Yc = 1),
      vx.map((t) => t());
  };
let Yc = !1;
er &&
  ((Yc = (_t.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(
    _t.readyState
  )),
  Yc || _t.addEventListener("DOMContentLoaded", yx));
function eT(t) {
  er && (Yc ? setTimeout(t, 0) : vx.push(t));
}
function tl(t) {
  const { tag: e, attributes: n = {}, children: i = [] } = t;
  return typeof t == "string"
    ? gx(t)
    : "<"
        .concat(e, " ")
        .concat(q1(n), ">")
        .concat(i.map(tl).join(""), "</")
        .concat(e, ">");
}
function Xg(t, e, n) {
  if (t && t[e] && t[e][n]) return { prefix: e, iconName: n, icon: t[e][n] };
}
var tf = function (e, n, i, r) {
  var s = Object.keys(e),
    o = s.length,
    a = n,
    l,
    c,
    u;
  for (i === void 0 ? ((l = 1), (u = e[s[0]])) : ((l = 0), (u = i)); l < o; l++)
    (c = s[l]), (u = a(u, e[c], c, e));
  return u;
};
function tT(t) {
  const e = [];
  let n = 0;
  const i = t.length;
  for (; n < i; ) {
    const r = t.charCodeAt(n++);
    if (r >= 55296 && r <= 56319 && n < i) {
      const s = t.charCodeAt(n++);
      (s & 64512) == 56320
        ? e.push(((r & 1023) << 10) + (s & 1023) + 65536)
        : (e.push(r), n--);
    } else e.push(r);
  }
  return e;
}
function Wd(t) {
  const e = tT(t);
  return e.length === 1 ? e[0].toString(16) : null;
}
function nT(t, e) {
  const n = t.length;
  let i = t.charCodeAt(e),
    r;
  return i >= 55296 &&
    i <= 56319 &&
    n > e + 1 &&
    ((r = t.charCodeAt(e + 1)), r >= 56320 && r <= 57343)
    ? (i - 55296) * 1024 + r - 56320 + 65536
    : i;
}
function Yg(t) {
  return Object.keys(t).reduce((e, n) => {
    const i = t[n];
    return !!i.icon ? (e[i.iconName] = i.icon) : (e[n] = i), e;
  }, {});
}
function jd(t, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const { skipHooks: i = !1 } = n,
    r = Yg(e);
  typeof di.hooks.addPack == "function" && !i
    ? di.hooks.addPack(t, Yg(e))
    : (di.styles[t] = te(te({}, di.styles[t] || {}), r)),
    t === "fas" && jd("fa", e);
}
const { styles: Wa, shims: iT } = di,
  xx = Object.keys(Gp),
  rT = xx.reduce((t, e) => ((t[e] = Object.keys(Gp[e])), t), {});
let Xp = null,
  Sx = {},
  Mx = {},
  Ex = {},
  Tx = {},
  wx = {};
function sT(t) {
  return ~G1.indexOf(t);
}
function oT(t, e) {
  const n = e.split("-"),
    i = n[0],
    r = n.slice(1).join("-");
  return i === t && r !== "" && !sT(r) ? r : null;
}
const Ax = () => {
  const t = (i) => tf(Wa, (r, s, o) => ((r[o] = tf(s, i, {})), r), {});
  (Sx = t(
    (i, r, s) => (
      r[3] && (i[r[3]] = s),
      r[2] &&
        r[2]
          .filter((a) => typeof a == "number")
          .forEach((a) => {
            i[a.toString(16)] = s;
          }),
      i
    )
  )),
    (Mx = t(
      (i, r, s) => (
        (i[s] = s),
        r[2] &&
          r[2]
            .filter((a) => typeof a == "string")
            .forEach((a) => {
              i[a] = s;
            }),
        i
      )
    )),
    (wx = t((i, r, s) => {
      const o = r[2];
      return (
        (i[s] = s),
        o.forEach((a) => {
          i[a] = s;
        }),
        i
      );
    }));
  const e = "far" in Wa || Ee.autoFetchSvg,
    n = tf(
      iT,
      (i, r) => {
        const s = r[0];
        let o = r[1];
        const a = r[2];
        return (
          o === "far" && !e && (o = "fas"),
          typeof s == "string" && (i.names[s] = { prefix: o, iconName: a }),
          typeof s == "number" &&
            (i.unicodes[s.toString(16)] = { prefix: o, iconName: a }),
          i
        );
      },
      { names: {}, unicodes: {} }
    );
  (Ex = n.names),
    (Tx = n.unicodes),
    (Xp = yu(Ee.styleDefault, { family: Ee.familyDefault }));
};
X1((t) => {
  Xp = yu(t.styleDefault, { family: Ee.familyDefault });
});
Ax();
function Yp(t, e) {
  return (Sx[t] || {})[e];
}
function aT(t, e) {
  return (Mx[t] || {})[e];
}
function is(t, e) {
  return (wx[t] || {})[e];
}
function bx(t) {
  return Ex[t] || { prefix: null, iconName: null };
}
function lT(t) {
  const e = Tx[t],
    n = Yp("fas", t);
  return (
    e ||
    (n ? { prefix: "fas", iconName: n } : null) || {
      prefix: null,
      iconName: null,
    }
  );
}
function Ur() {
  return Xp;
}
const Rx = () => ({ prefix: null, iconName: null, rest: [] });
function cT(t) {
  let e = en;
  const n = xx.reduce(
    (i, r) => ((i[r] = "".concat(Ee.cssPrefix, "-").concat(r)), i),
    {}
  );
  return (
    lx.forEach((i) => {
      (t.includes(n[i]) || t.some((r) => rT[i].includes(r))) && (e = i);
    }),
    e
  );
}
function yu(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const { family: n = en } = e,
    i = k1[n][t];
  if (n === _u && !t) return "fad";
  const r = Wg[n][t] || Wg[n][i],
    s = t in di.styles ? t : null;
  return r || s || null;
}
function uT(t) {
  let e = [],
    n = null;
  return (
    t.forEach((i) => {
      const r = oT(Ee.cssPrefix, i);
      r ? (n = r) : i && e.push(i);
    }),
    { iconName: n, rest: e }
  );
}
function Kg(t) {
  return t.sort().filter((e, n, i) => i.indexOf(e) === n);
}
function xu(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const { skipLookups: n = !1 } = e;
  let i = null;
  const r = kd.concat(A1),
    s = Kg(t.filter((f) => r.includes(f))),
    o = Kg(t.filter((f) => !kd.includes(f))),
    a = s.filter((f) => ((i = f), !ax.includes(f))),
    [l = null] = a,
    c = cT(s),
    u = te(te({}, uT(o)), {}, { prefix: yu(l, { family: c }) });
  return te(
    te(
      te({}, u),
      pT({
        values: t,
        family: c,
        styles: Wa,
        config: Ee,
        canonical: u,
        givenPrefix: i,
      })
    ),
    fT(n, i, u)
  );
}
function fT(t, e, n) {
  let { prefix: i, iconName: r } = n;
  if (t || !i || !r) return { prefix: i, iconName: r };
  const s = e === "fa" ? bx(r) : {},
    o = is(i, r);
  return (
    (r = s.iconName || o || r),
    (i = s.prefix || i),
    i === "far" && !Wa.far && Wa.fas && !Ee.autoFetchSvg && (i = "fas"),
    { prefix: i, iconName: r }
  );
}
const dT = lx.filter((t) => t !== en || t !== _u),
  hT = Object.keys(Fd)
    .filter((t) => t !== en)
    .map((t) => Object.keys(Fd[t]))
    .flat();
function pT(t) {
  const {
      values: e,
      family: n,
      canonical: i,
      givenPrefix: r = "",
      styles: s = {},
      config: o = {},
    } = t,
    a = n === _u,
    l = e.includes("fa-duotone") || e.includes("fad"),
    c = o.familyDefault === "duotone",
    u = i.prefix === "fad" || i.prefix === "fa-duotone";
  if (
    (!a && (l || c || u) && (i.prefix = "fad"),
    (e.includes("fa-brands") || e.includes("fab")) && (i.prefix = "fab"),
    !i.prefix &&
      dT.includes(n) &&
      (Object.keys(s).find((d) => hT.includes(d)) || o.autoFetchSvg))
  ) {
    const d = v1.get(n).defaultShortPrefixId;
    (i.prefix = d), (i.iconName = is(i.prefix, i.iconName) || i.iconName);
  }
  return (i.prefix === "fa" || r === "fa") && (i.prefix = Ur() || "fas"), i;
}
class mT {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)
      n[i] = arguments[i];
    const r = n.reduce(this._pullDefinitions, {});
    Object.keys(r).forEach((s) => {
      (this.definitions[s] = te(te({}, this.definitions[s] || {}), r[s])),
        jd(s, r[s]);
      const o = Gp[en][s];
      o && jd(o, r[s]), Ax();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(e, n) {
    const i = n.prefix && n.iconName && n.icon ? { 0: n } : n;
    return (
      Object.keys(i).map((r) => {
        const { prefix: s, iconName: o, icon: a } = i[r],
          l = a[2];
        e[s] || (e[s] = {}),
          l.length > 0 &&
            l.forEach((c) => {
              typeof c == "string" && (e[s][c] = a);
            }),
          (e[s][o] = a);
      }),
      e
    );
  }
}
let qg = [],
  $s = {};
const oo = {},
  gT = Object.keys(oo);
function _T(t, e) {
  let { mixoutsTo: n } = e;
  return (
    (qg = t),
    ($s = {}),
    Object.keys(oo).forEach((i) => {
      gT.indexOf(i) === -1 && delete oo[i];
    }),
    qg.forEach((i) => {
      const r = i.mixout ? i.mixout() : {};
      if (
        (Object.keys(r).forEach((s) => {
          typeof r[s] == "function" && (n[s] = r[s]),
            typeof r[s] == "object" &&
              Object.keys(r[s]).forEach((o) => {
                n[s] || (n[s] = {}), (n[s][o] = r[s][o]);
              });
        }),
        i.hooks)
      ) {
        const s = i.hooks();
        Object.keys(s).forEach((o) => {
          $s[o] || ($s[o] = []), $s[o].push(s[o]);
        });
      }
      i.provides && i.provides(oo);
    }),
    n
  );
}
function Xd(t, e) {
  for (
    var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2;
    r < n;
    r++
  )
    i[r - 2] = arguments[r];
  return (
    ($s[t] || []).forEach((o) => {
      e = o.apply(null, [e, ...i]);
    }),
    e
  );
}
function ps(t) {
  for (
    var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1;
    i < e;
    i++
  )
    n[i - 1] = arguments[i];
  ($s[t] || []).forEach((s) => {
    s.apply(null, n);
  });
}
function Or() {
  const t = arguments[0],
    e = Array.prototype.slice.call(arguments, 1);
  return oo[t] ? oo[t].apply(null, e) : void 0;
}
function Yd(t) {
  t.prefix === "fa" && (t.prefix = "fas");
  let { iconName: e } = t;
  const n = t.prefix || Ur();
  if (e)
    return (e = is(n, e) || e), Xg(Cx.definitions, n, e) || Xg(di.styles, n, e);
}
const Cx = new mT(),
  vT = () => {
    (Ee.autoReplaceSvg = !1), (Ee.observeMutations = !1), ps("noAuto");
  },
  yT = {
    i2svg: function () {
      let t =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return er
        ? (ps("beforeI2svg", t), Or("pseudoElements2svg", t), Or("i2svg", t))
        : Promise.reject(new Error("Operation requires a DOM of some kind."));
    },
    watch: function () {
      let t =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const { autoReplaceSvgRoot: e } = t;
      Ee.autoReplaceSvg === !1 && (Ee.autoReplaceSvg = !0),
        (Ee.observeMutations = !0),
        eT(() => {
          ST({ autoReplaceSvgRoot: e }), ps("watch", t);
        });
    },
  },
  xT = {
    icon: (t) => {
      if (t === null) return null;
      if (typeof t == "object" && t.prefix && t.iconName)
        return {
          prefix: t.prefix,
          iconName: is(t.prefix, t.iconName) || t.iconName,
        };
      if (Array.isArray(t) && t.length === 2) {
        const e = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1],
          n = yu(t[0]);
        return { prefix: n, iconName: is(n, e) || e };
      }
      if (
        typeof t == "string" &&
        (t.indexOf("".concat(Ee.cssPrefix, "-")) > -1 || t.match(B1))
      ) {
        const e = xu(t.split(" "), { skipLookups: !0 });
        return {
          prefix: e.prefix || Ur(),
          iconName: is(e.prefix, e.iconName) || e.iconName,
        };
      }
      if (typeof t == "string") {
        const e = Ur();
        return { prefix: e, iconName: is(e, t) || t };
      }
    },
  },
  Ln = {
    noAuto: vT,
    config: Ee,
    dom: yT,
    parse: xT,
    library: Cx,
    findIconDefinition: Yd,
    toHtml: tl,
  },
  ST = function () {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { autoReplaceSvgRoot: e = _t } = t;
    (Object.keys(di.styles).length > 0 || Ee.autoFetchSvg) &&
      er &&
      Ee.autoReplaceSvg &&
      Ln.dom.i2svg({ node: e });
  };
function Su(t, e) {
  return (
    Object.defineProperty(t, "abstract", { get: e }),
    Object.defineProperty(t, "html", {
      get: function () {
        return t.abstract.map((n) => tl(n));
      },
    }),
    Object.defineProperty(t, "node", {
      get: function () {
        if (!er) return;
        const n = _t.createElement("div");
        return (n.innerHTML = t.html), n.children;
      },
    }),
    t
  );
}
function MT(t) {
  let {
    children: e,
    main: n,
    mask: i,
    attributes: r,
    styles: s,
    transform: o,
  } = t;
  if (jp(o) && n.found && !i.found) {
    const { width: a, height: l } = n,
      c = { x: a / l / 2, y: 0.5 };
    r.style = vu(
      te(
        te({}, s),
        {},
        {
          "transform-origin": ""
            .concat(c.x + o.x / 16, "em ")
            .concat(c.y + o.y / 16, "em"),
        }
      )
    );
  }
  return [{ tag: "svg", attributes: r, children: e }];
}
function ET(t) {
  let { prefix: e, iconName: n, children: i, attributes: r, symbol: s } = t;
  const o =
    s === !0 ? "".concat(e, "-").concat(Ee.cssPrefix, "-").concat(n) : s;
  return [
    {
      tag: "svg",
      attributes: { style: "display: none;" },
      children: [
        {
          tag: "symbol",
          attributes: te(te({}, r), {}, { id: o }),
          children: i,
        },
      ],
    },
  ];
}
function Kp(t) {
  const {
      icons: { main: e, mask: n },
      prefix: i,
      iconName: r,
      transform: s,
      symbol: o,
      title: a,
      maskId: l,
      titleId: c,
      extra: u,
      watchable: f = !1,
    } = t,
    { width: d, height: p } = n.found ? n : e,
    g = E1.includes(i),
    v = [Ee.replacementClass, r ? "".concat(Ee.cssPrefix, "-").concat(r) : ""]
      .filter((C) => u.classes.indexOf(C) === -1)
      .filter((C) => C !== "" || !!C)
      .concat(u.classes)
      .join(" ");
  let m = {
    children: [],
    attributes: te(
      te({}, u.attributes),
      {},
      {
        "data-prefix": i,
        "data-icon": r,
        class: v,
        role: u.attributes.role || "img",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 ".concat(d, " ").concat(p),
      }
    ),
  };
  const h =
    g && !~u.classes.indexOf("fa-fw")
      ? { width: "".concat((d / p) * 16 * 0.0625, "em") }
      : {};
  f && (m.attributes[hs] = ""),
    a &&
      (m.children.push({
        tag: "title",
        attributes: {
          id: m.attributes["aria-labelledby"] || "title-".concat(c || Ga()),
        },
        children: [a],
      }),
      delete m.attributes.title);
  const _ = te(
      te({}, m),
      {},
      {
        prefix: i,
        iconName: r,
        main: e,
        mask: n,
        maskId: l,
        transform: s,
        symbol: o,
        styles: te(te({}, h), u.styles),
      }
    ),
    { children: y, attributes: x } =
      n.found && e.found
        ? Or("generateAbstractMask", _) || { children: [], attributes: {} }
        : Or("generateAbstractIcon", _) || { children: [], attributes: {} };
  return (_.children = y), (_.attributes = x), o ? ET(_) : MT(_);
}
function $g(t) {
  const {
      content: e,
      width: n,
      height: i,
      transform: r,
      title: s,
      extra: o,
      watchable: a = !1,
    } = t,
    l = te(
      te(te({}, o.attributes), s ? { title: s } : {}),
      {},
      { class: o.classes.join(" ") }
    );
  a && (l[hs] = "");
  const c = te({}, o.styles);
  jp(r) &&
    ((c.transform = Z1({
      transform: r,
      startCentered: !0,
      width: n,
      height: i,
    })),
    (c["-webkit-transform"] = c.transform));
  const u = vu(c);
  u.length > 0 && (l.style = u);
  const f = [];
  return (
    f.push({ tag: "span", attributes: l, children: [e] }),
    s &&
      f.push({ tag: "span", attributes: { class: "sr-only" }, children: [s] }),
    f
  );
}
function TT(t) {
  const { content: e, title: n, extra: i } = t,
    r = te(
      te(te({}, i.attributes), n ? { title: n } : {}),
      {},
      { class: i.classes.join(" ") }
    ),
    s = vu(i.styles);
  s.length > 0 && (r.style = s);
  const o = [];
  return (
    o.push({ tag: "span", attributes: r, children: [e] }),
    n &&
      o.push({ tag: "span", attributes: { class: "sr-only" }, children: [n] }),
    o
  );
}
const { styles: nf } = di;
function Kd(t) {
  const e = t[0],
    n = t[1],
    [i] = t.slice(4);
  let r = null;
  return (
    Array.isArray(i)
      ? (r = {
          tag: "g",
          attributes: { class: "".concat(Ee.cssPrefix, "-").concat(Ju.GROUP) },
          children: [
            {
              tag: "path",
              attributes: {
                class: "".concat(Ee.cssPrefix, "-").concat(Ju.SECONDARY),
                fill: "currentColor",
                d: i[0],
              },
            },
            {
              tag: "path",
              attributes: {
                class: "".concat(Ee.cssPrefix, "-").concat(Ju.PRIMARY),
                fill: "currentColor",
                d: i[1],
              },
            },
          ],
        })
      : (r = { tag: "path", attributes: { fill: "currentColor", d: i } }),
    { found: !0, width: e, height: n, icon: r }
  );
}
const wT = { found: !1, width: 512, height: 512 };
function AT(t, e) {
  !dx &&
    !Ee.showMissingIcons &&
    t &&
    console.error(
      'Icon with name "'.concat(t, '" and prefix "').concat(e, '" is missing.')
    );
}
function qd(t, e) {
  let n = e;
  return (
    e === "fa" && Ee.styleDefault !== null && (e = Ur()),
    new Promise((i, r) => {
      if (n === "fa") {
        const s = bx(t) || {};
        (t = s.iconName || t), (e = s.prefix || e);
      }
      if (t && e && nf[e] && nf[e][t]) {
        const s = nf[e][t];
        return i(Kd(s));
      }
      AT(t, e),
        i(
          te(
            te({}, wT),
            {},
            {
              icon:
                Ee.showMissingIcons && t ? Or("missingIconAbstract") || {} : {},
            }
          )
        );
    })
  );
}
const Zg = () => {},
  $d =
    Ee.measurePerformance && Tl && Tl.mark && Tl.measure
      ? Tl
      : { mark: Zg, measure: Zg },
  la = 'FA "6.7.1"',
  bT = (t) => ($d.mark("".concat(la, " ").concat(t, " begins")), () => Px(t)),
  Px = (t) => {
    $d.mark("".concat(la, " ").concat(t, " ends")),
      $d.measure(
        "".concat(la, " ").concat(t),
        "".concat(la, " ").concat(t, " begins"),
        "".concat(la, " ").concat(t, " ends")
      );
  };
var qp = { begin: bT, end: Px };
const pc = () => {};
function Qg(t) {
  return typeof (t.getAttribute ? t.getAttribute(hs) : null) == "string";
}
function RT(t) {
  const e = t.getAttribute ? t.getAttribute(Hp) : null,
    n = t.getAttribute ? t.getAttribute(Vp) : null;
  return e && n;
}
function CT(t) {
  return (
    t &&
    t.classList &&
    t.classList.contains &&
    t.classList.contains(Ee.replacementClass)
  );
}
function PT() {
  return Ee.autoReplaceSvg === !0
    ? mc.replace
    : mc[Ee.autoReplaceSvg] || mc.replace;
}
function LT(t) {
  return _t.createElementNS("http://www.w3.org/2000/svg", t);
}
function IT(t) {
  return _t.createElement(t);
}
function Lx(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const { ceFn: n = t.tag === "svg" ? LT : IT } = e;
  if (typeof t == "string") return _t.createTextNode(t);
  const i = n(t.tag);
  return (
    Object.keys(t.attributes || []).forEach(function (s) {
      i.setAttribute(s, t.attributes[s]);
    }),
    (t.children || []).forEach(function (s) {
      i.appendChild(Lx(s, { ceFn: n }));
    }),
    i
  );
}
function DT(t) {
  let e = " ".concat(t.outerHTML, " ");
  return (e = "".concat(e, "Font Awesome fontawesome.com ")), e;
}
const mc = {
  replace: function (t) {
    const e = t[0];
    if (e.parentNode)
      if (
        (t[1].forEach((n) => {
          e.parentNode.insertBefore(Lx(n), e);
        }),
        e.getAttribute(hs) === null && Ee.keepOriginalSource)
      ) {
        let n = _t.createComment(DT(e));
        e.parentNode.replaceChild(n, e);
      } else e.remove();
  },
  nest: function (t) {
    const e = t[0],
      n = t[1];
    if (~Wp(e).indexOf(Ee.replacementClass)) return mc.replace(t);
    const i = new RegExp("".concat(Ee.cssPrefix, "-.*"));
    if ((delete n[0].attributes.id, n[0].attributes.class)) {
      const s = n[0].attributes.class
        .split(" ")
        .reduce(
          (o, a) => (
            a === Ee.replacementClass || a.match(i)
              ? o.toSvg.push(a)
              : o.toNode.push(a),
            o
          ),
          { toNode: [], toSvg: [] }
        );
      (n[0].attributes.class = s.toSvg.join(" ")),
        s.toNode.length === 0
          ? e.removeAttribute("class")
          : e.setAttribute("class", s.toNode.join(" "));
    }
    const r = n.map((s) => tl(s)).join(`
`);
    e.setAttribute(hs, ""), (e.innerHTML = r);
  },
};
function Jg(t) {
  t();
}
function Ix(t, e) {
  const n = typeof e == "function" ? e : pc;
  if (t.length === 0) n();
  else {
    let i = Jg;
    Ee.mutateApproach === O1 && (i = Nr.requestAnimationFrame || Jg),
      i(() => {
        const r = PT(),
          s = qp.begin("mutate");
        t.map(r), s(), n();
      });
  }
}
let $p = !1;
function Dx() {
  $p = !0;
}
function Zd() {
  $p = !1;
}
let Kc = null;
function e_(t) {
  if (!zg || !Ee.observeMutations) return;
  const {
    treeCallback: e = pc,
    nodeCallback: n = pc,
    pseudoElementsCallback: i = pc,
    observeMutationsRoot: r = _t,
  } = t;
  (Kc = new zg((s) => {
    if ($p) return;
    const o = Ur();
    Uo(s).forEach((a) => {
      if (
        (a.type === "childList" &&
          a.addedNodes.length > 0 &&
          !Qg(a.addedNodes[0]) &&
          (Ee.searchPseudoElements && i(a.target), e(a.target)),
        a.type === "attributes" &&
          a.target.parentNode &&
          Ee.searchPseudoElements &&
          i(a.target.parentNode),
        a.type === "attributes" && Qg(a.target) && ~V1.indexOf(a.attributeName))
      )
        if (a.attributeName === "class" && RT(a.target)) {
          const { prefix: l, iconName: c } = xu(Wp(a.target));
          a.target.setAttribute(Hp, l || o), c && a.target.setAttribute(Vp, c);
        } else CT(a.target) && n(a.target);
    });
  })),
    er &&
      Kc.observe(r, {
        childList: !0,
        attributes: !0,
        characterData: !0,
        subtree: !0,
      });
}
function NT() {
  Kc && Kc.disconnect();
}
function UT(t) {
  const e = t.getAttribute("style");
  let n = [];
  return (
    e &&
      (n = e.split(";").reduce((i, r) => {
        const s = r.split(":"),
          o = s[0],
          a = s.slice(1);
        return o && a.length > 0 && (i[o] = a.join(":").trim()), i;
      }, {})),
    n
  );
}
function OT(t) {
  const e = t.getAttribute("data-prefix"),
    n = t.getAttribute("data-icon"),
    i = t.innerText !== void 0 ? t.innerText.trim() : "";
  let r = xu(Wp(t));
  return (
    r.prefix || (r.prefix = Ur()),
    e && n && ((r.prefix = e), (r.iconName = n)),
    (r.iconName && r.prefix) ||
      (r.prefix &&
        i.length > 0 &&
        (r.iconName =
          aT(r.prefix, t.innerText) || Yp(r.prefix, Wd(t.innerText))),
      !r.iconName &&
        Ee.autoFetchSvg &&
        t.firstChild &&
        t.firstChild.nodeType === Node.TEXT_NODE &&
        (r.iconName = t.firstChild.data)),
    r
  );
}
function FT(t) {
  const e = Uo(t.attributes).reduce(
      (r, s) => (
        r.name !== "class" && r.name !== "style" && (r[s.name] = s.value), r
      ),
      {}
    ),
    n = t.getAttribute("title"),
    i = t.getAttribute("data-fa-title-id");
  return (
    Ee.autoA11y &&
      (n
        ? (e["aria-labelledby"] = ""
            .concat(Ee.replacementClass, "-title-")
            .concat(i || Ga()))
        : ((e["aria-hidden"] = "true"), (e.focusable = "false"))),
    e
  );
}
function kT() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: fi,
    symbol: !1,
    mask: { iconName: null, prefix: null, rest: [] },
    maskId: null,
    extra: { classes: [], styles: {}, attributes: {} },
  };
}
function t_(t) {
  let e =
    arguments.length > 1 && arguments[1] !== void 0
      ? arguments[1]
      : { styleParser: !0 };
  const { iconName: n, prefix: i, rest: r } = OT(t),
    s = FT(t),
    o = Xd("parseNodeAttributes", {}, t);
  let a = e.styleParser ? UT(t) : [];
  return te(
    {
      iconName: n,
      title: t.getAttribute("title"),
      titleId: t.getAttribute("data-fa-title-id"),
      prefix: i,
      transform: fi,
      mask: { iconName: null, prefix: null, rest: [] },
      maskId: null,
      symbol: !1,
      extra: { classes: r, styles: a, attributes: s },
    },
    o
  );
}
const { styles: BT } = di;
function Nx(t) {
  const e = Ee.autoReplaceSvg === "nest" ? t_(t, { styleParser: !1 }) : t_(t);
  return ~e.extra.classes.indexOf(px)
    ? Or("generateLayersText", t, e)
    : Or("generateSvgReplacementMutation", t, e);
}
function zT() {
  return [...x1, ...kd];
}
function n_(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!er) return Promise.resolve();
  const n = _t.documentElement.classList,
    i = (u) => n.add("".concat(Gg, "-").concat(u)),
    r = (u) => n.remove("".concat(Gg, "-").concat(u)),
    s = Ee.autoFetchSvg ? zT() : ax.concat(Object.keys(BT));
  s.includes("fa") || s.push("fa");
  const o = [".".concat(px, ":not([").concat(hs, "])")]
    .concat(s.map((u) => ".".concat(u, ":not([").concat(hs, "])")))
    .join(", ");
  if (o.length === 0) return Promise.resolve();
  let a = [];
  try {
    a = Uo(t.querySelectorAll(o));
  } catch {}
  if (a.length > 0) i("pending"), r("complete");
  else return Promise.resolve();
  const l = qp.begin("onTree"),
    c = a.reduce((u, f) => {
      try {
        const d = Nx(f);
        d && u.push(d);
      } catch (d) {
        dx || (d.name === "MissingIcon" && console.error(d));
      }
      return u;
    }, []);
  return new Promise((u, f) => {
    Promise.all(c)
      .then((d) => {
        Ix(d, () => {
          i("active"),
            i("complete"),
            r("pending"),
            typeof e == "function" && e(),
            l(),
            u();
        });
      })
      .catch((d) => {
        l(), f(d);
      });
  });
}
function HT(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  Nx(t).then((n) => {
    n && Ix([n], e);
  });
}
function VT(t) {
  return function (e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = (e || {}).icon ? e : Yd(e || {});
    let { mask: r } = n;
    return (
      r && (r = (r || {}).icon ? r : Yd(r || {})),
      t(i, te(te({}, n), {}, { mask: r }))
    );
  };
}
const GT = function (t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: n = fi,
    symbol: i = !1,
    mask: r = null,
    maskId: s = null,
    title: o = null,
    titleId: a = null,
    classes: l = [],
    attributes: c = {},
    styles: u = {},
  } = e;
  if (!t) return;
  const { prefix: f, iconName: d, icon: p } = t;
  return Su(
    te({ type: "icon" }, t),
    () => (
      ps("beforeDOMElementCreation", { iconDefinition: t, params: e }),
      Ee.autoA11y &&
        (o
          ? (c["aria-labelledby"] = ""
              .concat(Ee.replacementClass, "-title-")
              .concat(a || Ga()))
          : ((c["aria-hidden"] = "true"), (c.focusable = "false"))),
      Kp({
        icons: {
          main: Kd(p),
          mask: r
            ? Kd(r.icon)
            : { found: !1, width: null, height: null, icon: {} },
        },
        prefix: f,
        iconName: d,
        transform: te(te({}, fi), n),
        symbol: i,
        title: o,
        maskId: s,
        titleId: a,
        extra: { attributes: c, styles: u, classes: l },
      })
    )
  );
};
var WT = {
    mixout() {
      return { icon: VT(GT) };
    },
    hooks() {
      return {
        mutationObserverCallbacks(t) {
          return (t.treeCallback = n_), (t.nodeCallback = HT), t;
        },
      };
    },
    provides(t) {
      (t.i2svg = function (e) {
        const { node: n = _t, callback: i = () => {} } = e;
        return n_(n, i);
      }),
        (t.generateSvgReplacementMutation = function (e, n) {
          const {
            iconName: i,
            title: r,
            titleId: s,
            prefix: o,
            transform: a,
            symbol: l,
            mask: c,
            maskId: u,
            extra: f,
          } = n;
          return new Promise((d, p) => {
            Promise.all([
              qd(i, o),
              c.iconName
                ? qd(c.iconName, c.prefix)
                : Promise.resolve({
                    found: !1,
                    width: 512,
                    height: 512,
                    icon: {},
                  }),
            ])
              .then((g) => {
                let [v, m] = g;
                d([
                  e,
                  Kp({
                    icons: { main: v, mask: m },
                    prefix: o,
                    iconName: i,
                    transform: a,
                    symbol: l,
                    maskId: u,
                    title: r,
                    titleId: s,
                    extra: f,
                    watchable: !0,
                  }),
                ]);
              })
              .catch(p);
          });
        }),
        (t.generateAbstractIcon = function (e) {
          let {
            children: n,
            attributes: i,
            main: r,
            transform: s,
            styles: o,
          } = e;
          const a = vu(o);
          a.length > 0 && (i.style = a);
          let l;
          return (
            jp(s) &&
              (l = Or("generateAbstractTransformGrouping", {
                main: r,
                transform: s,
                containerWidth: r.width,
                iconWidth: r.width,
              })),
            n.push(l || r.icon),
            { children: n, attributes: i }
          );
        });
    },
  },
  jT = {
    mixout() {
      return {
        layer(t) {
          let e =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const { classes: n = [] } = e;
          return Su({ type: "layer" }, () => {
            ps("beforeDOMElementCreation", { assembler: t, params: e });
            let i = [];
            return (
              t((r) => {
                Array.isArray(r)
                  ? r.map((s) => {
                      i = i.concat(s.abstract);
                    })
                  : (i = i.concat(r.abstract));
              }),
              [
                {
                  tag: "span",
                  attributes: {
                    class: ["".concat(Ee.cssPrefix, "-layers"), ...n].join(" "),
                  },
                  children: i,
                },
              ]
            );
          });
        },
      };
    },
  },
  XT = {
    mixout() {
      return {
        counter(t) {
          let e =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const {
            title: n = null,
            classes: i = [],
            attributes: r = {},
            styles: s = {},
          } = e;
          return Su(
            { type: "counter", content: t },
            () => (
              ps("beforeDOMElementCreation", { content: t, params: e }),
              TT({
                content: t.toString(),
                title: n,
                extra: {
                  attributes: r,
                  styles: s,
                  classes: ["".concat(Ee.cssPrefix, "-layers-counter"), ...i],
                },
              })
            )
          );
        },
      };
    },
  },
  YT = {
    mixout() {
      return {
        text(t) {
          let e =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const {
            transform: n = fi,
            title: i = null,
            classes: r = [],
            attributes: s = {},
            styles: o = {},
          } = e;
          return Su(
            { type: "text", content: t },
            () => (
              ps("beforeDOMElementCreation", { content: t, params: e }),
              $g({
                content: t,
                transform: te(te({}, fi), n),
                title: i,
                extra: {
                  attributes: s,
                  styles: o,
                  classes: ["".concat(Ee.cssPrefix, "-layers-text"), ...r],
                },
              })
            )
          );
        },
      };
    },
    provides(t) {
      t.generateLayersText = function (e, n) {
        const { title: i, transform: r, extra: s } = n;
        let o = null,
          a = null;
        if (sx) {
          const l = parseInt(getComputedStyle(e).fontSize, 10),
            c = e.getBoundingClientRect();
          (o = c.width / l), (a = c.height / l);
        }
        return (
          Ee.autoA11y && !i && (s.attributes["aria-hidden"] = "true"),
          Promise.resolve([
            e,
            $g({
              content: e.innerHTML,
              width: o,
              height: a,
              transform: r,
              title: i,
              extra: s,
              watchable: !0,
            }),
          ])
        );
      };
    },
  };
const KT = new RegExp('"', "ug"),
  i_ = [1105920, 1112319],
  r_ = te(
    te(te(te({}, { FontAwesome: { normal: "fas", 400: "fas" } }), _1), N1),
    b1
  ),
  Qd = Object.keys(r_).reduce((t, e) => ((t[e.toLowerCase()] = r_[e]), t), {}),
  qT = Object.keys(Qd).reduce((t, e) => {
    const n = Qd[e];
    return (t[e] = n[900] || [...Object.entries(n)][0][1]), t;
  }, {});
function $T(t) {
  const e = t.replace(KT, ""),
    n = nT(e, 0),
    i = n >= i_[0] && n <= i_[1],
    r = e.length === 2 ? e[0] === e[1] : !1;
  return { value: Wd(r ? e[0] : e), isSecondary: i || r };
}
function ZT(t, e) {
  const n = t.replace(/^['"]|['"]$/g, "").toLowerCase(),
    i = parseInt(e),
    r = isNaN(i) ? "normal" : i;
  return (Qd[n] || {})[r] || qT[n];
}
function s_(t, e) {
  const n = "".concat(U1).concat(e.replace(":", "-"));
  return new Promise((i, r) => {
    if (t.getAttribute(n) !== null) return i();
    const o = Uo(t.children).filter((d) => d.getAttribute(zd) === e)[0],
      a = Nr.getComputedStyle(t, e),
      l = a.getPropertyValue("font-family"),
      c = l.match(z1),
      u = a.getPropertyValue("font-weight"),
      f = a.getPropertyValue("content");
    if (o && !c) return t.removeChild(o), i();
    if (c && f !== "none" && f !== "") {
      const d = a.getPropertyValue("content");
      let p = ZT(l, u);
      const { value: g, isSecondary: v } = $T(d),
        m = c[0].startsWith("FontAwesome");
      let h = Yp(p, g),
        _ = h;
      if (m) {
        const y = lT(g);
        y.iconName && y.prefix && ((h = y.iconName), (p = y.prefix));
      }
      if (
        h &&
        !v &&
        (!o || o.getAttribute(Hp) !== p || o.getAttribute(Vp) !== _)
      ) {
        t.setAttribute(n, _), o && t.removeChild(o);
        const y = kT(),
          { extra: x } = y;
        (x.attributes[zd] = e),
          qd(h, p)
            .then((C) => {
              const R = Kp(
                  te(
                    te({}, y),
                    {},
                    {
                      icons: { main: C, mask: Rx() },
                      prefix: p,
                      iconName: _,
                      extra: x,
                      watchable: !0,
                    }
                  )
                ),
                w = _t.createElementNS("http://www.w3.org/2000/svg", "svg");
              e === "::before"
                ? t.insertBefore(w, t.firstChild)
                : t.appendChild(w),
                (w.outerHTML = R.map((A) => tl(A)).join(`
`)),
                t.removeAttribute(n),
                i();
            })
            .catch(r);
      } else i();
    } else i();
  });
}
function QT(t) {
  return Promise.all([s_(t, "::before"), s_(t, "::after")]);
}
function JT(t) {
  return (
    t.parentNode !== document.head &&
    !~F1.indexOf(t.tagName.toUpperCase()) &&
    !t.getAttribute(zd) &&
    (!t.parentNode || t.parentNode.tagName !== "svg")
  );
}
function o_(t) {
  if (er)
    return new Promise((e, n) => {
      const i = Uo(t.querySelectorAll("*")).filter(JT).map(QT),
        r = qp.begin("searchPseudoElements");
      Dx(),
        Promise.all(i)
          .then(() => {
            r(), Zd(), e();
          })
          .catch(() => {
            r(), Zd(), n();
          });
    });
}
var ew = {
  hooks() {
    return {
      mutationObserverCallbacks(t) {
        return (t.pseudoElementsCallback = o_), t;
      },
    };
  },
  provides(t) {
    t.pseudoElements2svg = function (e) {
      const { node: n = _t } = e;
      Ee.searchPseudoElements && o_(n);
    };
  },
};
let a_ = !1;
var tw = {
  mixout() {
    return {
      dom: {
        unwatch() {
          Dx(), (a_ = !0);
        },
      },
    };
  },
  hooks() {
    return {
      bootstrap() {
        e_(Xd("mutationObserverCallbacks", {}));
      },
      noAuto() {
        NT();
      },
      watch(t) {
        const { observeMutationsRoot: e } = t;
        a_
          ? Zd()
          : e_(Xd("mutationObserverCallbacks", { observeMutationsRoot: e }));
      },
    };
  },
};
const l_ = (t) => {
  let e = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 };
  return t
    .toLowerCase()
    .split(" ")
    .reduce((n, i) => {
      const r = i.toLowerCase().split("-"),
        s = r[0];
      let o = r.slice(1).join("-");
      if (s && o === "h") return (n.flipX = !0), n;
      if (s && o === "v") return (n.flipY = !0), n;
      if (((o = parseFloat(o)), isNaN(o))) return n;
      switch (s) {
        case "grow":
          n.size = n.size + o;
          break;
        case "shrink":
          n.size = n.size - o;
          break;
        case "left":
          n.x = n.x - o;
          break;
        case "right":
          n.x = n.x + o;
          break;
        case "up":
          n.y = n.y - o;
          break;
        case "down":
          n.y = n.y + o;
          break;
        case "rotate":
          n.rotate = n.rotate + o;
          break;
      }
      return n;
    }, e);
};
var nw = {
  mixout() {
    return { parse: { transform: (t) => l_(t) } };
  },
  hooks() {
    return {
      parseNodeAttributes(t, e) {
        const n = e.getAttribute("data-fa-transform");
        return n && (t.transform = l_(n)), t;
      },
    };
  },
  provides(t) {
    t.generateAbstractTransformGrouping = function (e) {
      let { main: n, transform: i, containerWidth: r, iconWidth: s } = e;
      const o = { transform: "translate(".concat(r / 2, " 256)") },
        a = "translate(".concat(i.x * 32, ", ").concat(i.y * 32, ") "),
        l = "scale("
          .concat((i.size / 16) * (i.flipX ? -1 : 1), ", ")
          .concat((i.size / 16) * (i.flipY ? -1 : 1), ") "),
        c = "rotate(".concat(i.rotate, " 0 0)"),
        u = { transform: "".concat(a, " ").concat(l, " ").concat(c) },
        f = { transform: "translate(".concat((s / 2) * -1, " -256)") },
        d = { outer: o, inner: u, path: f };
      return {
        tag: "g",
        attributes: te({}, d.outer),
        children: [
          {
            tag: "g",
            attributes: te({}, d.inner),
            children: [
              {
                tag: n.icon.tag,
                children: n.icon.children,
                attributes: te(te({}, n.icon.attributes), d.path),
              },
            ],
          },
        ],
      };
    };
  },
};
const rf = { x: 0, y: 0, width: "100%", height: "100%" };
function c_(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return (
    t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"), t
  );
}
function iw(t) {
  return t.tag === "g" ? t.children : [t];
}
var rw = {
    hooks() {
      return {
        parseNodeAttributes(t, e) {
          const n = e.getAttribute("data-fa-mask"),
            i = n ? xu(n.split(" ").map((r) => r.trim())) : Rx();
          return (
            i.prefix || (i.prefix = Ur()),
            (t.mask = i),
            (t.maskId = e.getAttribute("data-fa-mask-id")),
            t
          );
        },
      };
    },
    provides(t) {
      t.generateAbstractMask = function (e) {
        let {
          children: n,
          attributes: i,
          main: r,
          mask: s,
          maskId: o,
          transform: a,
        } = e;
        const { width: l, icon: c } = r,
          { width: u, icon: f } = s,
          d = $1({ transform: a, containerWidth: u, iconWidth: l }),
          p = {
            tag: "rect",
            attributes: te(te({}, rf), {}, { fill: "white" }),
          },
          g = c.children ? { children: c.children.map(c_) } : {},
          v = {
            tag: "g",
            attributes: te({}, d.inner),
            children: [
              c_(
                te(
                  { tag: c.tag, attributes: te(te({}, c.attributes), d.path) },
                  g
                )
              ),
            ],
          },
          m = { tag: "g", attributes: te({}, d.outer), children: [v] },
          h = "mask-".concat(o || Ga()),
          _ = "clip-".concat(o || Ga()),
          y = {
            tag: "mask",
            attributes: te(
              te({}, rf),
              {},
              {
                id: h,
                maskUnits: "userSpaceOnUse",
                maskContentUnits: "userSpaceOnUse",
              }
            ),
            children: [p, m],
          },
          x = {
            tag: "defs",
            children: [
              { tag: "clipPath", attributes: { id: _ }, children: iw(f) },
              y,
            ],
          };
        return (
          n.push(x, {
            tag: "rect",
            attributes: te(
              {
                fill: "currentColor",
                "clip-path": "url(#".concat(_, ")"),
                mask: "url(#".concat(h, ")"),
              },
              rf
            ),
          }),
          { children: n, attributes: i }
        );
      };
    },
  },
  sw = {
    provides(t) {
      let e = !1;
      Nr.matchMedia &&
        (e = Nr.matchMedia("(prefers-reduced-motion: reduce)").matches),
        (t.missingIconAbstract = function () {
          const n = [],
            i = { fill: "currentColor" },
            r = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" };
          n.push({
            tag: "path",
            attributes: te(
              te({}, i),
              {},
              {
                d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z",
              }
            ),
          });
          const s = te(te({}, r), {}, { attributeName: "opacity" }),
            o = {
              tag: "circle",
              attributes: te(te({}, i), {}, { cx: "256", cy: "364", r: "28" }),
              children: [],
            };
          return (
            e ||
              o.children.push(
                {
                  tag: "animate",
                  attributes: te(
                    te({}, r),
                    {},
                    { attributeName: "r", values: "28;14;28;28;14;28;" }
                  ),
                },
                {
                  tag: "animate",
                  attributes: te(te({}, s), {}, { values: "1;0;1;1;0;1;" }),
                }
              ),
            n.push(o),
            n.push({
              tag: "path",
              attributes: te(
                te({}, i),
                {},
                {
                  opacity: "1",
                  d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z",
                }
              ),
              children: e
                ? []
                : [
                    {
                      tag: "animate",
                      attributes: te(te({}, s), {}, { values: "1;0;0;0;0;1;" }),
                    },
                  ],
            }),
            e ||
              n.push({
                tag: "path",
                attributes: te(
                  te({}, i),
                  {},
                  {
                    opacity: "0",
                    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z",
                  }
                ),
                children: [
                  {
                    tag: "animate",
                    attributes: te(te({}, s), {}, { values: "0;0;1;1;0;0;" }),
                  },
                ],
              }),
            { tag: "g", attributes: { class: "missing" }, children: n }
          );
        });
    },
  },
  ow = {
    hooks() {
      return {
        parseNodeAttributes(t, e) {
          const n = e.getAttribute("data-fa-symbol"),
            i = n === null ? !1 : n === "" ? !0 : n;
          return (t.symbol = i), t;
        },
      };
    },
  },
  aw = [J1, WT, jT, XT, YT, ew, tw, nw, rw, sw, ow];
_T(aw, { mixoutsTo: Ln });
Ln.noAuto;
Ln.config;
Ln.library;
Ln.dom;
const Jd = Ln.parse;
Ln.findIconDefinition;
Ln.toHtml;
const lw = Ln.icon;
Ln.layer;
Ln.text;
Ln.counter;
var Ux = { exports: {} },
  cw = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  uw = cw,
  fw = uw;
function Ox() {}
function Fx() {}
Fx.resetWarningCache = Ox;
var dw = function () {
  function t(i, r, s, o, a, l) {
    if (l !== fw) {
      var c = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((c.name = "Invariant Violation"), c);
    }
  }
  t.isRequired = t;
  function e() {
    return t;
  }
  var n = {
    array: t,
    bigint: t,
    bool: t,
    func: t,
    number: t,
    object: t,
    string: t,
    symbol: t,
    any: t,
    arrayOf: e,
    element: t,
    elementType: t,
    instanceOf: e,
    node: t,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: Fx,
    resetWarningCache: Ox,
  };
  return (n.PropTypes = n), n;
};
Ux.exports = dw();
var hw = Ux.exports;
const Ge = G0(hw);
function u_(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(t, r).enumerable;
      })),
      n.push.apply(n, i);
  }
  return n;
}
function ai(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? u_(Object(n), !0).forEach(function (i) {
          Zs(t, i, n[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : u_(Object(n)).forEach(function (i) {
          Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i));
        });
  }
  return t;
}
function qc(t) {
  "@babel/helpers - typeof";
  return (
    (qc =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    qc(t)
  );
}
function Zs(t, e, n) {
  return (
    e in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function pw(t, e) {
  if (t == null) return {};
  var n = {},
    i = Object.keys(t),
    r,
    s;
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (n[r] = t[r]);
  return n;
}
function mw(t, e) {
  if (t == null) return {};
  var n = pw(t, e),
    i,
    r;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    for (r = 0; r < s.length; r++)
      (i = s[r]),
        !(e.indexOf(i) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(t, i) &&
          (n[i] = t[i]);
  }
  return n;
}
function eh(t) {
  return gw(t) || _w(t) || vw(t) || yw();
}
function gw(t) {
  if (Array.isArray(t)) return th(t);
}
function _w(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function vw(t, e) {
  if (t) {
    if (typeof t == "string") return th(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (
      (n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return th(t, e);
  }
}
function th(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
  return i;
}
function yw() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function xw(t) {
  var e,
    n = t.beat,
    i = t.fade,
    r = t.beatFade,
    s = t.bounce,
    o = t.shake,
    a = t.flash,
    l = t.spin,
    c = t.spinPulse,
    u = t.spinReverse,
    f = t.pulse,
    d = t.fixedWidth,
    p = t.inverse,
    g = t.border,
    v = t.listItem,
    m = t.flip,
    h = t.size,
    _ = t.rotation,
    y = t.pull,
    x =
      ((e = {
        "fa-beat": n,
        "fa-fade": i,
        "fa-beat-fade": r,
        "fa-bounce": s,
        "fa-shake": o,
        "fa-flash": a,
        "fa-spin": l,
        "fa-spin-reverse": u,
        "fa-spin-pulse": c,
        "fa-pulse": f,
        "fa-fw": d,
        "fa-inverse": p,
        "fa-border": g,
        "fa-li": v,
        "fa-flip": m === !0,
        "fa-flip-horizontal": m === "horizontal" || m === "both",
        "fa-flip-vertical": m === "vertical" || m === "both",
      }),
      Zs(e, "fa-".concat(h), typeof h < "u" && h !== null),
      Zs(e, "fa-rotate-".concat(_), typeof _ < "u" && _ !== null && _ !== 0),
      Zs(e, "fa-pull-".concat(y), typeof y < "u" && y !== null),
      Zs(e, "fa-swap-opacity", t.swapOpacity),
      e);
  return Object.keys(x)
    .map(function (C) {
      return x[C] ? C : null;
    })
    .filter(function (C) {
      return C;
    });
}
function Sw(t) {
  return (t = t - 0), t === t;
}
function kx(t) {
  return Sw(t)
    ? t
    : ((t = t.replace(/[\-_\s]+(.)?/g, function (e, n) {
        return n ? n.toUpperCase() : "";
      })),
      t.substr(0, 1).toLowerCase() + t.substr(1));
}
var Mw = ["style"];
function Ew(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function Tw(t) {
  return t
    .split(";")
    .map(function (e) {
      return e.trim();
    })
    .filter(function (e) {
      return e;
    })
    .reduce(function (e, n) {
      var i = n.indexOf(":"),
        r = kx(n.slice(0, i)),
        s = n.slice(i + 1).trim();
      return r.startsWith("webkit") ? (e[Ew(r)] = s) : (e[r] = s), e;
    }, {});
}
function Bx(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof e == "string") return e;
  var i = (e.children || []).map(function (l) {
      return Bx(t, l);
    }),
    r = Object.keys(e.attributes || {}).reduce(
      function (l, c) {
        var u = e.attributes[c];
        switch (c) {
          case "class":
            (l.attrs.className = u), delete e.attributes.class;
            break;
          case "style":
            l.attrs.style = Tw(u);
            break;
          default:
            c.indexOf("aria-") === 0 || c.indexOf("data-") === 0
              ? (l.attrs[c.toLowerCase()] = u)
              : (l.attrs[kx(c)] = u);
        }
        return l;
      },
      { attrs: {} }
    ),
    s = n.style,
    o = s === void 0 ? {} : s,
    a = mw(n, Mw);
  return (
    (r.attrs.style = ai(ai({}, r.attrs.style), o)),
    t.apply(void 0, [e.tag, ai(ai({}, r.attrs), a)].concat(eh(i)))
  );
}
var zx = !1;
try {
  zx = !0;
} catch {}
function ww() {
  if (!zx && console && typeof console.error == "function") {
    var t;
    (t = console).error.apply(t, arguments);
  }
}
function f_(t) {
  if (t && qc(t) === "object" && t.prefix && t.iconName && t.icon) return t;
  if (Jd.icon) return Jd.icon(t);
  if (t === null) return null;
  if (t && qc(t) === "object" && t.prefix && t.iconName) return t;
  if (Array.isArray(t) && t.length === 2)
    return { prefix: t[0], iconName: t[1] };
  if (typeof t == "string") return { prefix: "fas", iconName: t };
}
function sf(t, e) {
  return (Array.isArray(e) && e.length > 0) || (!Array.isArray(e) && e)
    ? Zs({}, t, e)
    : {};
}
var d_ = {
    border: !1,
    className: "",
    mask: null,
    maskId: null,
    fixedWidth: !1,
    inverse: !1,
    flip: !1,
    icon: null,
    listItem: !1,
    pull: null,
    pulse: !1,
    rotation: null,
    size: null,
    spin: !1,
    spinPulse: !1,
    spinReverse: !1,
    beat: !1,
    fade: !1,
    beatFade: !1,
    bounce: !1,
    shake: !1,
    symbol: !1,
    title: "",
    titleId: null,
    transform: null,
    swapOpacity: !1,
  },
  Oi = qh.forwardRef(function (t, e) {
    var n = ai(ai({}, d_), t),
      i = n.icon,
      r = n.mask,
      s = n.symbol,
      o = n.className,
      a = n.title,
      l = n.titleId,
      c = n.maskId,
      u = f_(i),
      f = sf("classes", [].concat(eh(xw(n)), eh((o || "").split(" ")))),
      d = sf(
        "transform",
        typeof n.transform == "string" ? Jd.transform(n.transform) : n.transform
      ),
      p = sf("mask", f_(r)),
      g = lw(
        u,
        ai(
          ai(ai(ai({}, f), d), p),
          {},
          { symbol: s, title: a, titleId: l, maskId: c }
        )
      );
    if (!g) return ww("Could not find icon", u), null;
    var v = g.abstract,
      m = { ref: e };
    return (
      Object.keys(n).forEach(function (h) {
        d_.hasOwnProperty(h) || (m[h] = n[h]);
      }),
      Aw(v[0], m)
    );
  });
Oi.displayName = "FontAwesomeIcon";
Oi.propTypes = {
  beat: Ge.bool,
  border: Ge.bool,
  beatFade: Ge.bool,
  bounce: Ge.bool,
  className: Ge.string,
  fade: Ge.bool,
  flash: Ge.bool,
  mask: Ge.oneOfType([Ge.object, Ge.array, Ge.string]),
  maskId: Ge.string,
  fixedWidth: Ge.bool,
  inverse: Ge.bool,
  flip: Ge.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: Ge.oneOfType([Ge.object, Ge.array, Ge.string]),
  listItem: Ge.bool,
  pull: Ge.oneOf(["right", "left"]),
  pulse: Ge.bool,
  rotation: Ge.oneOf([0, 90, 180, 270]),
  shake: Ge.bool,
  size: Ge.oneOf([
    "2xs",
    "xs",
    "sm",
    "lg",
    "xl",
    "2xl",
    "1x",
    "2x",
    "3x",
    "4x",
    "5x",
    "6x",
    "7x",
    "8x",
    "9x",
    "10x",
  ]),
  spin: Ge.bool,
  spinPulse: Ge.bool,
  spinReverse: Ge.bool,
  symbol: Ge.oneOfType([Ge.bool, Ge.string]),
  title: Ge.string,
  titleId: Ge.string,
  transform: Ge.oneOfType([Ge.string, Ge.object]),
  swapOpacity: Ge.bool,
};
var Aw = Bx.bind(null, qh.createElement);
/*!
 * Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */ const bw = {
    prefix: "fas",
    iconName: "bars",
    icon: [
      448,
      512,
      ["navicon"],
      "f0c9",
      "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z",
    ],
  },
  Rw = {
    prefix: "fas",
    iconName: "phone",
    icon: [
      512,
      512,
      [128222, 128379],
      "f095",
      "M164.9 24.6c-7.7-18.6-28-28.5-47.4-23.2l-88 24C12.1 30.2 0 46 0 64C0 311.4 200.6 512 448 512c18 0 33.8-12.1 38.6-29.5l24-88c5.3-19.4-4.6-39.7-23.2-47.4l-96-40c-16.3-6.8-35.2-2.1-46.3 11.6L304.7 368C234.3 334.7 177.3 277.7 144 207.3L193.3 167c13.7-11.2 18.4-30 11.6-46.3l-40-96z",
    ],
  },
  Cw = {
    prefix: "fas",
    iconName: "envelope",
    icon: [
      512,
      512,
      [128386, 9993, 61443],
      "f0e0",
      "M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48L48 64zM0 176L0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-208L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z",
    ],
  },
  Pw = {
    prefix: "fas",
    iconName: "location-dot",
    icon: [
      384,
      512,
      ["map-marker-alt"],
      "f3c5",
      "M215.7 499.2C267 435 384 279.4 384 192C384 86 298 0 192 0S0 86 0 192c0 87.4 117 243 168.3 307.2c12.3 15.3 35.1 15.3 47.4 0zM192 128a64 64 0 1 1 0 128 64 64 0 1 1 0-128z",
    ],
  };
function Lw() {
  const [t, e] = Qt.useState(!1),
    n = () => {
      e(!t);
    };
  return K.jsxs("div", {
    className: "container",
    children: [
      K.jsx("div", {
        className: "logo",
        children: K.jsx("img", {
          src: "../src/assets/cn.png",
          alt: "logo",
          id: "logo",
        }),
      }),
      K.jsx("div", {
        className: "name",
        children: K.jsx("p", { id: "name", children: "Gecko&News" }),
      }),
      K.jsxs("div", {
        className: "tabs",
        children: [
          K.jsx("a", {
            href: "",
            className: "links",
            "data-nav": !0,
            children: "About Us",
          }),
          K.jsx("a", {
            href: "",
            className: "links",
            "data-nav": !0,
            children: "News",
          }),
          K.jsx("a", {
            href: "",
            className: "links",
            "data-nav": !0,
            children: "Crypto",
          }),
        ],
      }),
      K.jsx("div", {
        className: "icon-container",
        children: K.jsx(Oi, { icon: bw, className: "icon", onClick: n }),
      }),
      K.jsxs("div", {
        className: `mobile-menu ${t ? "show" : ""}`,
        children: [
          K.jsx("a", {
            href: "",
            className: "mobile-link",
            "data-custom": !0,
            children: "About us",
          }),
          K.jsx("a", {
            href: "",
            className: "mobile-link",
            "data-custom": !0,
            children: "News",
          }),
          K.jsx("a", {
            href: "",
            className: "mobile-link",
            "data-custom": !0,
            children: "Crypto",
          }),
          K.jsx("a", {
            href: "",
            className: "mobile-link",
            "data-custom": !0,
            children: "Sign in",
          }),
        ],
      }),
    ],
  });
}
var Ht = [];
for (var of = 0; of < 256; ++of) Ht.push((of + 256).toString(16).slice(1));
function Iw(t, e = 0) {
  return (
    Ht[t[e + 0]] +
    Ht[t[e + 1]] +
    Ht[t[e + 2]] +
    Ht[t[e + 3]] +
    "-" +
    Ht[t[e + 4]] +
    Ht[t[e + 5]] +
    "-" +
    Ht[t[e + 6]] +
    Ht[t[e + 7]] +
    "-" +
    Ht[t[e + 8]] +
    Ht[t[e + 9]] +
    "-" +
    Ht[t[e + 10]] +
    Ht[t[e + 11]] +
    Ht[t[e + 12]] +
    Ht[t[e + 13]] +
    Ht[t[e + 14]] +
    Ht[t[e + 15]]
  ).toLowerCase();
}
var Al,
  Dw = new Uint8Array(16);
function Nw() {
  if (
    !Al &&
    ((Al =
      typeof crypto < "u" &&
      crypto.getRandomValues &&
      crypto.getRandomValues.bind(crypto)),
    !Al)
  )
    throw new Error(
      "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
    );
  return Al(Dw);
}
var Uw =
  typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const h_ = { randomUUID: Uw };
function Ow(t, e, n) {
  if (h_.randomUUID && !e && !t) return h_.randomUUID();
  t = t || {};
  var i = t.random || (t.rng || Nw)();
  return (i[6] = (i[6] & 15) | 64), (i[8] = (i[8] & 63) | 128), Iw(i);
}
function Fw() {
  const [t, e] = Qt.useState(null),
    [n, i] = Qt.useState(!0),
    [r, s] = Qt.useState(null),
    a =
      "https://newsapi.org/v2/everything?q=crypto&apiKey=9ded2ecc5197429f8d462dc6b1f0b9e7",
    l = { method: "GET", headers: { accept: "application/json" } };
  return (
    Qt.useEffect(() => {
      async function c() {
        try {
          const f = await (await fetch(a, l)).json();
          e(f), i(!1);
        } catch (u) {
          s(u), i(!1), console.error(u);
        }
      }
      c();
    }, []),
    n
      ? K.jsx("div", { className: "loader" })
      : r
      ? K.jsxs("p", { children: ["Error: ", r.message] })
      : K.jsx(K.Fragment, {
          children:
            t && t.articles && t.articles.length > 0
              ? t.articles
                  .slice(0, 20)
                  .sort(
                    (c, u) => new Date(u.publishedAt) - new Date(c.publishedAt)
                  )
                  .map((c) =>
                    c.title === "[Removed]"
                      ? (console.log("[Removed]"), null)
                      : K.jsxs(
                          "div",
                          {
                            className: "newsBlock",
                            children: [
                              K.jsxs("div", {
                                className: "newsContent",
                                children: [
                                  K.jsx("h2", { children: c.title }),
                                  K.jsx("b", { children: c.author }),
                                  K.jsx("i", {
                                    children: new Date(
                                      c.publishedAt
                                    ).toLocaleDateString(),
                                  }),
                                  K.jsx("p", {
                                    children:
                                      c.description ||
                                      "We are sorry! There is no description available...",
                                  }),
                                  c.url
                                    ? K.jsx("button", {
                                        className: "custom-button",
                                        children: K.jsx("a", {
                                          target: "_blank",
                                          href: c.url,
                                          className: "news-link",
                                          "data-news": !0,
                                          children: "Source",
                                        }),
                                      })
                                    : K.jsx("p", {
                                        children:
                                          "Ugh! There is no link available...",
                                      }),
                                  K.jsx("br", {}),
                                ],
                              }),
                              K.jsx("div", {
                                className: "urlToImageContainter",
                                children: K.jsx("img", {
                                  src:
                                    c.urlToImage || "src/assets/no-image.jpg",
                                  alt: "Possibly resource doesn't have an image...",
                                }),
                              }),
                            ],
                          },
                          Ow()
                        )
                  )
              : null,
        })
  );
}
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */ const p_ = {
    prefix: "fab",
    iconName: "linkedin",
    icon: [
      448,
      512,
      [],
      "f08c",
      "M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z",
    ],
  },
  kw = {
    prefix: "fab",
    iconName: "github",
    icon: [
      496,
      512,
      [],
      "f09b",
      "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z",
    ],
  };
function Bw() {
  return K.jsx(K.Fragment, {
    children: K.jsxs("div", {
      className: "footerContainer",
      children: [
        K.jsx("div", {
          class: "custom-shape-divider-top-1736841044",
          children: K.jsx("svg", {
            "data-name": "Layer 1",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1200 120",
            preserveAspectRatio: "none",
            children: K.jsx("path", {
              d: "M321.39,56.44c58-10.79,114.16-30.13,172-41.86,82.39-16.72,168.19-17.73,250.45-.39C823.78,31,906.67,72,985.66,92.83c70.05,18.48,146.53,26.09,214.34,3V0H0V27.35A600.21,600.21,0,0,0,321.39,56.44Z",
              class: "shape-fill",
            }),
          }),
        }),
        K.jsxs("div", {
          className: "footer-info",
          children: [
            K.jsxs("div", {
              className: "about",
              children: [
                K.jsx("h1", { children: "About Us" }),
                K.jsx("p", {
                  children:
                    "Lorem ipsum dolor sit amet consectetur adipisicing elit. Repellendus magni ipsum provident libero deleniti, modi perspiciatis.",
                }),
              ],
            }),
            K.jsxs("div", {
              className: "contacts",
              children: [
                K.jsx("h1", { children: "Contact" }),
                K.jsxs("ul", {
                  children: [
                    K.jsxs("li", {
                      children: [
                        K.jsx(Oi, { icon: Rw, className: "Contact-icons" }),
                        "+370 894 3215",
                      ],
                    }),
                    K.jsxs("li", {
                      children: [
                        K.jsx(Oi, { icon: Cw, className: "Contact-icons" }),
                        "crypto@gmail.com",
                      ],
                    }),
                    K.jsxs("li", {
                      children: [
                        K.jsx(Oi, { icon: Pw, className: "Contact-icons" }),
                        "Vilnius, Lithuania",
                      ],
                    }),
                  ],
                }),
              ],
            }),
            K.jsxs("div", {
              className: "useful-links",
              children: [
                K.jsx("h1", { children: "Quick Links" }),
                K.jsx("a", { href: "#", children: "Services" }),
                K.jsx("a", { href: "#", children: "Projects" }),
                K.jsx("a", { href: "#", children: "Careers" }),
                K.jsx("a", { href: "#", children: "Privacy Policy" }),
              ],
            }),
            K.jsxs("div", {
              className: "follow",
              children: [
                K.jsx("h1", { children: "Follow Us" }),
                K.jsxs("div", {
                  className: "follow-icons",
                  children: [
                    K.jsx("a", {
                      href: "",
                      children: K.jsx(Oi, {
                        icon: kw,
                        className: "follow-icons-color",
                      }),
                    }),
                    K.jsx("a", {
                      href: "",
                      children: K.jsx(Oi, {
                        icon: p_,
                        className: "follow-icons-color",
                      }),
                    }),
                    K.jsx("a", {
                      href: "",
                      children: K.jsx(Oi, {
                        icon: p_,
                        className: "follow-icons-color",
                      }),
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
        K.jsx("hr", {}),
        K.jsx("div", {
          className: "license",
          children: K.jsxs("p", {
            children: [
              " ",
              new Date().getFullYear(),
              " Your Company. All rights reserved.",
            ],
          }),
        }),
      ],
    }),
  });
}
function zw() {
  return K.jsxs("div", {
    className: "newsContainer",
    children: [K.jsx(Fw, {}), K.jsx(Bw, {})],
  });
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Zp = "170",
  ao = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Qs = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  Hw = 0,
  m_ = 1,
  Vw = 2,
  Hx = 1,
  Gw = 2,
  Ii = 3,
  Zi = 0,
  xn = 1,
  ui = 2,
  Pr = 0,
  lo = 1,
  g_ = 2,
  __ = 3,
  v_ = 4,
  Ww = 5,
  Qr = 100,
  jw = 101,
  Xw = 102,
  Yw = 103,
  Kw = 104,
  qw = 200,
  $w = 201,
  Zw = 202,
  Qw = 203,
  nh = 204,
  ih = 205,
  Jw = 206,
  eA = 207,
  tA = 208,
  nA = 209,
  iA = 210,
  rA = 211,
  sA = 212,
  oA = 213,
  aA = 214,
  rh = 0,
  sh = 1,
  oh = 2,
  So = 3,
  ah = 4,
  lh = 5,
  ch = 6,
  uh = 7,
  Vx = 0,
  lA = 1,
  cA = 2,
  Lr = 0,
  uA = 1,
  fA = 2,
  dA = 3,
  hA = 4,
  pA = 5,
  mA = 6,
  gA = 7,
  y_ = "attached",
  _A = "detached",
  Gx = 300,
  Mo = 301,
  Eo = 302,
  $c = 303,
  fh = 304,
  Mu = 306,
  To = 1e3,
  hi = 1001,
  Zc = 1002,
  ln = 1003,
  Wx = 1004,
  ca = 1005,
  kt = 1006,
  gc = 1007,
  pi = 1008,
  Qi = 1009,
  jx = 1010,
  Xx = 1011,
  ja = 1012,
  Qp = 1013,
  ms = 1014,
  gn = 1015,
  zi = 1016,
  Jp = 1017,
  em = 1018,
  wo = 1020,
  Yx = 35902,
  Kx = 1021,
  qx = 1022,
  Bn = 1023,
  $x = 1024,
  Zx = 1025,
  co = 1026,
  Ao = 1027,
  tm = 1028,
  nm = 1029,
  Qx = 1030,
  im = 1031,
  rm = 1033,
  _c = 33776,
  vc = 33777,
  yc = 33778,
  xc = 33779,
  dh = 35840,
  hh = 35841,
  ph = 35842,
  mh = 35843,
  gh = 36196,
  _h = 37492,
  vh = 37496,
  yh = 37808,
  xh = 37809,
  Sh = 37810,
  Mh = 37811,
  Eh = 37812,
  Th = 37813,
  wh = 37814,
  Ah = 37815,
  bh = 37816,
  Rh = 37817,
  Ch = 37818,
  Ph = 37819,
  Lh = 37820,
  Ih = 37821,
  Sc = 36492,
  Dh = 36494,
  Nh = 36495,
  Jx = 36283,
  Uh = 36284,
  Oh = 36285,
  Fh = 36286,
  Xa = 2300,
  Ya = 2301,
  af = 2302,
  x_ = 2400,
  S_ = 2401,
  M_ = 2402,
  vA = 2500,
  yA = 0,
  eS = 1,
  kh = 2,
  xA = 3200,
  SA = 3201,
  tS = 0,
  MA = 1,
  vr = "",
  Gt = "srgb",
  tn = "srgb-linear",
  Eu = "linear",
  at = "srgb",
  Es = 7680,
  E_ = 519,
  EA = 512,
  TA = 513,
  wA = 514,
  nS = 515,
  AA = 516,
  bA = 517,
  RA = 518,
  CA = 519,
  Bh = 35044,
  T_ = "300 es",
  Hi = 2e3,
  Qc = 2001;
class ys {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(n);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const qt = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let w_ = 1234567;
const Ea = Math.PI / 180,
  bo = 180 / Math.PI;
function ni() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    qt[t & 255] +
    qt[(t >> 8) & 255] +
    qt[(t >> 16) & 255] +
    qt[(t >> 24) & 255] +
    "-" +
    qt[e & 255] +
    qt[(e >> 8) & 255] +
    "-" +
    qt[((e >> 16) & 15) | 64] +
    qt[(e >> 24) & 255] +
    "-" +
    qt[(n & 63) | 128] +
    qt[(n >> 8) & 255] +
    "-" +
    qt[(n >> 16) & 255] +
    qt[(n >> 24) & 255] +
    qt[i & 255] +
    qt[(i >> 8) & 255] +
    qt[(i >> 16) & 255] +
    qt[(i >> 24) & 255]
  ).toLowerCase();
}
function Ft(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function sm(t, e) {
  return ((t % e) + e) % e;
}
function PA(t, e, n, i, r) {
  return i + ((t - e) * (r - i)) / (n - e);
}
function LA(t, e, n) {
  return t !== e ? (n - t) / (e - t) : 0;
}
function Ta(t, e, n) {
  return (1 - n) * t + n * e;
}
function IA(t, e, n, i) {
  return Ta(t, e, 1 - Math.exp(-n * i));
}
function DA(t, e = 1) {
  return e - Math.abs(sm(t, e * 2) - e);
}
function NA(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * (3 - 2 * t));
}
function UA(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * t * (t * (t * 6 - 15) + 10));
}
function OA(t, e) {
  return t + Math.floor(Math.random() * (e - t + 1));
}
function FA(t, e) {
  return t + Math.random() * (e - t);
}
function kA(t) {
  return t * (0.5 - Math.random());
}
function BA(t) {
  t !== void 0 && (w_ = t);
  let e = (w_ += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function zA(t) {
  return t * Ea;
}
function HA(t) {
  return t * bo;
}
function VA(t) {
  return (t & (t - 1)) === 0 && t !== 0;
}
function GA(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
}
function WA(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function jA(t, e, n, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(n / 2),
    l = o(n / 2),
    c = s((e + i) / 2),
    u = o((e + i) / 2),
    f = s((e - i) / 2),
    d = o((e - i) / 2),
    p = s((i - e) / 2),
    g = o((i - e) / 2);
  switch (r) {
    case "XYX":
      t.set(a * u, l * f, l * d, a * c);
      break;
    case "YZY":
      t.set(l * d, a * u, l * f, a * c);
      break;
    case "ZXZ":
      t.set(l * f, l * d, a * u, a * c);
      break;
    case "XZX":
      t.set(a * u, l * g, l * p, a * c);
      break;
    case "YXY":
      t.set(l * p, a * u, l * g, a * c);
      break;
    case "ZYZ":
      t.set(l * g, l * p, a * u, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function Qn(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function rt(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(t * 4294967295);
    case Uint16Array:
      return Math.round(t * 65535);
    case Uint8Array:
      return Math.round(t * 255);
    case Int32Array:
      return Math.round(t * 2147483647);
    case Int16Array:
      return Math.round(t * 32767);
    case Int8Array:
      return Math.round(t * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const iS = {
  DEG2RAD: Ea,
  RAD2DEG: bo,
  generateUUID: ni,
  clamp: Ft,
  euclideanModulo: sm,
  mapLinear: PA,
  inverseLerp: LA,
  lerp: Ta,
  damp: IA,
  pingpong: DA,
  smoothstep: NA,
  smootherstep: UA,
  randInt: OA,
  randFloat: FA,
  randFloatSpread: kA,
  seededRandom: BA,
  degToRad: zA,
  radToDeg: HA,
  isPowerOfTwo: VA,
  ceilPowerOfTwo: GA,
  floorPowerOfTwo: WA,
  setQuaternionFromProperEuler: jA,
  normalize: rt,
  denormalize: Qn,
};
class Le {
  constructor(e = 0, n = 0) {
    (Le.prototype.isVector2 = !0), (this.x = e), (this.y = n);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return (this.x = e), (this.y = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, n) {
    return (this.x = e.x + n.x), (this.y = e.y + n.y), this;
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, n) {
    return (this.x = e.x - n.x), (this.y = e.y - n.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * n + r[3] * i + r[6]),
      (this.y = r[1] * n + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      this
    );
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(n, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Ft(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (this.x += (e.x - this.x) * n), (this.y += (e.y - this.y) * n), this;
  }
  lerpVectors(e, n, i) {
    return (
      (this.x = e.x + (n.x - e.x) * i), (this.y = e.y + (n.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), e;
  }
  fromBufferAttribute(e, n) {
    return (this.x = e.getX(n)), (this.y = e.getY(n)), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n),
      r = Math.sin(n),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ke {
  constructor(e, n, i, r, s, o, a, l, c) {
    (ke.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, i, r, s, o, a, l, c);
  }
  set(e, n, i, r, s, o, a, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = r),
      (u[2] = a),
      (u[3] = n),
      (u[4] = s),
      (u[5] = l),
      (u[6] = i),
      (u[7] = o),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const n = this.elements,
      i = e.elements;
    return (
      (n[0] = i[0]),
      (n[1] = i[1]),
      (n[2] = i[2]),
      (n[3] = i[3]),
      (n[4] = i[4]),
      (n[5] = i[5]),
      (n[6] = i[6]),
      (n[7] = i[7]),
      (n[8] = i[8]),
      this
    );
  }
  extractBasis(e, n, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      n.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return (
      this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements,
      r = n.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      c = i[1],
      u = i[4],
      f = i[7],
      d = i[2],
      p = i[5],
      g = i[8],
      v = r[0],
      m = r[3],
      h = r[6],
      _ = r[1],
      y = r[4],
      x = r[7],
      C = r[2],
      R = r[5],
      w = r[8];
    return (
      (s[0] = o * v + a * _ + l * C),
      (s[3] = o * m + a * y + l * R),
      (s[6] = o * h + a * x + l * w),
      (s[1] = c * v + u * _ + f * C),
      (s[4] = c * m + u * y + f * R),
      (s[7] = c * h + u * x + f * w),
      (s[2] = d * v + p * _ + g * C),
      (s[5] = d * m + p * y + g * R),
      (s[8] = d * h + p * x + g * w),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[3] *= e),
      (n[6] *= e),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      (n[2] *= e),
      (n[5] *= e),
      (n[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      n * o * u - n * a * c - i * s * u + i * a * l + r * s * c - r * o * l
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      f = u * o - a * c,
      d = a * l - u * s,
      p = c * s - o * l,
      g = n * f + i * d + r * p;
    if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / g;
    return (
      (e[0] = f * v),
      (e[1] = (r * c - u * i) * v),
      (e[2] = (a * i - r * o) * v),
      (e[3] = d * v),
      (e[4] = (u * n - r * l) * v),
      (e[5] = (r * s - a * n) * v),
      (e[6] = p * v),
      (e[7] = (i * l - c * n) * v),
      (e[8] = (o * n - i * s) * v),
      this
    );
  }
  transpose() {
    let e;
    const n = this.elements;
    return (
      (e = n[1]),
      (n[1] = n[3]),
      (n[3] = e),
      (e = n[2]),
      (n[2] = n[6]),
      (n[6] = e),
      (e = n[5]),
      (n[5] = n[7]),
      (n[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[3]),
      (e[2] = n[6]),
      (e[3] = n[1]),
      (e[4] = n[4]),
      (e[5] = n[7]),
      (e[6] = n[2]),
      (e[7] = n[5]),
      (e[8] = n[8]),
      this
    );
  }
  setUvTransform(e, n, i, r, s, o, a) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        i * l,
        i * c,
        -i * (l * o + c * a) + o + e,
        -r * c,
        r * l,
        -r * (-c * o + l * a) + a + n,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, n) {
    return this.premultiply(lf.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(lf.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(lf.makeTranslation(e, n)), this;
  }
  makeTranslation(e, n) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(n, -i, 0, i, n, 0, 0, 0, 1), this;
  }
  makeScale(e, n) {
    return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this;
  }
  equals(e) {
    const n = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return (
      (e[n] = i[0]),
      (e[n + 1] = i[1]),
      (e[n + 2] = i[2]),
      (e[n + 3] = i[3]),
      (e[n + 4] = i[4]),
      (e[n + 5] = i[5]),
      (e[n + 6] = i[6]),
      (e[n + 7] = i[7]),
      (e[n + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const lf = new ke();
function rS(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
  return !1;
}
function Ka(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function XA() {
  const t = Ka("canvas");
  return (t.style.display = "block"), t;
}
const A_ = {};
function ua(t) {
  t in A_ || ((A_[t] = !0), console.warn(t));
}
function YA(t, e, n) {
  return new Promise(function (i, r) {
    function s() {
      switch (t.clientWaitSync(e, t.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case t.WAIT_FAILED:
          r();
          break;
        case t.TIMEOUT_EXPIRED:
          setTimeout(s, n);
          break;
        default:
          i();
      }
    }
    setTimeout(s, n);
  });
}
function KA(t) {
  const e = t.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function qA(t) {
  const e = t.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const Xe = {
  enabled: !0,
  workingColorSpace: tn,
  spaces: {},
  convert: function (t, e, n) {
    return (
      this.enabled === !1 ||
        e === n ||
        !e ||
        !n ||
        (this.spaces[e].transfer === at &&
          ((t.r = Gi(t.r)), (t.g = Gi(t.g)), (t.b = Gi(t.b))),
        this.spaces[e].primaries !== this.spaces[n].primaries &&
          (t.applyMatrix3(this.spaces[e].toXYZ),
          t.applyMatrix3(this.spaces[n].fromXYZ)),
        this.spaces[n].transfer === at &&
          ((t.r = uo(t.r)), (t.g = uo(t.g)), (t.b = uo(t.b)))),
      t
    );
  },
  fromWorkingColorSpace: function (t, e) {
    return this.convert(t, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function (t, e) {
    return this.convert(t, e, this.workingColorSpace);
  },
  getPrimaries: function (t) {
    return this.spaces[t].primaries;
  },
  getTransfer: function (t) {
    return t === vr ? Eu : this.spaces[t].transfer;
  },
  getLuminanceCoefficients: function (t, e = this.workingColorSpace) {
    return t.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function (t) {
    Object.assign(this.spaces, t);
  },
  _getMatrix: function (t, e, n) {
    return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ);
  },
  _getDrawingBufferColorSpace: function (t) {
    return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function (t = this.workingColorSpace) {
    return this.spaces[t].workingColorSpaceConfig.unpackColorSpace;
  },
};
function Gi(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function uo(t) {
  return t < 0.0031308 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
const b_ = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
  R_ = [0.2126, 0.7152, 0.0722],
  C_ = [0.3127, 0.329],
  P_ = new ke().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  L_ = new ke().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
Xe.define({
  [tn]: {
    primaries: b_,
    whitePoint: C_,
    transfer: Eu,
    toXYZ: P_,
    fromXYZ: L_,
    luminanceCoefficients: R_,
    workingColorSpaceConfig: { unpackColorSpace: Gt },
    outputColorSpaceConfig: { drawingBufferColorSpace: Gt },
  },
  [Gt]: {
    primaries: b_,
    whitePoint: C_,
    transfer: at,
    toXYZ: P_,
    fromXYZ: L_,
    luminanceCoefficients: R_,
    outputColorSpaceConfig: { drawingBufferColorSpace: Gt },
  },
});
let Ts;
class $A {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let n;
    if (e instanceof HTMLCanvasElement) n = e;
    else {
      Ts === void 0 && (Ts = Ka("canvas")),
        (Ts.width = e.width),
        (Ts.height = e.height);
      const i = Ts.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (n = Ts);
    }
    return n.width > 2048 || n.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        n.toDataURL("image/jpeg", 0.6))
      : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const n = Ka("canvas");
      (n.width = e.width), (n.height = e.height);
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = Gi(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray
          ? (n[i] = Math.floor(Gi(n[i] / 255) * 255))
          : (n[i] = Gi(n[i]));
      return { data: n, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let ZA = 0;
class sS {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: ZA++ }),
      (this.uuid = ni()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(cf(r[o].image)) : s.push(cf(r[o]));
      } else s = cf(r);
      i.url = s;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function cf(t) {
  return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ? $A.getDataURL(t)
    : t.data
    ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let QA = 0;
class zt extends ys {
  constructor(
    e = zt.DEFAULT_IMAGE,
    n = zt.DEFAULT_MAPPING,
    i = hi,
    r = hi,
    s = kt,
    o = pi,
    a = Bn,
    l = Qi,
    c = zt.DEFAULT_ANISOTROPY,
    u = vr
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: QA++ }),
      (this.uuid = ni()),
      (this.name = ""),
      (this.source = new sS(e)),
      (this.mipmaps = []),
      (this.mapping = n),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new Le(0, 0)),
      (this.repeat = new Le(1, 1)),
      (this.center = new Le(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new ke()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      n || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Gx) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case To:
          e.x = e.x - Math.floor(e.x);
          break;
        case hi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Zc:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case To:
          e.y = e.y - Math.floor(e.y);
          break;
        case hi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Zc:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
zt.DEFAULT_IMAGE = null;
zt.DEFAULT_MAPPING = Gx;
zt.DEFAULT_ANISOTROPY = 1;
class et {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    (et.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = n),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, r) {
    return (this.x = e), (this.y = n), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x),
      (this.y = e.y + n.y),
      (this.z = e.z + n.z),
      (this.w = e.w + n.w),
      this
    );
  }
  addScaledVector(e, n) {
    return (
      (this.x += e.x * n),
      (this.y += e.y * n),
      (this.z += e.z * n),
      (this.w += e.w * n),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x),
      (this.y = e.y - n.y),
      (this.z = e.z - n.z),
      (this.w = e.w - n.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * n + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * n + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * n + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * n + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return (
      n < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / n), (this.y = e.y / n), (this.z = e.z / n)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, r, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      f = l[8],
      d = l[1],
      p = l[5],
      g = l[9],
      v = l[2],
      m = l[6],
      h = l[10];
    if (
      Math.abs(u - d) < 0.01 &&
      Math.abs(f - v) < 0.01 &&
      Math.abs(g - m) < 0.01
    ) {
      if (
        Math.abs(u + d) < 0.1 &&
        Math.abs(f + v) < 0.1 &&
        Math.abs(g + m) < 0.1 &&
        Math.abs(c + p + h - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const y = (c + 1) / 2,
        x = (p + 1) / 2,
        C = (h + 1) / 2,
        R = (u + d) / 4,
        w = (f + v) / 4,
        A = (g + m) / 4;
      return (
        y > x && y > C
          ? y < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(y)), (r = R / i), (s = w / i))
          : x > C
          ? x < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(x)), (i = R / r), (s = A / r))
          : C < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(C)), (i = w / s), (r = A / s)),
        this.set(i, r, s, n),
        this
      );
    }
    let _ = Math.sqrt(
      (m - g) * (m - g) + (f - v) * (f - v) + (d - u) * (d - u)
    );
    return (
      Math.abs(_) < 0.001 && (_ = 1),
      (this.x = (m - g) / _),
      (this.y = (f - v) / _),
      (this.z = (d - u) / _),
      (this.w = Math.acos((c + p + h - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return (
      (this.x = n[12]),
      (this.y = n[13]),
      (this.z = n[14]),
      (this.w = n[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      (this.w = Math.max(e.w, Math.min(n.w, this.w))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      (this.w = Math.max(e, Math.min(n, this.w))),
      this
    );
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(n, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      (this.w += (e.w - this.w) * n),
      this
    );
  }
  lerpVectors(e, n, i) {
    return (
      (this.x = e.x + (n.x - e.x) * i),
      (this.y = e.y + (n.y - e.y) * i),
      (this.z = e.z + (n.z - e.z) * i),
      (this.w = e.w + (n.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return (
      (this.x = e[n]),
      (this.y = e[n + 1]),
      (this.z = e[n + 2]),
      (this.w = e[n + 3]),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this.x),
      (e[n + 1] = this.y),
      (e[n + 2] = this.z),
      (e[n + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)),
      (this.y = e.getY(n)),
      (this.z = e.getZ(n)),
      (this.w = e.getW(n)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class JA extends ys {
  constructor(e = 1, n = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = n),
      (this.depth = 1),
      (this.scissor = new et(0, 0, e, n)),
      (this.scissorTest = !1),
      (this.viewport = new et(0, 0, e, n));
    const r = { width: e, height: n, depth: 1 };
    i = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: kt,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      i
    );
    const s = new zt(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.colorSpace
    );
    (s.flipY = !1),
      (s.generateMipmaps = i.generateMipmaps),
      (s.internalFormat = i.internalFormat),
      (this.textures = []);
    const o = i.count;
    for (let a = 0; a < o; a++)
      (this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0);
    (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.resolveDepthBuffer = i.resolveDepthBuffer),
      (this.resolveStencilBuffer = i.resolveStencilBuffer),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      (this.width = e), (this.height = n), (this.depth = i);
      for (let r = 0, s = this.textures.length; r < s; r++)
        (this.textures[r].image.width = e),
          (this.textures[r].image.height = n),
          (this.textures[r].image.depth = i);
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let i = 0, r = e.textures.length; i < r; i++)
      (this.textures[i] = e.textures[i].clone()),
        (this.textures[i].isRenderTargetTexture = !0);
    const n = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new sS(n)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class gs extends JA {
  constructor(e = 1, n = 1, i = {}) {
    super(e, n, i), (this.isWebGLRenderTarget = !0);
  }
}
class oS extends zt {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: n, height: i, depth: r }),
      (this.magFilter = ln),
      (this.minFilter = ln),
      (this.wrapR = hi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class eb extends zt {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: n, height: i, depth: r }),
      (this.magFilter = ln),
      (this.minFilter = ln),
      (this.wrapR = hi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class vi {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, n, i, r, s, o, a) {
    let l = i[r + 0],
      c = i[r + 1],
      u = i[r + 2],
      f = i[r + 3];
    const d = s[o + 0],
      p = s[o + 1],
      g = s[o + 2],
      v = s[o + 3];
    if (a === 0) {
      (e[n + 0] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = f);
      return;
    }
    if (a === 1) {
      (e[n + 0] = d), (e[n + 1] = p), (e[n + 2] = g), (e[n + 3] = v);
      return;
    }
    if (f !== v || l !== d || c !== p || u !== g) {
      let m = 1 - a;
      const h = l * d + c * p + u * g + f * v,
        _ = h >= 0 ? 1 : -1,
        y = 1 - h * h;
      if (y > Number.EPSILON) {
        const C = Math.sqrt(y),
          R = Math.atan2(C, h * _);
        (m = Math.sin(m * R) / C), (a = Math.sin(a * R) / C);
      }
      const x = a * _;
      if (
        ((l = l * m + d * x),
        (c = c * m + p * x),
        (u = u * m + g * x),
        (f = f * m + v * x),
        m === 1 - a)
      ) {
        const C = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
        (l *= C), (c *= C), (u *= C), (f *= C);
      }
    }
    (e[n] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = f);
  }
  static multiplyQuaternionsFlat(e, n, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      c = i[r + 2],
      u = i[r + 3],
      f = s[o],
      d = s[o + 1],
      p = s[o + 2],
      g = s[o + 3];
    return (
      (e[n] = a * g + u * f + l * p - c * d),
      (e[n + 1] = l * g + u * d + c * f - a * p),
      (e[n + 2] = c * g + u * p + a * d - l * f),
      (e[n + 3] = u * g - a * f - l * d - c * p),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, n, i, r) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, n = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(i / 2),
      u = a(r / 2),
      f = a(s / 2),
      d = l(i / 2),
      p = l(r / 2),
      g = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = d * u * f + c * p * g),
          (this._y = c * p * f - d * u * g),
          (this._z = c * u * g + d * p * f),
          (this._w = c * u * f - d * p * g);
        break;
      case "YXZ":
        (this._x = d * u * f + c * p * g),
          (this._y = c * p * f - d * u * g),
          (this._z = c * u * g - d * p * f),
          (this._w = c * u * f + d * p * g);
        break;
      case "ZXY":
        (this._x = d * u * f - c * p * g),
          (this._y = c * p * f + d * u * g),
          (this._z = c * u * g + d * p * f),
          (this._w = c * u * f - d * p * g);
        break;
      case "ZYX":
        (this._x = d * u * f - c * p * g),
          (this._y = c * p * f + d * u * g),
          (this._z = c * u * g - d * p * f),
          (this._w = c * u * f + d * p * g);
        break;
      case "YZX":
        (this._x = d * u * f + c * p * g),
          (this._y = c * p * f + d * u * g),
          (this._z = c * u * g - d * p * f),
          (this._w = c * u * f - d * p * g);
        break;
      case "XZY":
        (this._x = d * u * f - c * p * g),
          (this._y = c * p * f - d * u * g),
          (this._z = c * u * g + d * p * f),
          (this._w = c * u * f + d * p * g);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const n = e.elements,
      i = n[0],
      r = n[4],
      s = n[8],
      o = n[1],
      a = n[5],
      l = n[9],
      c = n[2],
      u = n[6],
      f = n[10],
      d = i + a + f;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      (this._w = 0.25 / p),
        (this._x = (u - l) * p),
        (this._y = (s - c) * p),
        (this._z = (o - r) * p);
    } else if (i > a && i > f) {
      const p = 2 * Math.sqrt(1 + i - a - f);
      (this._w = (u - l) / p),
        (this._x = 0.25 * p),
        (this._y = (r + o) / p),
        (this._z = (s + c) / p);
    } else if (a > f) {
      const p = 2 * Math.sqrt(1 + a - i - f);
      (this._w = (s - c) / p),
        (this._x = (r + o) / p),
        (this._y = 0.25 * p),
        (this._z = (l + u) / p);
    } else {
      const p = 2 * Math.sqrt(1 + f - i - a);
      (this._w = (o - r) / p),
        (this._x = (s + c) / p),
        (this._y = (l + u) / p),
        (this._z = 0.25 * p);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * n.z - e.z * n.y),
          (this._y = e.z * n.x - e.x * n.z),
          (this._z = e.x * n.y - e.y * n.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Ft(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, n / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = n._x,
      l = n._y,
      c = n._z,
      u = n._w;
    return (
      (this._x = i * u + o * a + r * c - s * l),
      (this._y = r * u + o * l + s * a - i * c),
      (this._z = s * u + o * c + i * l - r * a),
      (this._w = o * u - i * a - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const p = 1 - n;
      return (
        (this._w = p * o + n * this._w),
        (this._x = p * i + n * this._x),
        (this._y = p * r + n * this._y),
        (this._z = p * s + n * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, a),
      f = Math.sin((1 - n) * u) / c,
      d = Math.sin(n * u) / c;
    return (
      (this._w = o * f + this._w * d),
      (this._x = i * f + this._x * d),
      (this._y = r * f + this._y * d),
      (this._z = s * f + this._z * d),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      n = 2 * Math.PI * Math.random(),
      i = Math.random(),
      r = Math.sqrt(1 - i),
      s = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(n),
      s * Math.cos(n)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, n = 0) {
    return (
      (this._x = e[n]),
      (this._y = e[n + 1]),
      (this._z = e[n + 2]),
      (this._w = e[n + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this._x = e.getX(n)),
      (this._y = e.getY(n)),
      (this._z = e.getZ(n)),
      (this._w = e.getW(n)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class D {
  constructor(e = 0, n = 0, i = 0) {
    (D.prototype.isVector3 = !0), (this.x = e), (this.y = n), (this.z = i);
  }
  set(e, n, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = n),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x), (this.y = e.y + n.y), (this.z = e.z + n.z), this
    );
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), (this.z += e.z * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x), (this.y = e.y - n.y), (this.z = e.z - n.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, n) {
    return (
      (this.x = e.x * n.x), (this.y = e.y * n.y), (this.z = e.z * n.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(I_.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(I_.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * n + s[3] * i + s[6] * r),
      (this.y = s[1] * n + s[4] * i + s[7] * r),
      (this.z = s[2] * n + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * n + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * n + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * n + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * n + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (o * r - a * i),
      u = 2 * (a * n - s * r),
      f = 2 * (s * i - o * n);
    return (
      (this.x = n + l * c + o * f - a * u),
      (this.y = i + l * u + a * c - s * f),
      (this.z = r + l * f + s * u - o * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * n + s[4] * i + s[8] * r),
      (this.y = s[1] * n + s[5] * i + s[9] * r),
      (this.z = s[2] * n + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      this
    );
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(n, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      this
    );
  }
  lerpVectors(e, n, i) {
    return (
      (this.x = e.x + (n.x - e.x) * i),
      (this.y = e.y + (n.y - e.y) * i),
      (this.z = e.z + (n.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = n.x,
      a = n.y,
      l = n.z;
    return (
      (this.x = r * l - s * a),
      (this.y = s * o - i * l),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return uf.copy(this).projectOnVector(e), this.sub(uf);
  }
  reflect(e) {
    return this.sub(uf.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Ft(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return n * n + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const r = Math.sin(n) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(n) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return (
      (this.x = e * Math.sin(n)), (this.y = i), (this.z = e * Math.cos(n)), this
    );
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return (this.x = n[12]), (this.y = n[13]), (this.z = n[14]), this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = n), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), (this.z = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), (e[n + 2] = this.z), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)), (this.y = e.getY(n)), (this.z = e.getZ(n)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      n = Math.random() * 2 - 1,
      i = Math.sqrt(1 - n * n);
    return (
      (this.x = i * Math.cos(e)), (this.y = n), (this.z = i * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const uf = new D(),
  I_ = new vi();
class tr {
  constructor(
    e = new D(1 / 0, 1 / 0, 1 / 0),
    n = new D(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(Xn.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(Xn.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = Xn.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (n === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, Xn)
            : Xn.fromBufferAttribute(s, o),
            Xn.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Xn);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            bl.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            bl.copy(i.boundingBox)),
          bl.applyMatrix4(e.matrixWorld),
          this.union(bl);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], n);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Xn),
      Xn.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let n, i;
    return (
      e.normal.x > 0
        ? ((n = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((n = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((n += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((n += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((n += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((n += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      n <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(qo),
      Rl.subVectors(this.max, qo),
      ws.subVectors(e.a, qo),
      As.subVectors(e.b, qo),
      bs.subVectors(e.c, qo),
      or.subVectors(As, ws),
      ar.subVectors(bs, As),
      Vr.subVectors(ws, bs);
    let n = [
      0,
      -or.z,
      or.y,
      0,
      -ar.z,
      ar.y,
      0,
      -Vr.z,
      Vr.y,
      or.z,
      0,
      -or.x,
      ar.z,
      0,
      -ar.x,
      Vr.z,
      0,
      -Vr.x,
      -or.y,
      or.x,
      0,
      -ar.y,
      ar.x,
      0,
      -Vr.y,
      Vr.x,
      0,
    ];
    return !ff(n, ws, As, bs, Rl) ||
      ((n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !ff(n, ws, As, bs, Rl))
      ? !1
      : (Cl.crossVectors(or, ar),
        (n = [Cl.x, Cl.y, Cl.z]),
        ff(n, ws, As, bs, Rl));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Xn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Xn).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ai[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ai[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ai[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ai[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ai[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ai[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ai[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ai[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ai),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ai = [
    new D(),
    new D(),
    new D(),
    new D(),
    new D(),
    new D(),
    new D(),
    new D(),
  ],
  Xn = new D(),
  bl = new tr(),
  ws = new D(),
  As = new D(),
  bs = new D(),
  or = new D(),
  ar = new D(),
  Vr = new D(),
  qo = new D(),
  Rl = new D(),
  Cl = new D(),
  Gr = new D();
function ff(t, e, n, i, r) {
  for (let s = 0, o = t.length - 3; s <= o; s += 3) {
    Gr.fromArray(t, s);
    const a =
        r.x * Math.abs(Gr.x) + r.y * Math.abs(Gr.y) + r.z * Math.abs(Gr.z),
      l = e.dot(Gr),
      c = n.dot(Gr),
      u = i.dot(Gr);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
  }
  return !0;
}
const tb = new tr(),
  $o = new D(),
  df = new D();
class xi {
  constructor(e = new D(), n = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = n);
  }
  set(e, n) {
    return this.center.copy(e), (this.radius = n), this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : tb.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return (
      n.copy(e),
      i > this.radius * this.radius &&
        (n.sub(this.center).normalize(),
        n.multiplyScalar(this.radius).add(this.center)),
      n
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    $o.subVectors(e, this.center);
    const n = $o.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector($o, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (df.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint($o.copy(e.center).add(df)),
            this.expandByPoint($o.copy(e.center).sub(df))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const bi = new D(),
  hf = new D(),
  Pl = new D(),
  lr = new D(),
  pf = new D(),
  Ll = new D(),
  mf = new D();
class nl {
  constructor(e = new D(), n = new D(0, 0, -1)) {
    (this.origin = e), (this.direction = n);
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, bi)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0
      ? n.copy(this.origin)
      : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = bi.subVectors(e, this.origin).dot(this.direction);
    return n < 0
      ? this.origin.distanceToSquared(e)
      : (bi.copy(this.origin).addScaledVector(this.direction, n),
        bi.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, r) {
    hf.copy(e).add(n).multiplyScalar(0.5),
      Pl.copy(n).sub(e).normalize(),
      lr.copy(this.origin).sub(hf);
    const s = e.distanceTo(n) * 0.5,
      o = -this.direction.dot(Pl),
      a = lr.dot(this.direction),
      l = -lr.dot(Pl),
      c = lr.lengthSq(),
      u = Math.abs(1 - o * o);
    let f, d, p, g;
    if (u > 0)
      if (((f = o * l - a), (d = o * a - l), (g = s * u), f >= 0))
        if (d >= -g)
          if (d <= g) {
            const v = 1 / u;
            (f *= v),
              (d *= v),
              (p = f * (f + o * d + 2 * a) + d * (o * f + d + 2 * l) + c);
          } else
            (d = s),
              (f = Math.max(0, -(o * d + a))),
              (p = -f * f + d * (d + 2 * l) + c);
        else
          (d = -s),
            (f = Math.max(0, -(o * d + a))),
            (p = -f * f + d * (d + 2 * l) + c);
      else
        d <= -g
          ? ((f = Math.max(0, -(-o * s + a))),
            (d = f > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (p = -f * f + d * (d + 2 * l) + c))
          : d <= g
          ? ((f = 0),
            (d = Math.min(Math.max(-s, -l), s)),
            (p = d * (d + 2 * l) + c))
          : ((f = Math.max(0, -(o * s + a))),
            (d = f > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (p = -f * f + d * (d + 2 * l) + c));
    else
      (d = o > 0 ? -s : s),
        (f = Math.max(0, -(o * d + a))),
        (p = -f * f + d * (d + 2 * l) + c);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, f),
      r && r.copy(hf).addScaledVector(Pl, d),
      p
    );
  }
  intersectSphere(e, n) {
    bi.subVectors(e.center, this.origin);
    const i = bi.dot(this.direction),
      r = bi.dot(bi) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, n) : this.at(a, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, r, s, o, a, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      f = 1 / this.direction.z,
      d = this.origin;
    return (
      c >= 0
        ? ((i = (e.min.x - d.x) * c), (r = (e.max.x - d.x) * c))
        : ((i = (e.max.x - d.x) * c), (r = (e.min.x - d.x) * c)),
      u >= 0
        ? ((s = (e.min.y - d.y) * u), (o = (e.max.y - d.y) * u))
        : ((s = (e.max.y - d.y) * u), (o = (e.min.y - d.y) * u)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      f >= 0
        ? ((a = (e.min.z - d.z) * f), (l = (e.max.z - d.z) * f))
        : ((a = (e.max.z - d.z) * f), (l = (e.min.z - d.z) * f)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, n)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, bi) !== null;
  }
  intersectTriangle(e, n, i, r, s) {
    pf.subVectors(n, e), Ll.subVectors(i, e), mf.crossVectors(pf, Ll);
    let o = this.direction.dot(mf),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    lr.subVectors(this.origin, e);
    const l = a * this.direction.dot(Ll.crossVectors(lr, Ll));
    if (l < 0) return null;
    const c = a * this.direction.dot(pf.cross(lr));
    if (c < 0 || l + c > o) return null;
    const u = -a * lr.dot(mf);
    return u < 0 ? null : this.at(u / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Be {
  constructor(e, n, i, r, s, o, a, l, c, u, f, d, p, g, v, m) {
    (Be.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, i, r, s, o, a, l, c, u, f, d, p, g, v, m);
  }
  set(e, n, i, r, s, o, a, l, c, u, f, d, p, g, v, m) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[4] = n),
      (h[8] = i),
      (h[12] = r),
      (h[1] = s),
      (h[5] = o),
      (h[9] = a),
      (h[13] = l),
      (h[2] = c),
      (h[6] = u),
      (h[10] = f),
      (h[14] = d),
      (h[3] = p),
      (h[7] = g),
      (h[11] = v),
      (h[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Be().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements,
      i = e.elements;
    return (
      (n[0] = i[0]),
      (n[1] = i[1]),
      (n[2] = i[2]),
      (n[3] = i[3]),
      (n[4] = i[4]),
      (n[5] = i[5]),
      (n[6] = i[6]),
      (n[7] = i[7]),
      (n[8] = i[8]),
      (n[9] = i[9]),
      (n[10] = i[10]),
      (n[11] = i[11]),
      (n[12] = i[12]),
      (n[13] = i[13]),
      (n[14] = i[14]),
      (n[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const n = this.elements,
      i = e.elements;
    return (n[12] = i[12]), (n[13] = i[13]), (n[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return (
      this.set(
        n[0],
        n[3],
        n[6],
        0,
        n[1],
        n[4],
        n[7],
        0,
        n[2],
        n[5],
        n[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, n, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      n.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, n, i) {
    return (
      this.set(
        e.x,
        n.x,
        i.x,
        0,
        e.y,
        n.y,
        i.y,
        0,
        e.z,
        n.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const n = this.elements,
      i = e.elements,
      r = 1 / Rs.setFromMatrixColumn(e, 0).length(),
      s = 1 / Rs.setFromMatrixColumn(e, 1).length(),
      o = 1 / Rs.setFromMatrixColumn(e, 2).length();
    return (
      (n[0] = i[0] * r),
      (n[1] = i[1] * r),
      (n[2] = i[2] * r),
      (n[3] = 0),
      (n[4] = i[4] * s),
      (n[5] = i[5] * s),
      (n[6] = i[6] * s),
      (n[7] = 0),
      (n[8] = i[8] * o),
      (n[9] = i[9] * o),
      (n[10] = i[10] * o),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const n = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      c = Math.sin(r),
      u = Math.cos(s),
      f = Math.sin(s);
    if (e.order === "XYZ") {
      const d = o * u,
        p = o * f,
        g = a * u,
        v = a * f;
      (n[0] = l * u),
        (n[4] = -l * f),
        (n[8] = c),
        (n[1] = p + g * c),
        (n[5] = d - v * c),
        (n[9] = -a * l),
        (n[2] = v - d * c),
        (n[6] = g + p * c),
        (n[10] = o * l);
    } else if (e.order === "YXZ") {
      const d = l * u,
        p = l * f,
        g = c * u,
        v = c * f;
      (n[0] = d + v * a),
        (n[4] = g * a - p),
        (n[8] = o * c),
        (n[1] = o * f),
        (n[5] = o * u),
        (n[9] = -a),
        (n[2] = p * a - g),
        (n[6] = v + d * a),
        (n[10] = o * l);
    } else if (e.order === "ZXY") {
      const d = l * u,
        p = l * f,
        g = c * u,
        v = c * f;
      (n[0] = d - v * a),
        (n[4] = -o * f),
        (n[8] = g + p * a),
        (n[1] = p + g * a),
        (n[5] = o * u),
        (n[9] = v - d * a),
        (n[2] = -o * c),
        (n[6] = a),
        (n[10] = o * l);
    } else if (e.order === "ZYX") {
      const d = o * u,
        p = o * f,
        g = a * u,
        v = a * f;
      (n[0] = l * u),
        (n[4] = g * c - p),
        (n[8] = d * c + v),
        (n[1] = l * f),
        (n[5] = v * c + d),
        (n[9] = p * c - g),
        (n[2] = -c),
        (n[6] = a * l),
        (n[10] = o * l);
    } else if (e.order === "YZX") {
      const d = o * l,
        p = o * c,
        g = a * l,
        v = a * c;
      (n[0] = l * u),
        (n[4] = v - d * f),
        (n[8] = g * f + p),
        (n[1] = f),
        (n[5] = o * u),
        (n[9] = -a * u),
        (n[2] = -c * u),
        (n[6] = p * f + g),
        (n[10] = d - v * f);
    } else if (e.order === "XZY") {
      const d = o * l,
        p = o * c,
        g = a * l,
        v = a * c;
      (n[0] = l * u),
        (n[4] = -f),
        (n[8] = c * u),
        (n[1] = d * f + v),
        (n[5] = o * u),
        (n[9] = p * f - g),
        (n[2] = g * f - p),
        (n[6] = a * u),
        (n[10] = v * f + d);
    }
    return (
      (n[3] = 0),
      (n[7] = 0),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(nb, e, ib);
  }
  lookAt(e, n, i) {
    const r = this.elements;
    return (
      Mn.subVectors(e, n),
      Mn.lengthSq() === 0 && (Mn.z = 1),
      Mn.normalize(),
      cr.crossVectors(i, Mn),
      cr.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (Mn.x += 1e-4) : (Mn.z += 1e-4),
        Mn.normalize(),
        cr.crossVectors(i, Mn)),
      cr.normalize(),
      Il.crossVectors(Mn, cr),
      (r[0] = cr.x),
      (r[4] = Il.x),
      (r[8] = Mn.x),
      (r[1] = cr.y),
      (r[5] = Il.y),
      (r[9] = Mn.y),
      (r[2] = cr.z),
      (r[6] = Il.z),
      (r[10] = Mn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements,
      r = n.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      c = i[12],
      u = i[1],
      f = i[5],
      d = i[9],
      p = i[13],
      g = i[2],
      v = i[6],
      m = i[10],
      h = i[14],
      _ = i[3],
      y = i[7],
      x = i[11],
      C = i[15],
      R = r[0],
      w = r[4],
      A = r[8],
      E = r[12],
      S = r[1],
      P = r[5],
      G = r[9],
      F = r[13],
      H = r[2],
      X = r[6],
      V = r[10],
      Z = r[14],
      L = r[3],
      Y = r[7],
      q = r[11],
      oe = r[15];
    return (
      (s[0] = o * R + a * S + l * H + c * L),
      (s[4] = o * w + a * P + l * X + c * Y),
      (s[8] = o * A + a * G + l * V + c * q),
      (s[12] = o * E + a * F + l * Z + c * oe),
      (s[1] = u * R + f * S + d * H + p * L),
      (s[5] = u * w + f * P + d * X + p * Y),
      (s[9] = u * A + f * G + d * V + p * q),
      (s[13] = u * E + f * F + d * Z + p * oe),
      (s[2] = g * R + v * S + m * H + h * L),
      (s[6] = g * w + v * P + m * X + h * Y),
      (s[10] = g * A + v * G + m * V + h * q),
      (s[14] = g * E + v * F + m * Z + h * oe),
      (s[3] = _ * R + y * S + x * H + C * L),
      (s[7] = _ * w + y * P + x * X + C * Y),
      (s[11] = _ * A + y * G + x * V + C * q),
      (s[15] = _ * E + y * F + x * Z + C * oe),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[4] *= e),
      (n[8] *= e),
      (n[12] *= e),
      (n[1] *= e),
      (n[5] *= e),
      (n[9] *= e),
      (n[13] *= e),
      (n[2] *= e),
      (n[6] *= e),
      (n[10] *= e),
      (n[14] *= e),
      (n[3] *= e),
      (n[7] *= e),
      (n[11] *= e),
      (n[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      f = e[6],
      d = e[10],
      p = e[14],
      g = e[3],
      v = e[7],
      m = e[11],
      h = e[15];
    return (
      g *
        (+s * l * f -
          r * c * f -
          s * a * d +
          i * c * d +
          r * a * p -
          i * l * p) +
      v *
        (+n * l * p -
          n * c * d +
          s * o * d -
          r * o * p +
          r * c * u -
          s * l * u) +
      m *
        (+n * c * f -
          n * a * p -
          s * o * f +
          i * o * p +
          s * a * u -
          i * c * u) +
      h *
        (-r * a * u - n * l * f + n * a * d + r * o * f - i * o * d + i * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let n;
    return (
      (n = e[1]),
      (e[1] = e[4]),
      (e[4] = n),
      (n = e[2]),
      (e[2] = e[8]),
      (e[8] = n),
      (n = e[6]),
      (e[6] = e[9]),
      (e[9] = n),
      (n = e[3]),
      (e[3] = e[12]),
      (e[12] = n),
      (n = e[7]),
      (e[7] = e[13]),
      (e[13] = n),
      (n = e[11]),
      (e[11] = e[14]),
      (e[14] = n),
      this
    );
  }
  setPosition(e, n, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = n), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      f = e[9],
      d = e[10],
      p = e[11],
      g = e[12],
      v = e[13],
      m = e[14],
      h = e[15],
      _ = f * m * c - v * d * c + v * l * p - a * m * p - f * l * h + a * d * h,
      y = g * d * c - u * m * c - g * l * p + o * m * p + u * l * h - o * d * h,
      x = u * v * c - g * f * c + g * a * p - o * v * p - u * a * h + o * f * h,
      C = g * f * l - u * v * l - g * a * d + o * v * d + u * a * m - o * f * m,
      R = n * _ + i * y + r * x + s * C;
    if (R === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / R;
    return (
      (e[0] = _ * w),
      (e[1] =
        (v * d * s -
          f * m * s -
          v * r * p +
          i * m * p +
          f * r * h -
          i * d * h) *
        w),
      (e[2] =
        (a * m * s -
          v * l * s +
          v * r * c -
          i * m * c -
          a * r * h +
          i * l * h) *
        w),
      (e[3] =
        (f * l * s -
          a * d * s -
          f * r * c +
          i * d * c +
          a * r * p -
          i * l * p) *
        w),
      (e[4] = y * w),
      (e[5] =
        (u * m * s -
          g * d * s +
          g * r * p -
          n * m * p -
          u * r * h +
          n * d * h) *
        w),
      (e[6] =
        (g * l * s -
          o * m * s -
          g * r * c +
          n * m * c +
          o * r * h -
          n * l * h) *
        w),
      (e[7] =
        (o * d * s -
          u * l * s +
          u * r * c -
          n * d * c -
          o * r * p +
          n * l * p) *
        w),
      (e[8] = x * w),
      (e[9] =
        (g * f * s -
          u * v * s -
          g * i * p +
          n * v * p +
          u * i * h -
          n * f * h) *
        w),
      (e[10] =
        (o * v * s -
          g * a * s +
          g * i * c -
          n * v * c -
          o * i * h +
          n * a * h) *
        w),
      (e[11] =
        (u * a * s -
          o * f * s -
          u * i * c +
          n * f * c +
          o * i * p -
          n * a * p) *
        w),
      (e[12] = C * w),
      (e[13] =
        (u * v * r -
          g * f * r +
          g * i * d -
          n * v * d -
          u * i * m +
          n * f * m) *
        w),
      (e[14] =
        (g * a * r -
          o * v * r -
          g * i * l +
          n * v * l +
          o * i * m -
          n * a * m) *
        w),
      (e[15] =
        (o * f * r -
          u * a * r +
          u * i * l -
          n * f * l -
          o * i * d +
          n * a * d) *
        w),
      this
    );
  }
  scale(e) {
    const n = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (n[0] *= i),
      (n[4] *= r),
      (n[8] *= s),
      (n[1] *= i),
      (n[5] *= r),
      (n[9] *= s),
      (n[2] *= i),
      (n[6] *= r),
      (n[10] *= s),
      (n[3] *= i),
      (n[7] *= r),
      (n[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, r));
  }
  makeTranslation(e, n, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n),
      r = Math.sin(n),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      c = s * o,
      u = s * a;
    return (
      this.set(
        c * o + i,
        c * a - r * l,
        c * l + r * a,
        0,
        c * a + r * l,
        u * a + i,
        u * l - r * o,
        0,
        c * l - r * a,
        u * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, n, i) {
    return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, n, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, n, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, n, i) {
    const r = this.elements,
      s = n._x,
      o = n._y,
      a = n._z,
      l = n._w,
      c = s + s,
      u = o + o,
      f = a + a,
      d = s * c,
      p = s * u,
      g = s * f,
      v = o * u,
      m = o * f,
      h = a * f,
      _ = l * c,
      y = l * u,
      x = l * f,
      C = i.x,
      R = i.y,
      w = i.z;
    return (
      (r[0] = (1 - (v + h)) * C),
      (r[1] = (p + x) * C),
      (r[2] = (g - y) * C),
      (r[3] = 0),
      (r[4] = (p - x) * R),
      (r[5] = (1 - (d + h)) * R),
      (r[6] = (m + _) * R),
      (r[7] = 0),
      (r[8] = (g + y) * w),
      (r[9] = (m - _) * w),
      (r[10] = (1 - (d + v)) * w),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, n, i) {
    const r = this.elements;
    let s = Rs.set(r[0], r[1], r[2]).length();
    const o = Rs.set(r[4], r[5], r[6]).length(),
      a = Rs.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Yn.copy(this);
    const c = 1 / s,
      u = 1 / o,
      f = 1 / a;
    return (
      (Yn.elements[0] *= c),
      (Yn.elements[1] *= c),
      (Yn.elements[2] *= c),
      (Yn.elements[4] *= u),
      (Yn.elements[5] *= u),
      (Yn.elements[6] *= u),
      (Yn.elements[8] *= f),
      (Yn.elements[9] *= f),
      (Yn.elements[10] *= f),
      n.setFromRotationMatrix(Yn),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, n, i, r, s, o, a = Hi) {
    const l = this.elements,
      c = (2 * s) / (n - e),
      u = (2 * s) / (i - r),
      f = (n + e) / (n - e),
      d = (i + r) / (i - r);
    let p, g;
    if (a === Hi) (p = -(o + s) / (o - s)), (g = (-2 * o * s) / (o - s));
    else if (a === Qc) (p = -o / (o - s)), (g = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = f),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = d),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = p),
      (l[14] = g),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, n, i, r, s, o, a = Hi) {
    const l = this.elements,
      c = 1 / (n - e),
      u = 1 / (i - r),
      f = 1 / (o - s),
      d = (n + e) * c,
      p = (i + r) * u;
    let g, v;
    if (a === Hi) (g = (o + s) * f), (v = -2 * f);
    else if (a === Qc) (g = s * f), (v = -1 * f);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -d),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -p),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = v),
      (l[14] = -g),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const n = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return (
      (e[n] = i[0]),
      (e[n + 1] = i[1]),
      (e[n + 2] = i[2]),
      (e[n + 3] = i[3]),
      (e[n + 4] = i[4]),
      (e[n + 5] = i[5]),
      (e[n + 6] = i[6]),
      (e[n + 7] = i[7]),
      (e[n + 8] = i[8]),
      (e[n + 9] = i[9]),
      (e[n + 10] = i[10]),
      (e[n + 11] = i[11]),
      (e[n + 12] = i[12]),
      (e[n + 13] = i[13]),
      (e[n + 14] = i[14]),
      (e[n + 15] = i[15]),
      e
    );
  }
}
const Rs = new D(),
  Yn = new Be(),
  nb = new D(0, 0, 0),
  ib = new D(1, 1, 1),
  cr = new D(),
  Il = new D(),
  Mn = new D(),
  D_ = new Be(),
  N_ = new vi();
class yi {
  constructor(e = 0, n = 0, i = 0, r = yi.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, n, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      c = r[5],
      u = r[9],
      f = r[2],
      d = r[6],
      p = r[10];
    switch (n) {
      case "XYZ":
        (this._y = Math.asin(Ft(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, p)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(d, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Ft(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-f, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Ft(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-f, p)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Ft(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
        break;
      case "YZX":
        (this._z = Math.asin(Ft(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-f, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, p)));
        break;
      case "XZY":
        (this._z = Math.asin(-Ft(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-u, p)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            n
        );
    }
    return (this._order = n), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return (
      D_.makeRotationFromQuaternion(e), this.setFromRotationMatrix(D_, n, i)
    );
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return N_.setFromEuler(this), this.setFromQuaternion(N_, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
yi.DEFAULT_ORDER = "XYZ";
class aS {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let rb = 0;
const U_ = new D(),
  Cs = new vi(),
  Ri = new Be(),
  Dl = new D(),
  Zo = new D(),
  sb = new D(),
  ob = new vi(),
  O_ = new D(1, 0, 0),
  F_ = new D(0, 1, 0),
  k_ = new D(0, 0, 1),
  B_ = { type: "added" },
  ab = { type: "removed" },
  Ps = { type: "childadded", child: null },
  gf = { type: "childremoved", child: null };
class Mt extends ys {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: rb++ }),
      (this.uuid = ni()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Mt.DEFAULT_UP.clone());
    const e = new D(),
      n = new yi(),
      i = new vi(),
      r = new D(1, 1, 1);
    function s() {
      i.setFromEuler(n, !1);
    }
    function o() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: n },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new Be() },
        normalMatrix: { value: new ke() },
      }),
      (this.matrix = new Be()),
      (this.matrixWorld = new Be()),
      (this.matrixAutoUpdate = Mt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new aS()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return Cs.setFromAxisAngle(e, n), this.quaternion.multiply(Cs), this;
  }
  rotateOnWorldAxis(e, n) {
    return Cs.setFromAxisAngle(e, n), this.quaternion.premultiply(Cs), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(O_, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(F_, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(k_, e);
  }
  translateOnAxis(e, n) {
    return (
      U_.copy(e).applyQuaternion(this.quaternion),
      this.position.add(U_.multiplyScalar(n)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(O_, e);
  }
  translateY(e) {
    return this.translateOnAxis(F_, e);
  }
  translateZ(e) {
    return this.translateOnAxis(k_, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Ri.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, n, i) {
    e.isVector3 ? Dl.copy(e) : Dl.set(e, n, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Zo.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Ri.lookAt(Zo, Dl, this.up)
        : Ri.lookAt(Dl, Zo, this.up),
      this.quaternion.setFromRotationMatrix(Ri),
      r &&
        (Ri.extractRotation(r.matrixWorld),
        Cs.setFromRotationMatrix(Ri),
        this.quaternion.premultiply(Cs.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(B_),
            (Ps.child = e),
            this.dispatchEvent(Ps),
            (Ps.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return (
      n !== -1 &&
        ((e.parent = null),
        this.children.splice(n, 1),
        e.dispatchEvent(ab),
        (gf.child = e),
        this.dispatchEvent(gf),
        (gf.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ri.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Ri.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Ri),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(B_),
      (Ps.child = e),
      this.dispatchEvent(Ps),
      (Ps.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, n);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].getObjectsByProperty(e, n, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zo, e, sb), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Zo, ob, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++) n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++) n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++) n[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (
      (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      n === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) r[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string",
      i = {};
    n &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray(),
          }));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const f = l[c];
            s(e.shapes, f);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (n) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        u = o(e.images),
        f = o(e.shapes),
        d = o(e.skeletons),
        p = o(e.animations),
        g = o(e.nodes);
      a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        c.length > 0 && (i.textures = c),
        u.length > 0 && (i.images = u),
        f.length > 0 && (i.shapes = f),
        d.length > 0 && (i.skeletons = d),
        p.length > 0 && (i.animations = p),
        g.length > 0 && (i.nodes = g);
    }
    return (i.object = r), i;
    function o(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      n === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Mt.DEFAULT_UP = new D(0, 1, 0);
Mt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Kn = new D(),
  Ci = new D(),
  _f = new D(),
  Pi = new D(),
  Ls = new D(),
  Is = new D(),
  z_ = new D(),
  vf = new D(),
  yf = new D(),
  xf = new D(),
  Sf = new et(),
  Mf = new et(),
  Ef = new et();
class Jn {
  constructor(e = new D(), n = new D(), i = new D()) {
    (this.a = e), (this.b = n), (this.c = i);
  }
  static getNormal(e, n, i, r) {
    r.subVectors(i, n), Kn.subVectors(e, n), r.cross(Kn);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, n, i, r, s) {
    Kn.subVectors(r, n), Ci.subVectors(i, n), _f.subVectors(e, n);
    const o = Kn.dot(Kn),
      a = Kn.dot(Ci),
      l = Kn.dot(_f),
      c = Ci.dot(Ci),
      u = Ci.dot(_f),
      f = o * c - a * a;
    if (f === 0) return s.set(0, 0, 0), null;
    const d = 1 / f,
      p = (c * l - a * u) * d,
      g = (o * u - a * l) * d;
    return s.set(1 - p - g, g, p);
  }
  static containsPoint(e, n, i, r) {
    return this.getBarycoord(e, n, i, r, Pi) === null
      ? !1
      : Pi.x >= 0 && Pi.y >= 0 && Pi.x + Pi.y <= 1;
  }
  static getInterpolation(e, n, i, r, s, o, a, l) {
    return this.getBarycoord(e, n, i, r, Pi) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, Pi.x),
        l.addScaledVector(o, Pi.y),
        l.addScaledVector(a, Pi.z),
        l);
  }
  static getInterpolatedAttribute(e, n, i, r, s, o) {
    return (
      Sf.setScalar(0),
      Mf.setScalar(0),
      Ef.setScalar(0),
      Sf.fromBufferAttribute(e, n),
      Mf.fromBufferAttribute(e, i),
      Ef.fromBufferAttribute(e, r),
      o.setScalar(0),
      o.addScaledVector(Sf, s.x),
      o.addScaledVector(Mf, s.y),
      o.addScaledVector(Ef, s.z),
      o
    );
  }
  static isFrontFacing(e, n, i, r) {
    return Kn.subVectors(i, n), Ci.subVectors(e, n), Kn.cross(Ci).dot(r) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, r) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, n, i, r) {
    return (
      this.a.fromBufferAttribute(e, n),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Kn.subVectors(this.c, this.b),
      Ci.subVectors(this.a, this.b),
      Kn.cross(Ci).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Jn.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return Jn.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, i, r, s) {
    return Jn.getInterpolation(e, this.a, this.b, this.c, n, i, r, s);
  }
  containsPoint(e) {
    return Jn.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Jn.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    Ls.subVectors(r, i), Is.subVectors(s, i), vf.subVectors(e, i);
    const l = Ls.dot(vf),
      c = Is.dot(vf);
    if (l <= 0 && c <= 0) return n.copy(i);
    yf.subVectors(e, r);
    const u = Ls.dot(yf),
      f = Is.dot(yf);
    if (u >= 0 && f <= u) return n.copy(r);
    const d = l * f - u * c;
    if (d <= 0 && l >= 0 && u <= 0)
      return (o = l / (l - u)), n.copy(i).addScaledVector(Ls, o);
    xf.subVectors(e, s);
    const p = Ls.dot(xf),
      g = Is.dot(xf);
    if (g >= 0 && p <= g) return n.copy(s);
    const v = p * c - l * g;
    if (v <= 0 && c >= 0 && g <= 0)
      return (a = c / (c - g)), n.copy(i).addScaledVector(Is, a);
    const m = u * g - p * f;
    if (m <= 0 && f - u >= 0 && p - g >= 0)
      return (
        z_.subVectors(s, r),
        (a = (f - u) / (f - u + (p - g))),
        n.copy(r).addScaledVector(z_, a)
      );
    const h = 1 / (m + v + d);
    return (
      (o = v * h),
      (a = d * h),
      n.copy(i).addScaledVector(Ls, o).addScaledVector(Is, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const lS = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  ur = { h: 0, s: 0, l: 0 },
  Nl = { h: 0, s: 0, l: 0 };
function Tf(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * 6 * n
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * 6 * (2 / 3 - n)
      : t
  );
}
class De {
  constructor(e, n, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, n, i)
    );
  }
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
        ? this.setHex(r)
        : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, n, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, n = Gt) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Xe.toWorkingColorSpace(this, n),
      this
    );
  }
  setRGB(e, n, i, r = Xe.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = n),
      (this.b = i),
      Xe.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, n, i, r = Xe.workingColorSpace) {
    if (((e = sm(e, 1)), (n = Ft(n, 0, 1)), (i = Ft(i, 0, 1)), n === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + n) : i + n - i * n,
        o = 2 * i - s;
      (this.r = Tf(o, s, e + 1 / 3)),
        (this.g = Tf(o, s, e)),
        (this.b = Tf(o, s, e - 1 / 3));
    }
    return Xe.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, n = Gt) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                n
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                n
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                n
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          n
        );
      if (o === 6) return this.setHex(parseInt(s, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = Gt) {
    const i = lS[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, n)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Gi(e.r)), (this.g = Gi(e.g)), (this.b = Gi(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = uo(e.r)), (this.g = uo(e.g)), (this.b = uo(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Gt) {
    return (
      Xe.fromWorkingColorSpace($t.copy(this), e),
      Math.round(Ft($t.r * 255, 0, 255)) * 65536 +
        Math.round(Ft($t.g * 255, 0, 255)) * 256 +
        Math.round(Ft($t.b * 255, 0, 255))
    );
  }
  getHexString(e = Gt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = Xe.workingColorSpace) {
    Xe.fromWorkingColorSpace($t.copy(this), n);
    const i = $t.r,
      r = $t.g,
      s = $t.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let l, c;
    const u = (a + o) / 2;
    if (a === o) (l = 0), (c = 0);
    else {
      const f = o - a;
      switch (((c = u <= 0.5 ? f / (o + a) : f / (2 - o - a)), o)) {
        case i:
          l = (r - s) / f + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / f + 2;
          break;
        case s:
          l = (i - r) / f + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, n = Xe.workingColorSpace) {
    return (
      Xe.fromWorkingColorSpace($t.copy(this), n),
      (e.r = $t.r),
      (e.g = $t.g),
      (e.b = $t.b),
      e
    );
  }
  getStyle(e = Gt) {
    Xe.fromWorkingColorSpace($t.copy(this), e);
    const n = $t.r,
      i = $t.g,
      r = $t.b;
    return e !== Gt
      ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(
          r * 255
        )})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(ur), this.setHSL(ur.h + e, ur.s + n, ur.l + i);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, n) {
    return (
      (this.r = e.r + n.r), (this.g = e.g + n.g), (this.b = e.b + n.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, n) {
    return (
      (this.r += (e.r - this.r) * n),
      (this.g += (e.g - this.g) * n),
      (this.b += (e.b - this.b) * n),
      this
    );
  }
  lerpColors(e, n, i) {
    return (
      (this.r = e.r + (n.r - e.r) * i),
      (this.g = e.g + (n.g - e.g) * i),
      (this.b = e.b + (n.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, n) {
    this.getHSL(ur), e.getHSL(Nl);
    const i = Ta(ur.h, Nl.h, n),
      r = Ta(ur.s, Nl.s, n),
      s = Ta(ur.l, Nl.l, n);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const n = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * n + s[3] * i + s[6] * r),
      (this.g = s[1] * n + s[4] * i + s[7] * r),
      (this.b = s[2] * n + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return (this.r = e[n]), (this.g = e[n + 1]), (this.b = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.r), (e[n + 1] = this.g), (e[n + 2] = this.b), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.r = e.getX(n)), (this.g = e.getY(n)), (this.b = e.getZ(n)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const $t = new De();
De.NAMES = lS;
let lb = 0;
class _i extends ys {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {}
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: lb++ }),
      (this.uuid = ni()),
      (this.name = ""),
      (this.blending = lo),
      (this.side = Zi),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = nh),
      (this.blendDst = ih),
      (this.blendEquation = Qr),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new De(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = So),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = E_),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Es),
      (this.stencilZFail = Es),
      (this.stencilZPass = Es),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const i = e[n];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${n}' has value of undefined.`
          );
          continue;
        }
        const r = this[n];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${n}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[n] = i);
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (i.dispersion = this.dispersion),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== lo && (i.blending = this.blending),
      this.side !== Zi && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== nh && (i.blendSrc = this.blendSrc),
      this.blendDst !== ih && (i.blendDst = this.blendDst),
      this.blendEquation !== Qr && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== So && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== E_ && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Es && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== Es && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Es && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (n) {
      const s = r(e.textures),
        o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const r = n.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = n[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class rs extends _i {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.color = new De(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new yi()),
      (this.combine = Vx),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Fi = cb();
function cb() {
  const t = new ArrayBuffer(4),
    e = new Float32Array(t),
    n = new Uint32Array(t),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : c < -14
      ? ((i[l] = 1024 >> (-c - 14)),
        (i[l | 256] = (1024 >> (-c - 14)) | 32768),
        (r[l] = -c - 1),
        (r[l | 256] = -c - 1))
      : c <= 15
      ? ((i[l] = (c + 15) << 10),
        (i[l | 256] = ((c + 15) << 10) | 32768),
        (r[l] = 13),
        (r[l | 256] = 13))
      : c < 128
      ? ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 24), (r[l | 256] = 24))
      : ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 13), (r[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0;
    for (; !(c & 8388608); ) (c <<= 1), (u -= 8388608);
    (c &= -8388609), (u += 947912704), (s[l] = c | u);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function ub(t) {
  Math.abs(t) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (t = Ft(t, -65504, 65504)),
    (Fi.floatView[0] = t);
  const e = Fi.uint32View[0],
    n = (e >> 23) & 511;
  return Fi.baseTable[n] + ((e & 8388607) >> Fi.shiftTable[n]);
}
function fb(t) {
  const e = t >> 10;
  return (
    (Fi.uint32View[0] =
      Fi.mantissaTable[Fi.offsetTable[e] + (t & 1023)] + Fi.exponentTable[e]),
    Fi.floatView[0]
  );
}
const Ul = { toHalfFloat: ub, fromHalfFloat: fb },
  Rt = new D(),
  Ol = new Le();
class cn {
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.normalized = i),
      (this.usage = Bh),
      (this.updateRanges = []),
      (this.gpuType = gn),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, n, i) {
    (e *= this.itemSize), (i *= n.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = n.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        Ol.fromBufferAttribute(this, n),
          Ol.applyMatrix3(e),
          this.setXY(n, Ol.x, Ol.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        Rt.fromBufferAttribute(this, n),
          Rt.applyMatrix3(e),
          this.setXYZ(n, Rt.x, Rt.y, Rt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Rt.fromBufferAttribute(this, n),
        Rt.applyMatrix4(e),
        this.setXYZ(n, Rt.x, Rt.y, Rt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Rt.fromBufferAttribute(this, n),
        Rt.applyNormalMatrix(e),
        this.setXYZ(n, Rt.x, Rt.y, Rt.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Rt.fromBufferAttribute(this, n),
        Rt.transformDirection(e),
        this.setXYZ(n, Rt.x, Rt.y, Rt.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = Qn(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return (
      this.normalized && (i = rt(i, this.array)),
      (this.array[e * this.itemSize + n] = i),
      this
    );
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.array[e * this.itemSize] = n),
      this
    );
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.array[e * this.itemSize + 1] = n),
      this
    );
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.array[e * this.itemSize + 2] = n),
      this
    );
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.array[e * this.itemSize + 3] = n),
      this
    );
  }
  setXY(e, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = rt(n, this.array)), (i = rt(i, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, n, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = rt(n, this.array)),
        (i = rt(i, this.array)),
        (r = rt(r, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, n, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = rt(n, this.array)),
        (i = rt(i, this.array)),
        (r = rt(r, this.array)),
        (s = rt(s, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Bh && (e.usage = this.usage),
      e
    );
  }
}
class cS extends cn {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class uS extends cn {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class Wi extends cn {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let db = 0;
const Nn = new Be(),
  wf = new Mt(),
  Ds = new D(),
  En = new tr(),
  Qo = new tr(),
  Ut = new D();
class Si extends ys {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: db++ }),
      (this.uuid = ni()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (rS(e) ? uS : cS)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return (this.attributes[e] = n), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({ start: e, count: n, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    (this.drawRange.start = e), (this.drawRange.count = n);
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), (n.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new ke().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Nn.makeRotationFromQuaternion(e), this.applyMatrix4(Nn), this;
  }
  rotateX(e) {
    return Nn.makeRotationX(e), this.applyMatrix4(Nn), this;
  }
  rotateY(e) {
    return Nn.makeRotationY(e), this.applyMatrix4(Nn), this;
  }
  rotateZ(e) {
    return Nn.makeRotationZ(e), this.applyMatrix4(Nn), this;
  }
  translate(e, n, i) {
    return Nn.makeTranslation(e, n, i), this.applyMatrix4(Nn), this;
  }
  scale(e, n, i) {
    return Nn.makeScale(e, n, i), this.applyMatrix4(Nn), this;
  }
  lookAt(e) {
    return wf.lookAt(e), wf.updateMatrix(), this.applyMatrix4(wf.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Ds).negate(),
      this.translate(Ds.x, Ds.y, Ds.z),
      this
    );
  }
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const i = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r];
        i.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new Wi(i, 3));
    } else {
      for (let i = 0, r = n.count; i < r; i++) {
        const s = e[i];
        n.setXYZ(i, s.x, s.y, s.z || 0);
      }
      e.length > n.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        ),
        (n.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new tr());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new D(-1 / 0, -1 / 0, -1 / 0),
          new D(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), n))
        for (let i = 0, r = n.length; i < r; i++) {
          const s = n[i];
          En.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Ut.addVectors(this.boundingBox.min, En.min),
                this.boundingBox.expandByPoint(Ut),
                Ut.addVectors(this.boundingBox.max, En.max),
                this.boundingBox.expandByPoint(Ut))
              : (this.boundingBox.expandByPoint(En.min),
                this.boundingBox.expandByPoint(En.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new xi());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new D(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((En.setFromBufferAttribute(e), n))
        for (let s = 0, o = n.length; s < o; s++) {
          const a = n[s];
          Qo.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Ut.addVectors(En.min, Qo.min),
                En.expandByPoint(Ut),
                Ut.addVectors(En.max, Qo.max),
                En.expandByPoint(Ut))
              : (En.expandByPoint(Qo.min), En.expandByPoint(Qo.max));
        }
      En.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Ut.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Ut)));
      if (n)
        for (let s = 0, o = n.length; s < o; s++) {
          const a = n[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            Ut.fromBufferAttribute(a, c),
              l && (Ds.fromBufferAttribute(e, c), Ut.add(Ds)),
              (r = Math.max(r, i.distanceToSquared(Ut)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      n = this.attributes;
    if (
      e === null ||
      n.position === void 0 ||
      n.normal === void 0 ||
      n.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = n.position,
      r = n.normal,
      s = n.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new cn(new Float32Array(4 * i.count), 4));
    const o = this.getAttribute("tangent"),
      a = [],
      l = [];
    for (let A = 0; A < i.count; A++) (a[A] = new D()), (l[A] = new D());
    const c = new D(),
      u = new D(),
      f = new D(),
      d = new Le(),
      p = new Le(),
      g = new Le(),
      v = new D(),
      m = new D();
    function h(A, E, S) {
      c.fromBufferAttribute(i, A),
        u.fromBufferAttribute(i, E),
        f.fromBufferAttribute(i, S),
        d.fromBufferAttribute(s, A),
        p.fromBufferAttribute(s, E),
        g.fromBufferAttribute(s, S),
        u.sub(c),
        f.sub(c),
        p.sub(d),
        g.sub(d);
      const P = 1 / (p.x * g.y - g.x * p.y);
      isFinite(P) &&
        (v
          .copy(u)
          .multiplyScalar(g.y)
          .addScaledVector(f, -p.y)
          .multiplyScalar(P),
        m
          .copy(f)
          .multiplyScalar(p.x)
          .addScaledVector(u, -g.x)
          .multiplyScalar(P),
        a[A].add(v),
        a[E].add(v),
        a[S].add(v),
        l[A].add(m),
        l[E].add(m),
        l[S].add(m));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{ start: 0, count: e.count }]);
    for (let A = 0, E = _.length; A < E; ++A) {
      const S = _[A],
        P = S.start,
        G = S.count;
      for (let F = P, H = P + G; F < H; F += 3)
        h(e.getX(F + 0), e.getX(F + 1), e.getX(F + 2));
    }
    const y = new D(),
      x = new D(),
      C = new D(),
      R = new D();
    function w(A) {
      C.fromBufferAttribute(r, A), R.copy(C);
      const E = a[A];
      y.copy(E),
        y.sub(C.multiplyScalar(C.dot(E))).normalize(),
        x.crossVectors(R, E);
      const P = x.dot(l[A]) < 0 ? -1 : 1;
      o.setXYZW(A, y.x, y.y, y.z, P);
    }
    for (let A = 0, E = _.length; A < E; ++A) {
      const S = _[A],
        P = S.start,
        G = S.count;
      for (let F = P, H = P + G; F < H; F += 3)
        w(e.getX(F + 0)), w(e.getX(F + 1)), w(e.getX(F + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new cn(new Float32Array(n.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let d = 0, p = i.count; d < p; d++) i.setXYZ(d, 0, 0, 0);
      const r = new D(),
        s = new D(),
        o = new D(),
        a = new D(),
        l = new D(),
        c = new D(),
        u = new D(),
        f = new D();
      if (e)
        for (let d = 0, p = e.count; d < p; d += 3) {
          const g = e.getX(d + 0),
            v = e.getX(d + 1),
            m = e.getX(d + 2);
          r.fromBufferAttribute(n, g),
            s.fromBufferAttribute(n, v),
            o.fromBufferAttribute(n, m),
            u.subVectors(o, s),
            f.subVectors(r, s),
            u.cross(f),
            a.fromBufferAttribute(i, g),
            l.fromBufferAttribute(i, v),
            c.fromBufferAttribute(i, m),
            a.add(u),
            l.add(u),
            c.add(u),
            i.setXYZ(g, a.x, a.y, a.z),
            i.setXYZ(v, l.x, l.y, l.z),
            i.setXYZ(m, c.x, c.y, c.z);
        }
      else
        for (let d = 0, p = n.count; d < p; d += 3)
          r.fromBufferAttribute(n, d + 0),
            s.fromBufferAttribute(n, d + 1),
            o.fromBufferAttribute(n, d + 2),
            u.subVectors(o, s),
            f.subVectors(r, s),
            u.cross(f),
            i.setXYZ(d + 0, u.x, u.y, u.z),
            i.setXYZ(d + 1, u.x, u.y, u.z),
            i.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      Ut.fromBufferAttribute(e, n),
        Ut.normalize(),
        e.setXYZ(n, Ut.x, Ut.y, Ut.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        u = a.itemSize,
        f = a.normalized,
        d = new c.constructor(l.length * u);
      let p = 0,
        g = 0;
      for (let v = 0, m = l.length; v < m; v++) {
        a.isInterleavedBufferAttribute
          ? (p = l[v] * a.data.stride + a.offset)
          : (p = l[v] * u);
        for (let h = 0; h < u; h++) d[g++] = c[p++];
      }
      return new cn(d, u, f);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const n = new Si(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const l = r[a],
        c = e(l, i);
      n.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        c = s[a];
      for (let u = 0, f = c.length; u < f; u++) {
        const d = c[u],
          p = e(d, i);
        l.push(p);
      }
      n.morphAttributes[a] = l;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      n.addGroup(c.start, c.count, c.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null &&
      (e.data.index = {
        type: n.array.constructor.name,
        array: Array.prototype.slice.call(n.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let f = 0, d = c.length; f < d; f++) {
        const p = c[f];
        u.push(p.toJSON(e.data));
      }
      u.length > 0 && ((r[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const r = e.attributes;
    for (const c in r) {
      const u = r[c];
      this.setAttribute(c, u.clone(n));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        f = s[c];
      for (let d = 0, p = f.length; d < p; d++) u.push(f[d].clone(n));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, u = o.length; c < u; c++) {
      const f = o[c];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const H_ = new Be(),
  Wr = new nl(),
  Fl = new xi(),
  V_ = new D(),
  kl = new D(),
  Bl = new D(),
  zl = new D(),
  Af = new D(),
  Hl = new D(),
  G_ = new D(),
  Vl = new D();
class An extends Mt {
  constructor(e = new Si(), n = new rs()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    n.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      Hl.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = a[l],
          f = s[l];
        u !== 0 &&
          (Af.fromBufferAttribute(f, e),
          o ? Hl.addScaledVector(Af, u) : Hl.addScaledVector(Af.sub(n), u));
      }
      n.add(Hl);
    }
    return n;
  }
  raycast(e, n) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Fl.copy(i.boundingSphere),
      Fl.applyMatrix4(s),
      Wr.copy(e.ray).recast(e.near),
      !(
        Fl.containsPoint(Wr.origin) === !1 &&
        (Wr.intersectSphere(Fl, V_) === null ||
          Wr.origin.distanceToSquared(V_) > (e.far - e.near) ** 2)
      ) &&
        (H_.copy(s).invert(),
        Wr.copy(e.ray).applyMatrix4(H_),
        !(i.boundingBox !== null && Wr.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, n, Wr)));
  }
  _computeIntersections(e, n, i) {
    let r;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      f = s.attributes.normal,
      d = s.groups,
      p = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let g = 0, v = d.length; g < v; g++) {
          const m = d[g],
            h = o[m.materialIndex],
            _ = Math.max(m.start, p.start),
            y = Math.min(
              a.count,
              Math.min(m.start + m.count, p.start + p.count)
            );
          for (let x = _, C = y; x < C; x += 3) {
            const R = a.getX(x),
              w = a.getX(x + 1),
              A = a.getX(x + 2);
            (r = Gl(this, h, e, i, c, u, f, R, w, A)),
              r &&
                ((r.faceIndex = Math.floor(x / 3)),
                (r.face.materialIndex = m.materialIndex),
                n.push(r));
          }
        }
      else {
        const g = Math.max(0, p.start),
          v = Math.min(a.count, p.start + p.count);
        for (let m = g, h = v; m < h; m += 3) {
          const _ = a.getX(m),
            y = a.getX(m + 1),
            x = a.getX(m + 2);
          (r = Gl(this, o, e, i, c, u, f, _, y, x)),
            r && ((r.faceIndex = Math.floor(m / 3)), n.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let g = 0, v = d.length; g < v; g++) {
          const m = d[g],
            h = o[m.materialIndex],
            _ = Math.max(m.start, p.start),
            y = Math.min(
              l.count,
              Math.min(m.start + m.count, p.start + p.count)
            );
          for (let x = _, C = y; x < C; x += 3) {
            const R = x,
              w = x + 1,
              A = x + 2;
            (r = Gl(this, h, e, i, c, u, f, R, w, A)),
              r &&
                ((r.faceIndex = Math.floor(x / 3)),
                (r.face.materialIndex = m.materialIndex),
                n.push(r));
          }
        }
      else {
        const g = Math.max(0, p.start),
          v = Math.min(l.count, p.start + p.count);
        for (let m = g, h = v; m < h; m += 3) {
          const _ = m,
            y = m + 1,
            x = m + 2;
          (r = Gl(this, o, e, i, c, u, f, _, y, x)),
            r && ((r.faceIndex = Math.floor(m / 3)), n.push(r));
        }
      }
  }
}
function hb(t, e, n, i, r, s, o, a) {
  let l;
  if (
    (e.side === xn
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === Zi, a)),
    l === null)
  )
    return null;
  Vl.copy(a), Vl.applyMatrix4(t.matrixWorld);
  const c = n.ray.origin.distanceTo(Vl);
  return c < n.near || c > n.far
    ? null
    : { distance: c, point: Vl.clone(), object: t };
}
function Gl(t, e, n, i, r, s, o, a, l, c) {
  t.getVertexPosition(a, kl),
    t.getVertexPosition(l, Bl),
    t.getVertexPosition(c, zl);
  const u = hb(t, e, n, i, kl, Bl, zl, G_);
  if (u) {
    const f = new D();
    Jn.getBarycoord(G_, kl, Bl, zl, f),
      r && (u.uv = Jn.getInterpolatedAttribute(r, a, l, c, f, new Le())),
      s && (u.uv1 = Jn.getInterpolatedAttribute(s, a, l, c, f, new Le())),
      o &&
        ((u.normal = Jn.getInterpolatedAttribute(o, a, l, c, f, new D())),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = { a, b: l, c, normal: new D(), materialIndex: 0 };
    Jn.getNormal(kl, Bl, zl, d.normal), (u.face = d), (u.barycoord = f);
  }
  return u;
}
class il extends Si {
  constructor(e = 1, n = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      c = [],
      u = [],
      f = [];
    let d = 0,
      p = 0;
    g("z", "y", "x", -1, -1, i, n, e, o, s, 0),
      g("z", "y", "x", 1, -1, i, n, -e, o, s, 1),
      g("x", "z", "y", 1, 1, e, i, n, r, o, 2),
      g("x", "z", "y", 1, -1, e, i, -n, r, o, 3),
      g("x", "y", "z", 1, -1, e, n, i, r, s, 4),
      g("x", "y", "z", -1, -1, e, n, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new Wi(c, 3)),
      this.setAttribute("normal", new Wi(u, 3)),
      this.setAttribute("uv", new Wi(f, 2));
    function g(v, m, h, _, y, x, C, R, w, A, E) {
      const S = x / w,
        P = C / A,
        G = x / 2,
        F = C / 2,
        H = R / 2,
        X = w + 1,
        V = A + 1;
      let Z = 0,
        L = 0;
      const Y = new D();
      for (let q = 0; q < V; q++) {
        const oe = q * P - F;
        for (let pe = 0; pe < X; pe++) {
          const Ne = pe * S - G;
          (Y[v] = Ne * _),
            (Y[m] = oe * y),
            (Y[h] = H),
            c.push(Y.x, Y.y, Y.z),
            (Y[v] = 0),
            (Y[m] = 0),
            (Y[h] = R > 0 ? 1 : -1),
            u.push(Y.x, Y.y, Y.z),
            f.push(pe / w),
            f.push(1 - q / A),
            (Z += 1);
        }
      }
      for (let q = 0; q < A; q++)
        for (let oe = 0; oe < w; oe++) {
          const pe = d + oe + X * q,
            Ne = d + oe + X * (q + 1),
            j = d + (oe + 1) + X * (q + 1),
            ie = d + (oe + 1) + X * q;
          l.push(pe, Ne, ie), l.push(Ne, j, ie), (L += 6);
        }
      a.addGroup(p, L, E), (p += L), (d += Z);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new il(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Ro(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const i in t[n]) {
      const r = t[n][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[n][i] = null))
          : (e[n][i] = r.clone())
        : Array.isArray(r)
        ? (e[n][i] = r.slice())
        : (e[n][i] = r);
    }
  }
  return e;
}
function rn(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const i = Ro(t[n]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function pb(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) e.push(t[n].clone());
  return e;
}
function fS(t) {
  const e = t.getRenderTarget();
  return e === null
    ? t.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : Xe.workingColorSpace;
}
const mb = { clone: Ro, merge: rn };
var gb = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  _b = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Fr extends _i {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = gb),
      (this.fragmentShader = _b),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Ro(e.uniforms)),
      (this.uniformsGroups = pb(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    (n.glslVersion = this.glslVersion), (n.uniforms = {});
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (n.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (n.uniforms[r] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (n.uniforms[r] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (n.uniforms[r] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (n.uniforms[r] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (n.uniforms[r] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (n.uniforms[r] = { type: "m4", value: o.toArray() })
        : (n.uniforms[r] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines),
      (n.vertexShader = this.vertexShader),
      (n.fragmentShader = this.fragmentShader),
      (n.lights = this.lights),
      (n.clipping = this.clipping);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class dS extends Mt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Be()),
      (this.projectionMatrix = new Be()),
      (this.projectionMatrixInverse = new Be()),
      (this.coordinateSystem = Hi);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const fr = new D(),
  W_ = new Le(),
  j_ = new Le();
class on extends dS {
  constructor(e = 50, n = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = n),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const n = (0.5 * this.getFilmHeight()) / e;
    (this.fov = bo * 2 * Math.atan(n)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Ea * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return bo * 2 * Math.atan(Math.tan(Ea * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, n, i) {
    fr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(fr.x, fr.y).multiplyScalar(-e / fr.z),
      fr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(fr.x, fr.y).multiplyScalar(-e / fr.z);
  }
  getViewSize(e, n) {
    return this.getViewBounds(e, W_, j_), n.subVectors(j_, W_);
  }
  setViewOffset(e, n, i, r, s, o) {
    (this.aspect = e / n),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = (e * Math.tan(Ea * 0.5 * this.fov)) / this.zoom,
      i = 2 * n,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      (s += (o.offsetX * r) / l),
        (n -= (o.offsetY * i) / c),
        (r *= o.width / l),
        (i *= o.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        n,
        n - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.fov = this.fov),
      (n.object.zoom = this.zoom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      (n.object.focus = this.focus),
      (n.object.aspect = this.aspect),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      (n.object.filmGauge = this.filmGauge),
      (n.object.filmOffset = this.filmOffset),
      n
    );
  }
}
const Ns = -90,
  Us = 1;
class vb extends Mt {
  constructor(e, n, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const r = new on(Ns, Us, e, n);
    (r.layers = this.layers), this.add(r);
    const s = new on(Ns, Us, e, n);
    (s.layers = this.layers), this.add(s);
    const o = new on(Ns, Us, e, n);
    (o.layers = this.layers), this.add(o);
    const a = new on(Ns, Us, e, n);
    (a.layers = this.layers), this.add(a);
    const l = new on(Ns, Us, e, n);
    (l.layers = this.layers), this.add(l);
    const c = new on(Ns, Us, e, n);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      n = this.children.concat(),
      [i, r, s, o, a, l] = n;
    for (const c of n) this.remove(c);
    if (e === Hi)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === Qc)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of n) this.add(c), c.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, l, c, u] = this.children,
      f = e.getRenderTarget(),
      d = e.getActiveCubeFace(),
      p = e.getActiveMipmapLevel(),
      g = e.xr.enabled;
    e.xr.enabled = !1;
    const v = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(n, s),
      e.setRenderTarget(i, 1, r),
      e.render(n, o),
      e.setRenderTarget(i, 2, r),
      e.render(n, a),
      e.setRenderTarget(i, 3, r),
      e.render(n, l),
      e.setRenderTarget(i, 4, r),
      e.render(n, c),
      (i.texture.generateMipmaps = v),
      e.setRenderTarget(i, 5, r),
      e.render(n, u),
      e.setRenderTarget(f, d, p),
      (e.xr.enabled = g),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class hS extends zt {
  constructor(e, n, i, r, s, o, a, l, c, u) {
    (e = e !== void 0 ? e : []),
      (n = n !== void 0 ? n : Mo),
      super(e, n, i, r, s, o, a, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class yb extends gs {
  constructor(e = 1, n = {}) {
    super(e, e, n), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    (this.texture = new hS(
      r,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : kt);
  }
  fromEquirectangularTexture(e, n) {
    (this.texture.type = n.type),
      (this.texture.colorSpace = n.colorSpace),
      (this.texture.generateMipmaps = n.generateMipmaps),
      (this.texture.minFilter = n.minFilter),
      (this.texture.magFilter = n.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new il(5, 5, 5),
      s = new Fr({
        name: "CubemapFromEquirect",
        uniforms: Ro(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: xn,
        blending: Pr,
      });
    s.uniforms.tEquirect.value = n;
    const o = new An(r, s),
      a = n.minFilter;
    return (
      n.minFilter === pi && (n.minFilter = kt),
      new vb(1, 10, this).update(e, o),
      (n.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, n, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(n, i, r);
    e.setRenderTarget(s);
  }
}
const bf = new D(),
  xb = new D(),
  Sb = new ke();
class mr {
  constructor(e = new D(1, 0, 0), n = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = n);
  }
  set(e, n) {
    return this.normal.copy(e), (this.constant = n), this;
  }
  setComponents(e, n, i, r) {
    return this.normal.set(e, n, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), (this.constant = -n.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const r = bf.subVectors(i, n).cross(xb.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const i = e.delta(bf),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : n.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (n < 0 && i > 0) || (i < 0 && n > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || Sb.getNormalMatrix(e),
      r = this.coplanarPoint(bf).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const jr = new xi(),
  Wl = new D();
class om {
  constructor(
    e = new mr(),
    n = new mr(),
    i = new mr(),
    r = new mr(),
    s = new mr(),
    o = new mr()
  ) {
    this.planes = [e, n, i, r, s, o];
  }
  set(e, n, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(n),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, n = Hi) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      l = r[3],
      c = r[4],
      u = r[5],
      f = r[6],
      d = r[7],
      p = r[8],
      g = r[9],
      v = r[10],
      m = r[11],
      h = r[12],
      _ = r[13],
      y = r[14],
      x = r[15];
    if (
      (i[0].setComponents(l - s, d - c, m - p, x - h).normalize(),
      i[1].setComponents(l + s, d + c, m + p, x + h).normalize(),
      i[2].setComponents(l + o, d + u, m + g, x + _).normalize(),
      i[3].setComponents(l - o, d - u, m - g, x - _).normalize(),
      i[4].setComponents(l - a, d - f, m - v, x - y).normalize(),
      n === Hi)
    )
      i[5].setComponents(l + a, d + f, m + v, x + y).normalize();
    else if (n === Qc) i[5].setComponents(a, f, v, y).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          n
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        jr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(),
        jr.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(jr);
  }
  intersectsSprite(e) {
    return (
      jr.center.set(0, 0, 0),
      (jr.radius = 0.7071067811865476),
      jr.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(jr)
    );
  }
  intersectsSphere(e) {
    const n = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (n[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = n[i];
      if (
        ((Wl.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (Wl.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (Wl.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(Wl) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) if (n[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function pS() {
  let t = null,
    e = !1,
    n = null,
    i = null;
  function r(s, o) {
    n(s, o), (i = t.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && n !== null && ((i = t.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      n = s;
    },
    setContext: function (s) {
      t = s;
    },
  };
}
function Mb(t) {
  const e = new WeakMap();
  function n(a, l) {
    const c = a.array,
      u = a.usage,
      f = c.byteLength,
      d = t.createBuffer();
    t.bindBuffer(l, d), t.bufferData(l, c, u), a.onUploadCallback();
    let p;
    if (c instanceof Float32Array) p = t.FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (p = t.HALF_FLOAT) : (p = t.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) p = t.SHORT;
    else if (c instanceof Uint32Array) p = t.UNSIGNED_INT;
    else if (c instanceof Int32Array) p = t.INT;
    else if (c instanceof Int8Array) p = t.BYTE;
    else if (c instanceof Uint8Array) p = t.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) p = t.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: d,
      type: p,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: f,
    };
  }
  function i(a, l, c) {
    const u = l.array,
      f = l.updateRanges;
    if ((t.bindBuffer(c, a), f.length === 0)) t.bufferSubData(c, 0, u);
    else {
      f.sort((p, g) => p.start - g.start);
      let d = 0;
      for (let p = 1; p < f.length; p++) {
        const g = f[d],
          v = f[p];
        v.start <= g.start + g.count + 1
          ? (g.count = Math.max(g.count, v.start + v.count - g.start))
          : (++d, (f[d] = v));
      }
      f.length = d + 1;
      for (let p = 0, g = f.length; p < g; p++) {
        const v = f[p];
        t.bufferSubData(c, v.start * u.BYTES_PER_ELEMENT, u, v.start, v.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function r(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (t.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (
      (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)
    ) {
      const u = e.get(a);
      (!u || u.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    const c = e.get(a);
    if (c === void 0) e.set(a, n(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      i(c.buffer, a, l), (c.version = a.version);
    }
  }
  return { get: r, remove: s, update: o };
}
class Tu extends Si {
  constructor(e = 1, n = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      o = n / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      c = a + 1,
      u = l + 1,
      f = e / a,
      d = n / l,
      p = [],
      g = [],
      v = [],
      m = [];
    for (let h = 0; h < u; h++) {
      const _ = h * d - o;
      for (let y = 0; y < c; y++) {
        const x = y * f - s;
        g.push(x, -_, 0), v.push(0, 0, 1), m.push(y / a), m.push(1 - h / l);
      }
    }
    for (let h = 0; h < l; h++)
      for (let _ = 0; _ < a; _++) {
        const y = _ + c * h,
          x = _ + c * (h + 1),
          C = _ + 1 + c * (h + 1),
          R = _ + 1 + c * h;
        p.push(y, x, R), p.push(x, C, R);
      }
    this.setIndex(p),
      this.setAttribute("position", new Wi(g, 3)),
      this.setAttribute("normal", new Wi(v, 3)),
      this.setAttribute("uv", new Wi(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Tu(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var Eb = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  Tb = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  wb = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  Ab = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  bb = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  Rb = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  Cb = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  Pb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  Lb = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  Ib = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  Db = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  Nb = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Ub = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  Ob = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  Fb = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  kb = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  Bb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  zb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Hb = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Vb = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Gb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  Wb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  jb = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  Xb = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  Yb = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Kb = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  qb = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  $b = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  Zb = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Qb = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  Jb = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  eR = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  tR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  nR = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  iR = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  rR = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  sR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  oR = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  aR = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  lR = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  cR = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  uR = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  fR = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  dR = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  hR = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  pR = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  mR = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  gR = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  _R = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  vR = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  yR = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  xR = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  SR = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  MR = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  ER = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  TR = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  wR = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  AR = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  bR = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  RR = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  CR = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  PR = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  LR = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  IR = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  DR = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  NR = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  UR = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  OR = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  FR = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  kR = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  BR = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  zR = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  HR = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  VR = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  GR = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  WR = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  jR = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  XR = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  YR = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  KR = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  qR = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  $R = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  ZR = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  QR = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  JR = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  eC = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  tC = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  nC = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  iC = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  rC = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  sC = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  oC = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  aC = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  lC = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  cC = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  uC = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  fC = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  dC = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  hC = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  pC = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  mC = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  gC = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  _C = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  vC = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  yC = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  xC = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  SC = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const MC = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  EC = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  TC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  wC = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  AC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  bC = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  RC = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  CC = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  PC = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  LC = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  IC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  DC = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  NC = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  UC = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  OC = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  FC = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  kC = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  BC = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  zC = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  HC = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  VC = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  GC = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  WC = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  jC = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  XC = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  YC = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  KC = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  qC = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  $C = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  ZC = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  QC = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  JC = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  e2 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  t2 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  He = {
    alphahash_fragment: Eb,
    alphahash_pars_fragment: Tb,
    alphamap_fragment: wb,
    alphamap_pars_fragment: Ab,
    alphatest_fragment: bb,
    alphatest_pars_fragment: Rb,
    aomap_fragment: Cb,
    aomap_pars_fragment: Pb,
    batching_pars_vertex: Lb,
    batching_vertex: Ib,
    begin_vertex: Db,
    beginnormal_vertex: Nb,
    bsdfs: Ub,
    iridescence_fragment: Ob,
    bumpmap_pars_fragment: Fb,
    clipping_planes_fragment: kb,
    clipping_planes_pars_fragment: Bb,
    clipping_planes_pars_vertex: zb,
    clipping_planes_vertex: Hb,
    color_fragment: Vb,
    color_pars_fragment: Gb,
    color_pars_vertex: Wb,
    color_vertex: jb,
    common: Xb,
    cube_uv_reflection_fragment: Yb,
    defaultnormal_vertex: Kb,
    displacementmap_pars_vertex: qb,
    displacementmap_vertex: $b,
    emissivemap_fragment: Zb,
    emissivemap_pars_fragment: Qb,
    colorspace_fragment: Jb,
    colorspace_pars_fragment: eR,
    envmap_fragment: tR,
    envmap_common_pars_fragment: nR,
    envmap_pars_fragment: iR,
    envmap_pars_vertex: rR,
    envmap_physical_pars_fragment: mR,
    envmap_vertex: sR,
    fog_vertex: oR,
    fog_pars_vertex: aR,
    fog_fragment: lR,
    fog_pars_fragment: cR,
    gradientmap_pars_fragment: uR,
    lightmap_pars_fragment: fR,
    lights_lambert_fragment: dR,
    lights_lambert_pars_fragment: hR,
    lights_pars_begin: pR,
    lights_toon_fragment: gR,
    lights_toon_pars_fragment: _R,
    lights_phong_fragment: vR,
    lights_phong_pars_fragment: yR,
    lights_physical_fragment: xR,
    lights_physical_pars_fragment: SR,
    lights_fragment_begin: MR,
    lights_fragment_maps: ER,
    lights_fragment_end: TR,
    logdepthbuf_fragment: wR,
    logdepthbuf_pars_fragment: AR,
    logdepthbuf_pars_vertex: bR,
    logdepthbuf_vertex: RR,
    map_fragment: CR,
    map_pars_fragment: PR,
    map_particle_fragment: LR,
    map_particle_pars_fragment: IR,
    metalnessmap_fragment: DR,
    metalnessmap_pars_fragment: NR,
    morphinstance_vertex: UR,
    morphcolor_vertex: OR,
    morphnormal_vertex: FR,
    morphtarget_pars_vertex: kR,
    morphtarget_vertex: BR,
    normal_fragment_begin: zR,
    normal_fragment_maps: HR,
    normal_pars_fragment: VR,
    normal_pars_vertex: GR,
    normal_vertex: WR,
    normalmap_pars_fragment: jR,
    clearcoat_normal_fragment_begin: XR,
    clearcoat_normal_fragment_maps: YR,
    clearcoat_pars_fragment: KR,
    iridescence_pars_fragment: qR,
    opaque_fragment: $R,
    packing: ZR,
    premultiplied_alpha_fragment: QR,
    project_vertex: JR,
    dithering_fragment: eC,
    dithering_pars_fragment: tC,
    roughnessmap_fragment: nC,
    roughnessmap_pars_fragment: iC,
    shadowmap_pars_fragment: rC,
    shadowmap_pars_vertex: sC,
    shadowmap_vertex: oC,
    shadowmask_pars_fragment: aC,
    skinbase_vertex: lC,
    skinning_pars_vertex: cC,
    skinning_vertex: uC,
    skinnormal_vertex: fC,
    specularmap_fragment: dC,
    specularmap_pars_fragment: hC,
    tonemapping_fragment: pC,
    tonemapping_pars_fragment: mC,
    transmission_fragment: gC,
    transmission_pars_fragment: _C,
    uv_pars_fragment: vC,
    uv_pars_vertex: yC,
    uv_vertex: xC,
    worldpos_vertex: SC,
    background_vert: MC,
    background_frag: EC,
    backgroundCube_vert: TC,
    backgroundCube_frag: wC,
    cube_vert: AC,
    cube_frag: bC,
    depth_vert: RC,
    depth_frag: CC,
    distanceRGBA_vert: PC,
    distanceRGBA_frag: LC,
    equirect_vert: IC,
    equirect_frag: DC,
    linedashed_vert: NC,
    linedashed_frag: UC,
    meshbasic_vert: OC,
    meshbasic_frag: FC,
    meshlambert_vert: kC,
    meshlambert_frag: BC,
    meshmatcap_vert: zC,
    meshmatcap_frag: HC,
    meshnormal_vert: VC,
    meshnormal_frag: GC,
    meshphong_vert: WC,
    meshphong_frag: jC,
    meshphysical_vert: XC,
    meshphysical_frag: YC,
    meshtoon_vert: KC,
    meshtoon_frag: qC,
    points_vert: $C,
    points_frag: ZC,
    shadow_vert: QC,
    shadow_frag: JC,
    sprite_vert: e2,
    sprite_frag: t2,
  },
  le = {
    common: {
      diffuse: { value: new De(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new ke() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new ke() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new ke() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new ke() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new ke() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new ke() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new ke() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new ke() },
      normalScale: { value: new Le(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new ke() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new ke() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new ke() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new ke() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new De(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new De(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new ke() },
      alphaTest: { value: 0 },
      uvTransform: { value: new ke() },
    },
    sprite: {
      diffuse: { value: new De(16777215) },
      opacity: { value: 1 },
      center: { value: new Le(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new ke() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new ke() },
      alphaTest: { value: 0 },
    },
  },
  li = {
    basic: {
      uniforms: rn([
        le.common,
        le.specularmap,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.fog,
      ]),
      vertexShader: He.meshbasic_vert,
      fragmentShader: He.meshbasic_frag,
    },
    lambert: {
      uniforms: rn([
        le.common,
        le.specularmap,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.fog,
        le.lights,
        { emissive: { value: new De(0) } },
      ]),
      vertexShader: He.meshlambert_vert,
      fragmentShader: He.meshlambert_frag,
    },
    phong: {
      uniforms: rn([
        le.common,
        le.specularmap,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.fog,
        le.lights,
        {
          emissive: { value: new De(0) },
          specular: { value: new De(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: He.meshphong_vert,
      fragmentShader: He.meshphong_frag,
    },
    standard: {
      uniforms: rn([
        le.common,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.roughnessmap,
        le.metalnessmap,
        le.fog,
        le.lights,
        {
          emissive: { value: new De(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: He.meshphysical_vert,
      fragmentShader: He.meshphysical_frag,
    },
    toon: {
      uniforms: rn([
        le.common,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.gradientmap,
        le.fog,
        le.lights,
        { emissive: { value: new De(0) } },
      ]),
      vertexShader: He.meshtoon_vert,
      fragmentShader: He.meshtoon_frag,
    },
    matcap: {
      uniforms: rn([
        le.common,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: He.meshmatcap_vert,
      fragmentShader: He.meshmatcap_frag,
    },
    points: {
      uniforms: rn([le.points, le.fog]),
      vertexShader: He.points_vert,
      fragmentShader: He.points_frag,
    },
    dashed: {
      uniforms: rn([
        le.common,
        le.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: He.linedashed_vert,
      fragmentShader: He.linedashed_frag,
    },
    depth: {
      uniforms: rn([le.common, le.displacementmap]),
      vertexShader: He.depth_vert,
      fragmentShader: He.depth_frag,
    },
    normal: {
      uniforms: rn([
        le.common,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: He.meshnormal_vert,
      fragmentShader: He.meshnormal_frag,
    },
    sprite: {
      uniforms: rn([le.sprite, le.fog]),
      vertexShader: He.sprite_vert,
      fragmentShader: He.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new ke() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: He.background_vert,
      fragmentShader: He.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new ke() },
      },
      vertexShader: He.backgroundCube_vert,
      fragmentShader: He.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: He.cube_vert,
      fragmentShader: He.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: He.equirect_vert,
      fragmentShader: He.equirect_frag,
    },
    distanceRGBA: {
      uniforms: rn([
        le.common,
        le.displacementmap,
        {
          referencePosition: { value: new D() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: He.distanceRGBA_vert,
      fragmentShader: He.distanceRGBA_frag,
    },
    shadow: {
      uniforms: rn([
        le.lights,
        le.fog,
        { color: { value: new De(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: He.shadow_vert,
      fragmentShader: He.shadow_frag,
    },
  };
li.physical = {
  uniforms: rn([
    li.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new ke() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new ke() },
      clearcoatNormalScale: { value: new Le(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new ke() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new ke() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new ke() },
      sheen: { value: 0 },
      sheenColor: { value: new De(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new ke() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new ke() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new ke() },
      transmissionSamplerSize: { value: new Le() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new ke() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new De(0) },
      specularColor: { value: new De(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new ke() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new ke() },
      anisotropyVector: { value: new Le() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new ke() },
    },
  ]),
  vertexShader: He.meshphysical_vert,
  fragmentShader: He.meshphysical_frag,
};
const jl = { r: 0, b: 0, g: 0 },
  Xr = new yi(),
  n2 = new Be();
function i2(t, e, n, i, r, s, o) {
  const a = new De(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    f = null,
    d = 0,
    p = null;
  function g(_) {
    let y = _.isScene === !0 ? _.background : null;
    return (
      y && y.isTexture && (y = (_.backgroundBlurriness > 0 ? n : e).get(y)), y
    );
  }
  function v(_) {
    let y = !1;
    const x = g(_);
    x === null ? h(a, l) : x && x.isColor && (h(x, 1), (y = !0));
    const C = t.xr.getEnvironmentBlendMode();
    C === "additive"
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : C === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
      (t.autoClear || y) &&
        (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil));
  }
  function m(_, y) {
    const x = g(y);
    x && (x.isCubeTexture || x.mapping === Mu)
      ? (u === void 0 &&
          ((u = new An(
            new il(1, 1, 1),
            new Fr({
              name: "BackgroundCubeMaterial",
              uniforms: Ro(li.backgroundCube.uniforms),
              vertexShader: li.backgroundCube.vertexShader,
              fragmentShader: li.backgroundCube.fragmentShader,
              side: xn,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          u.geometry.deleteAttribute("normal"),
          u.geometry.deleteAttribute("uv"),
          (u.onBeforeRender = function (C, R, w) {
            this.matrixWorld.copyPosition(w.matrixWorld);
          }),
          Object.defineProperty(u.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          r.update(u)),
        Xr.copy(y.backgroundRotation),
        (Xr.x *= -1),
        (Xr.y *= -1),
        (Xr.z *= -1),
        x.isCubeTexture &&
          x.isRenderTargetTexture === !1 &&
          ((Xr.y *= -1), (Xr.z *= -1)),
        (u.material.uniforms.envMap.value = x),
        (u.material.uniforms.flipEnvMap.value =
          x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value =
          y.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = y.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(
          n2.makeRotationFromEuler(Xr)
        ),
        (u.material.toneMapped = Xe.getTransfer(x.colorSpace) !== at),
        (f !== x || d !== x.version || p !== t.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (f = x),
          (d = x.version),
          (p = t.toneMapping)),
        u.layers.enableAll(),
        _.unshift(u, u.geometry, u.material, 0, 0, null))
      : x &&
        x.isTexture &&
        (c === void 0 &&
          ((c = new An(
            new Tu(2, 2),
            new Fr({
              name: "BackgroundMaterial",
              uniforms: Ro(li.background.uniforms),
              vertexShader: li.background.vertexShader,
              fragmentShader: li.background.fragmentShader,
              side: Zi,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          r.update(c)),
        (c.material.uniforms.t2D.value = x),
        (c.material.uniforms.backgroundIntensity.value = y.backgroundIntensity),
        (c.material.toneMapped = Xe.getTransfer(x.colorSpace) !== at),
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(x.matrix),
        (f !== x || d !== x.version || p !== t.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (f = x),
          (d = x.version),
          (p = t.toneMapping)),
        c.layers.enableAll(),
        _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function h(_, y) {
    _.getRGB(jl, fS(t)), i.buffers.color.setClear(jl.r, jl.g, jl.b, y, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (_, y = 1) {
      a.set(_), (l = y), h(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (_) {
      (l = _), h(a, l);
    },
    render: v,
    addToRenderList: m,
  };
}
function r2(t, e) {
  const n = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    i = {},
    r = d(null);
  let s = r,
    o = !1;
  function a(S, P, G, F, H) {
    let X = !1;
    const V = f(F, G, P);
    s !== V && ((s = V), c(s.object)),
      (X = p(S, F, G, H)),
      X && g(S, F, G, H),
      H !== null && e.update(H, t.ELEMENT_ARRAY_BUFFER),
      (X || o) &&
        ((o = !1),
        x(S, P, G, F),
        H !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(H).buffer));
  }
  function l() {
    return t.createVertexArray();
  }
  function c(S) {
    return t.bindVertexArray(S);
  }
  function u(S) {
    return t.deleteVertexArray(S);
  }
  function f(S, P, G) {
    const F = G.wireframe === !0;
    let H = i[S.id];
    H === void 0 && ((H = {}), (i[S.id] = H));
    let X = H[P.id];
    X === void 0 && ((X = {}), (H[P.id] = X));
    let V = X[F];
    return V === void 0 && ((V = d(l())), (X[F] = V)), V;
  }
  function d(S) {
    const P = [],
      G = [],
      F = [];
    for (let H = 0; H < n; H++) (P[H] = 0), (G[H] = 0), (F[H] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: P,
      enabledAttributes: G,
      attributeDivisors: F,
      object: S,
      attributes: {},
      index: null,
    };
  }
  function p(S, P, G, F) {
    const H = s.attributes,
      X = P.attributes;
    let V = 0;
    const Z = G.getAttributes();
    for (const L in Z)
      if (Z[L].location >= 0) {
        const q = H[L];
        let oe = X[L];
        if (
          (oe === void 0 &&
            (L === "instanceMatrix" &&
              S.instanceMatrix &&
              (oe = S.instanceMatrix),
            L === "instanceColor" && S.instanceColor && (oe = S.instanceColor)),
          q === void 0 || q.attribute !== oe || (oe && q.data !== oe.data))
        )
          return !0;
        V++;
      }
    return s.attributesNum !== V || s.index !== F;
  }
  function g(S, P, G, F) {
    const H = {},
      X = P.attributes;
    let V = 0;
    const Z = G.getAttributes();
    for (const L in Z)
      if (Z[L].location >= 0) {
        let q = X[L];
        q === void 0 &&
          (L === "instanceMatrix" && S.instanceMatrix && (q = S.instanceMatrix),
          L === "instanceColor" && S.instanceColor && (q = S.instanceColor));
        const oe = {};
        (oe.attribute = q), q && q.data && (oe.data = q.data), (H[L] = oe), V++;
      }
    (s.attributes = H), (s.attributesNum = V), (s.index = F);
  }
  function v() {
    const S = s.newAttributes;
    for (let P = 0, G = S.length; P < G; P++) S[P] = 0;
  }
  function m(S) {
    h(S, 0);
  }
  function h(S, P) {
    const G = s.newAttributes,
      F = s.enabledAttributes,
      H = s.attributeDivisors;
    (G[S] = 1),
      F[S] === 0 && (t.enableVertexAttribArray(S), (F[S] = 1)),
      H[S] !== P && (t.vertexAttribDivisor(S, P), (H[S] = P));
  }
  function _() {
    const S = s.newAttributes,
      P = s.enabledAttributes;
    for (let G = 0, F = P.length; G < F; G++)
      P[G] !== S[G] && (t.disableVertexAttribArray(G), (P[G] = 0));
  }
  function y(S, P, G, F, H, X, V) {
    V === !0
      ? t.vertexAttribIPointer(S, P, G, H, X)
      : t.vertexAttribPointer(S, P, G, F, H, X);
  }
  function x(S, P, G, F) {
    v();
    const H = F.attributes,
      X = G.getAttributes(),
      V = P.defaultAttributeValues;
    for (const Z in X) {
      const L = X[Z];
      if (L.location >= 0) {
        let Y = H[Z];
        if (
          (Y === void 0 &&
            (Z === "instanceMatrix" &&
              S.instanceMatrix &&
              (Y = S.instanceMatrix),
            Z === "instanceColor" && S.instanceColor && (Y = S.instanceColor)),
          Y !== void 0)
        ) {
          const q = Y.normalized,
            oe = Y.itemSize,
            pe = e.get(Y);
          if (pe === void 0) continue;
          const Ne = pe.buffer,
            j = pe.type,
            ie = pe.bytesPerElement,
            ge = j === t.INT || j === t.UNSIGNED_INT || Y.gpuType === Qp;
          if (Y.isInterleavedBufferAttribute) {
            const ae = Y.data,
              Ce = ae.stride,
              Ue = Y.offset;
            if (ae.isInstancedInterleavedBuffer) {
              for (let Ve = 0; Ve < L.locationSize; Ve++)
                h(L.location + Ve, ae.meshPerAttribute);
              S.isInstancedMesh !== !0 &&
                F._maxInstanceCount === void 0 &&
                (F._maxInstanceCount = ae.meshPerAttribute * ae.count);
            } else
              for (let Ve = 0; Ve < L.locationSize; Ve++) m(L.location + Ve);
            t.bindBuffer(t.ARRAY_BUFFER, Ne);
            for (let Ve = 0; Ve < L.locationSize; Ve++)
              y(
                L.location + Ve,
                oe / L.locationSize,
                j,
                q,
                Ce * ie,
                (Ue + (oe / L.locationSize) * Ve) * ie,
                ge
              );
          } else {
            if (Y.isInstancedBufferAttribute) {
              for (let ae = 0; ae < L.locationSize; ae++)
                h(L.location + ae, Y.meshPerAttribute);
              S.isInstancedMesh !== !0 &&
                F._maxInstanceCount === void 0 &&
                (F._maxInstanceCount = Y.meshPerAttribute * Y.count);
            } else
              for (let ae = 0; ae < L.locationSize; ae++) m(L.location + ae);
            t.bindBuffer(t.ARRAY_BUFFER, Ne);
            for (let ae = 0; ae < L.locationSize; ae++)
              y(
                L.location + ae,
                oe / L.locationSize,
                j,
                q,
                oe * ie,
                (oe / L.locationSize) * ae * ie,
                ge
              );
          }
        } else if (V !== void 0) {
          const q = V[Z];
          if (q !== void 0)
            switch (q.length) {
              case 2:
                t.vertexAttrib2fv(L.location, q);
                break;
              case 3:
                t.vertexAttrib3fv(L.location, q);
                break;
              case 4:
                t.vertexAttrib4fv(L.location, q);
                break;
              default:
                t.vertexAttrib1fv(L.location, q);
            }
        }
      }
    }
    _();
  }
  function C() {
    A();
    for (const S in i) {
      const P = i[S];
      for (const G in P) {
        const F = P[G];
        for (const H in F) u(F[H].object), delete F[H];
        delete P[G];
      }
      delete i[S];
    }
  }
  function R(S) {
    if (i[S.id] === void 0) return;
    const P = i[S.id];
    for (const G in P) {
      const F = P[G];
      for (const H in F) u(F[H].object), delete F[H];
      delete P[G];
    }
    delete i[S.id];
  }
  function w(S) {
    for (const P in i) {
      const G = i[P];
      if (G[S.id] === void 0) continue;
      const F = G[S.id];
      for (const H in F) u(F[H].object), delete F[H];
      delete G[S.id];
    }
  }
  function A() {
    E(), (o = !0), s !== r && ((s = r), c(s.object));
  }
  function E() {
    (r.geometry = null), (r.program = null), (r.wireframe = !1);
  }
  return {
    setup: a,
    reset: A,
    resetDefaultState: E,
    dispose: C,
    releaseStatesOfGeometry: R,
    releaseStatesOfProgram: w,
    initAttributes: v,
    enableAttribute: m,
    disableUnusedAttributes: _,
  };
}
function s2(t, e, n) {
  let i;
  function r(c) {
    i = c;
  }
  function s(c, u) {
    t.drawArrays(i, c, u), n.update(u, i, 1);
  }
  function o(c, u, f) {
    f !== 0 && (t.drawArraysInstanced(i, c, u, f), n.update(u, i, f));
  }
  function a(c, u, f) {
    if (f === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, f);
    let p = 0;
    for (let g = 0; g < f; g++) p += u[g];
    n.update(p, i, 1);
  }
  function l(c, u, f, d) {
    if (f === 0) return;
    const p = e.get("WEBGL_multi_draw");
    if (p === null) for (let g = 0; g < c.length; g++) o(c[g], u[g], d[g]);
    else {
      p.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, d, 0, f);
      let g = 0;
      for (let v = 0; v < f; v++) g += u[v] * d[v];
      n.update(g, i, 1);
    }
  }
  (this.setMode = r),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l);
}
function o2(t, e, n, i) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const w = e.get("EXT_texture_filter_anisotropic");
      r = t.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function o(w) {
    return !(
      w !== Bn &&
      i.convert(w) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(w) {
    const A =
      w === zi &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      w !== Qi &&
      i.convert(w) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) &&
      w !== gn &&
      !A
    );
  }
  function l(w) {
    if (w === "highp") {
      if (
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      w = "mediump";
    }
    return w === "mediump" &&
      t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
        0 &&
      t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = n.precision !== void 0 ? n.precision : "highp";
  const u = l(c);
  u !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      u,
      "instead."
    ),
    (c = u));
  const f = n.logarithmicDepthBuffer === !0,
    d = n.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    p = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    g = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    v = t.getParameter(t.MAX_TEXTURE_SIZE),
    m = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    h = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    _ = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    y = t.getParameter(t.MAX_VARYING_VECTORS),
    x = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    C = g > 0,
    R = t.getParameter(t.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: f,
    reverseDepthBuffer: d,
    maxTextures: p,
    maxVertexTextures: g,
    maxTextureSize: v,
    maxCubemapSize: m,
    maxAttributes: h,
    maxVertexUniforms: _,
    maxVaryings: y,
    maxFragmentUniforms: x,
    vertexTextures: C,
    maxSamples: R,
  };
}
function a2(t) {
  const e = this;
  let n = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new mr(),
    a = new ke(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (f, d) {
      const p = f.length !== 0 || d || i !== 0 || r;
      return (r = d), (i = f.length), p;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (f, d) {
      n = u(f, d, 0);
    }),
    (this.setState = function (f, d, p) {
      const g = f.clippingPlanes,
        v = f.clipIntersection,
        m = f.clipShadows,
        h = t.get(f);
      if (!r || g === null || g.length === 0 || (s && !m)) s ? u(null) : c();
      else {
        const _ = s ? 0 : i,
          y = _ * 4;
        let x = h.clippingState || null;
        (l.value = x), (x = u(g, d, y, p));
        for (let C = 0; C !== y; ++C) x[C] = n[C];
        (h.clippingState = x),
          (this.numIntersection = v ? this.numPlanes : 0),
          (this.numPlanes += _);
      }
    });
  function c() {
    l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function u(f, d, p, g) {
    const v = f !== null ? f.length : 0;
    let m = null;
    if (v !== 0) {
      if (((m = l.value), g !== !0 || m === null)) {
        const h = p + v * 4,
          _ = d.matrixWorldInverse;
        a.getNormalMatrix(_),
          (m === null || m.length < h) && (m = new Float32Array(h));
        for (let y = 0, x = p; y !== v; ++y, x += 4)
          o.copy(f[y]).applyMatrix4(_, a),
            o.normal.toArray(m, x),
            (m[x + 3] = o.constant);
      }
      (l.value = m), (l.needsUpdate = !0);
    }
    return (e.numPlanes = v), (e.numIntersection = 0), m;
  }
}
function l2(t) {
  let e = new WeakMap();
  function n(o, a) {
    return a === $c ? (o.mapping = Mo) : a === fh && (o.mapping = Eo), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === $c || a === fh)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return n(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new yb(l.height);
            return (
              c.fromEquirectangularTexture(t, o),
              e.set(o, c),
              o.addEventListener("dispose", r),
              n(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class am extends dS {
  constructor(e = -1, n = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = n),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, n, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      n = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + n,
      l = r - n;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= u * this.view.offsetY),
        (l = a - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.zoom = this.zoom),
      (n.object.left = this.left),
      (n.object.right = this.right),
      (n.object.top = this.top),
      (n.object.bottom = this.bottom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      n
    );
  }
}
const Js = 4,
  X_ = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Jr = 20,
  Rf = new am(),
  Y_ = new De();
let Cf = null,
  Pf = 0,
  Lf = 0,
  If = !1;
const Zr = (1 + Math.sqrt(5)) / 2,
  Os = 1 / Zr,
  K_ = [
    new D(-Zr, Os, 0),
    new D(Zr, Os, 0),
    new D(-Os, 0, Zr),
    new D(Os, 0, Zr),
    new D(0, Zr, -Os),
    new D(0, Zr, Os),
    new D(-1, 1, -1),
    new D(1, 1, -1),
    new D(-1, 1, 1),
    new D(1, 1, 1),
  ];
class q_ {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, n = 0, i = 0.1, r = 100) {
    (Cf = this._renderer.getRenderTarget()),
      (Pf = this._renderer.getActiveCubeFace()),
      (Lf = this._renderer.getActiveMipmapLevel()),
      (If = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      n > 0 && this._blur(s, 0, 0, n),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Q_()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Z_()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Cf, Pf, Lf),
      (this._renderer.xr.enabled = If),
      (e.scissorTest = !1),
      Xl(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === Mo || e.mapping === Eo
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (Cf = this._renderer.getRenderTarget()),
      (Pf = this._renderer.getActiveCubeFace()),
      (Lf = this._renderer.getActiveMipmapLevel()),
      (If = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const i = n || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      n = 4 * this._cubeSize,
      i = {
        magFilter: kt,
        minFilter: kt,
        generateMipmaps: !1,
        type: zi,
        format: Bn,
        colorSpace: tn,
        depthBuffer: !1,
      },
      r = $_(e, n, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== n
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = $_(e, n, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = c2(s)),
        (this._blurMaterial = u2(s, e, n));
    }
    return r;
  }
  _compileMaterial(e) {
    const n = new An(this._lodPlanes[0], e);
    this._renderer.compile(n, Rf);
  }
  _sceneToCubeUV(e, n, i, r) {
    const a = new on(90, 1, n, i),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      f = u.autoClear,
      d = u.toneMapping;
    u.getClearColor(Y_), (u.toneMapping = Lr), (u.autoClear = !1);
    const p = new rs({
        name: "PMREM.Background",
        side: xn,
        depthWrite: !1,
        depthTest: !1,
      }),
      g = new An(new il(), p);
    let v = !1;
    const m = e.background;
    m
      ? m.isColor && (p.color.copy(m), (e.background = null), (v = !0))
      : (p.color.copy(Y_), (v = !0));
    for (let h = 0; h < 6; h++) {
      const _ = h % 3;
      _ === 0
        ? (a.up.set(0, l[h], 0), a.lookAt(c[h], 0, 0))
        : _ === 1
        ? (a.up.set(0, 0, l[h]), a.lookAt(0, c[h], 0))
        : (a.up.set(0, l[h], 0), a.lookAt(0, 0, c[h]));
      const y = this._cubeSize;
      Xl(r, _ * y, h > 2 ? y : 0, y, y),
        u.setRenderTarget(r),
        v && u.render(g, a),
        u.render(e, a);
    }
    g.geometry.dispose(),
      g.material.dispose(),
      (u.toneMapping = d),
      (u.autoClear = f),
      (e.background = m);
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer,
      r = e.mapping === Mo || e.mapping === Eo;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Q_()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Z_());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new An(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Xl(n, 0, 0, 3 * l, 2 * l), i.setRenderTarget(n), i.render(o, Rf);
  }
  _applyPMREM(e) {
    const n = this._renderer,
      i = n.autoClear;
    n.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let s = 1; s < r; s++) {
      const o = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1]
        ),
        a = K_[(r - s - 1) % K_.length];
      this._blur(e, s - 1, s, o, a);
    }
    n.autoClear = i;
  }
  _blur(e, n, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, n, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, n, i, r, s, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      f = new An(this._lodPlanes[r], c),
      d = c.uniforms,
      p = this._sizeLods[i] - 1,
      g = isFinite(s) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * Jr - 1),
      v = s / g,
      m = isFinite(s) ? 1 + Math.floor(u * v) : Jr;
    m > Jr &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Jr}`
      );
    const h = [];
    let _ = 0;
    for (let w = 0; w < Jr; ++w) {
      const A = w / v,
        E = Math.exp((-A * A) / 2);
      h.push(E), w === 0 ? (_ += E) : w < m && (_ += 2 * E);
    }
    for (let w = 0; w < h.length; w++) h[w] = h[w] / _;
    (d.envMap.value = e.texture),
      (d.samples.value = m),
      (d.weights.value = h),
      (d.latitudinal.value = o === "latitudinal"),
      a && (d.poleAxis.value = a);
    const { _lodMax: y } = this;
    (d.dTheta.value = g), (d.mipInt.value = y - i);
    const x = this._sizeLods[r],
      C = 3 * x * (r > y - Js ? r - y + Js : 0),
      R = 4 * (this._cubeSize - x);
    Xl(n, C, R, 3 * x, 2 * x), l.setRenderTarget(n), l.render(f, Rf);
  }
}
function c2(t) {
  const e = [],
    n = [],
    i = [];
  let r = t;
  const s = t - Js + 1 + X_.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    n.push(a);
    let l = 1 / a;
    o > t - Js ? (l = X_[o - t + Js - 1]) : o === 0 && (l = 0), i.push(l);
    const c = 1 / (a - 2),
      u = -c,
      f = 1 + c,
      d = [u, u, f, u, f, f, u, u, f, f, u, f],
      p = 6,
      g = 6,
      v = 3,
      m = 2,
      h = 1,
      _ = new Float32Array(v * g * p),
      y = new Float32Array(m * g * p),
      x = new Float32Array(h * g * p);
    for (let R = 0; R < p; R++) {
      const w = ((R % 3) * 2) / 3 - 1,
        A = R > 2 ? 0 : -1,
        E = [
          w,
          A,
          0,
          w + 2 / 3,
          A,
          0,
          w + 2 / 3,
          A + 1,
          0,
          w,
          A,
          0,
          w + 2 / 3,
          A + 1,
          0,
          w,
          A + 1,
          0,
        ];
      _.set(E, v * g * R), y.set(d, m * g * R);
      const S = [R, R, R, R, R, R];
      x.set(S, h * g * R);
    }
    const C = new Si();
    C.setAttribute("position", new cn(_, v)),
      C.setAttribute("uv", new cn(y, m)),
      C.setAttribute("faceIndex", new cn(x, h)),
      e.push(C),
      r > Js && r--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i };
}
function $_(t, e, n) {
  const i = new gs(t, e, n);
  return (
    (i.texture.mapping = Mu),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function Xl(t, e, n, i, r) {
  t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
}
function u2(t, e, n) {
  const i = new Float32Array(Jr),
    r = new D(0, 1, 0);
  return new Fr({
    name: "SphericalGaussianBlur",
    defines: {
      n: Jr,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${t}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: lm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Pr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Z_() {
  return new Fr({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: lm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Pr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Q_() {
  return new Fr({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: lm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Pr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function lm() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function f2(t) {
  let e = new WeakMap(),
    n = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === $c || l === fh,
        u = l === Mo || l === Eo;
      if (c || u) {
        let f = e.get(a);
        const d = f !== void 0 ? f.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== d)
          return (
            n === null && (n = new q_(t)),
            (f = c ? n.fromEquirectangular(a, f) : n.fromCubemap(a, f)),
            (f.texture.pmremVersion = a.pmremVersion),
            e.set(a, f),
            f.texture
          );
        if (f !== void 0) return f.texture;
        {
          const p = a.image;
          return (c && p && p.height > 0) || (u && p && r(p))
            ? (n === null && (n = new q_(t)),
              (f = c ? n.fromEquirectangular(a) : n.fromCubemap(a)),
              (f.texture.pmremVersion = a.pmremVersion),
              e.set(a, f),
              a.addEventListener("dispose", s),
              f.texture)
            : null;
        }
      }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    (e = new WeakMap()), n !== null && (n.dispose(), (n = null));
  }
  return { get: i, dispose: o };
}
function d2(t) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          t.getExtension("WEBGL_depth_texture") ||
          t.getExtension("MOZ_WEBGL_depth_texture") ||
          t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          t.getExtension("EXT_texture_filter_anisotropic") ||
          t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          t.getExtension("WEBGL_compressed_texture_s3tc") ||
          t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          t.getExtension("WEBGL_compressed_texture_pvrtc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = t.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return n(i) !== null;
    },
    init: function () {
      n("EXT_color_buffer_float"),
        n("WEBGL_clip_cull_distance"),
        n("OES_texture_float_linear"),
        n("EXT_color_buffer_half_float"),
        n("WEBGL_multisampled_render_to_texture"),
        n("WEBGL_render_shared_exponent");
    },
    get: function (i) {
      const r = n(i);
      return (
        r === null &&
          ua("THREE.WebGLRenderer: " + i + " extension not supported."),
        r
      );
    },
  };
}
function h2(t, e, n, i) {
  const r = {},
    s = new WeakMap();
  function o(f) {
    const d = f.target;
    d.index !== null && e.remove(d.index);
    for (const g in d.attributes) e.remove(d.attributes[g]);
    for (const g in d.morphAttributes) {
      const v = d.morphAttributes[g];
      for (let m = 0, h = v.length; m < h; m++) e.remove(v[m]);
    }
    d.removeEventListener("dispose", o), delete r[d.id];
    const p = s.get(d);
    p && (e.remove(p), s.delete(d)),
      i.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      n.memory.geometries--;
  }
  function a(f, d) {
    return (
      r[d.id] === !0 ||
        (d.addEventListener("dispose", o),
        (r[d.id] = !0),
        n.memory.geometries++),
      d
    );
  }
  function l(f) {
    const d = f.attributes;
    for (const g in d) e.update(d[g], t.ARRAY_BUFFER);
    const p = f.morphAttributes;
    for (const g in p) {
      const v = p[g];
      for (let m = 0, h = v.length; m < h; m++) e.update(v[m], t.ARRAY_BUFFER);
    }
  }
  function c(f) {
    const d = [],
      p = f.index,
      g = f.attributes.position;
    let v = 0;
    if (p !== null) {
      const _ = p.array;
      v = p.version;
      for (let y = 0, x = _.length; y < x; y += 3) {
        const C = _[y + 0],
          R = _[y + 1],
          w = _[y + 2];
        d.push(C, R, R, w, w, C);
      }
    } else if (g !== void 0) {
      const _ = g.array;
      v = g.version;
      for (let y = 0, x = _.length / 3 - 1; y < x; y += 3) {
        const C = y + 0,
          R = y + 1,
          w = y + 2;
        d.push(C, R, R, w, w, C);
      }
    } else return;
    const m = new (rS(d) ? uS : cS)(d, 1);
    m.version = v;
    const h = s.get(f);
    h && e.remove(h), s.set(f, m);
  }
  function u(f) {
    const d = s.get(f);
    if (d) {
      const p = f.index;
      p !== null && d.version < p.version && c(f);
    } else c(f);
    return s.get(f);
  }
  return { get: a, update: l, getWireframeAttribute: u };
}
function p2(t, e, n) {
  let i;
  function r(d) {
    i = d;
  }
  let s, o;
  function a(d) {
    (s = d.type), (o = d.bytesPerElement);
  }
  function l(d, p) {
    t.drawElements(i, p, s, d * o), n.update(p, i, 1);
  }
  function c(d, p, g) {
    g !== 0 && (t.drawElementsInstanced(i, p, s, d * o, g), n.update(p, i, g));
  }
  function u(d, p, g) {
    if (g === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, s, d, 0, g);
    let m = 0;
    for (let h = 0; h < g; h++) m += p[h];
    n.update(m, i, 1);
  }
  function f(d, p, g, v) {
    if (g === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let h = 0; h < d.length; h++) c(d[h] / o, p[h], v[h]);
    else {
      m.multiDrawElementsInstancedWEBGL(i, p, 0, s, d, 0, v, 0, g);
      let h = 0;
      for (let _ = 0; _ < g; _++) h += p[_] * v[_];
      n.update(h, i, 1);
    }
  }
  (this.setMode = r),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = f);
}
function m2(t) {
  const e = { geometries: 0, textures: 0 },
    n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((n.calls++, o)) {
      case t.TRIANGLES:
        n.triangles += a * (s / 3);
        break;
      case t.LINES:
        n.lines += a * (s / 2);
        break;
      case t.LINE_STRIP:
        n.lines += a * (s - 1);
        break;
      case t.LINE_LOOP:
        n.lines += a * s;
        break;
      case t.POINTS:
        n.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    (n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0);
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function g2(t, e, n) {
  const i = new WeakMap(),
    r = new et();
  function s(o, a, l) {
    const c = o.morphTargetInfluences,
      u =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      f = u !== void 0 ? u.length : 0;
    let d = i.get(a);
    if (d === void 0 || d.count !== f) {
      let S = function () {
        A.dispose(), i.delete(a), a.removeEventListener("dispose", S);
      };
      var p = S;
      d !== void 0 && d.texture.dispose();
      const g = a.morphAttributes.position !== void 0,
        v = a.morphAttributes.normal !== void 0,
        m = a.morphAttributes.color !== void 0,
        h = a.morphAttributes.position || [],
        _ = a.morphAttributes.normal || [],
        y = a.morphAttributes.color || [];
      let x = 0;
      g === !0 && (x = 1), v === !0 && (x = 2), m === !0 && (x = 3);
      let C = a.attributes.position.count * x,
        R = 1;
      C > e.maxTextureSize &&
        ((R = Math.ceil(C / e.maxTextureSize)), (C = e.maxTextureSize));
      const w = new Float32Array(C * R * 4 * f),
        A = new oS(w, C, R, f);
      (A.type = gn), (A.needsUpdate = !0);
      const E = x * 4;
      for (let P = 0; P < f; P++) {
        const G = h[P],
          F = _[P],
          H = y[P],
          X = C * R * 4 * P;
        for (let V = 0; V < G.count; V++) {
          const Z = V * E;
          g === !0 &&
            (r.fromBufferAttribute(G, V),
            (w[X + Z + 0] = r.x),
            (w[X + Z + 1] = r.y),
            (w[X + Z + 2] = r.z),
            (w[X + Z + 3] = 0)),
            v === !0 &&
              (r.fromBufferAttribute(F, V),
              (w[X + Z + 4] = r.x),
              (w[X + Z + 5] = r.y),
              (w[X + Z + 6] = r.z),
              (w[X + Z + 7] = 0)),
            m === !0 &&
              (r.fromBufferAttribute(H, V),
              (w[X + Z + 8] = r.x),
              (w[X + Z + 9] = r.y),
              (w[X + Z + 10] = r.z),
              (w[X + Z + 11] = H.itemSize === 4 ? r.w : 1));
        }
      }
      (d = { count: f, texture: A, size: new Le(C, R) }),
        i.set(a, d),
        a.addEventListener("dispose", S);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(t, "morphTexture", o.morphTexture, n);
    else {
      let g = 0;
      for (let m = 0; m < c.length; m++) g += c[m];
      const v = a.morphTargetsRelative ? 1 : 1 - g;
      l.getUniforms().setValue(t, "morphTargetBaseInfluence", v),
        l.getUniforms().setValue(t, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(t, "morphTargetsTexture", d.texture, n),
      l.getUniforms().setValue(t, "morphTargetsTextureSize", d.size);
  }
  return { update: s };
}
function _2(t, e, n, i) {
  let r = new WeakMap();
  function s(l) {
    const c = i.render.frame,
      u = l.geometry,
      f = e.get(l, u);
    if (
      (r.get(f) !== c && (e.update(f), r.set(f, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        r.get(l) !== c &&
          (n.update(l.instanceMatrix, t.ARRAY_BUFFER),
          l.instanceColor !== null && n.update(l.instanceColor, t.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const d = l.skeleton;
      r.get(d) !== c && (d.update(), r.set(d, c));
    }
    return f;
  }
  function o() {
    r = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      n.remove(c.instanceMatrix),
      c.instanceColor !== null && n.remove(c.instanceColor);
  }
  return { update: s, dispose: o };
}
class mS extends zt {
  constructor(e, n, i, r, s, o, a, l, c, u = co) {
    if (u !== co && u !== Ao)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && u === co && (i = ms),
      i === void 0 && u === Ao && (i = wo),
      super(null, r, s, o, a, l, u, i, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: n }),
      (this.magFilter = a !== void 0 ? a : ln),
      (this.minFilter = l !== void 0 ? l : ln),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (n.compareFunction = this.compareFunction),
      n
    );
  }
}
const gS = new zt(),
  J_ = new mS(1, 1),
  _S = new oS(),
  vS = new eb(),
  yS = new hS(),
  e0 = [],
  t0 = [],
  n0 = new Float32Array(16),
  i0 = new Float32Array(9),
  r0 = new Float32Array(4);
function Oo(t, e, n) {
  const i = t[0];
  if (i <= 0 || i > 0) return t;
  const r = e * n;
  let s = e0[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (e0[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += n), t[o].toArray(s, a);
  }
  return s;
}
function Dt(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function Nt(t, e) {
  for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
}
function wu(t, e) {
  let n = t0[e];
  n === void 0 && ((n = new Int32Array(e)), (t0[e] = n));
  for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
  return n;
}
function v2(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
}
function y2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (Dt(n, e)) return;
    t.uniform2fv(this.addr, e), Nt(n, e);
  }
}
function x2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) &&
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b));
  else {
    if (Dt(n, e)) return;
    t.uniform3fv(this.addr, e), Nt(n, e);
  }
}
function S2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (Dt(n, e)) return;
    t.uniform4fv(this.addr, e), Nt(n, e);
  }
}
function M2(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Dt(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), Nt(n, e);
  } else {
    if (Dt(n, i)) return;
    r0.set(i), t.uniformMatrix2fv(this.addr, !1, r0), Nt(n, i);
  }
}
function E2(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Dt(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), Nt(n, e);
  } else {
    if (Dt(n, i)) return;
    i0.set(i), t.uniformMatrix3fv(this.addr, !1, i0), Nt(n, i);
  }
}
function T2(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Dt(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), Nt(n, e);
  } else {
    if (Dt(n, i)) return;
    n0.set(i), t.uniformMatrix4fv(this.addr, !1, n0), Nt(n, i);
  }
}
function w2(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
}
function A2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (Dt(n, e)) return;
    t.uniform2iv(this.addr, e), Nt(n, e);
  }
}
function b2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3i(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (Dt(n, e)) return;
    t.uniform3iv(this.addr, e), Nt(n, e);
  }
}
function R2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (Dt(n, e)) return;
    t.uniform4iv(this.addr, e), Nt(n, e);
  }
}
function C2(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
}
function P2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (Dt(n, e)) return;
    t.uniform2uiv(this.addr, e), Nt(n, e);
  }
}
function L2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3ui(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (Dt(n, e)) return;
    t.uniform3uiv(this.addr, e), Nt(n, e);
  }
}
function I2(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (Dt(n, e)) return;
    t.uniform4uiv(this.addr, e), Nt(n, e);
  }
}
function D2(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r));
  let s;
  this.type === t.SAMPLER_2D_SHADOW
    ? ((J_.compareFunction = nS), (s = J_))
    : (s = gS),
    n.setTexture2D(e || s, r);
}
function N2(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture3D(e || vS, r);
}
function U2(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTextureCube(e || yS, r);
}
function O2(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture2DArray(e || _S, r);
}
function F2(t) {
  switch (t) {
    case 5126:
      return v2;
    case 35664:
      return y2;
    case 35665:
      return x2;
    case 35666:
      return S2;
    case 35674:
      return M2;
    case 35675:
      return E2;
    case 35676:
      return T2;
    case 5124:
    case 35670:
      return w2;
    case 35667:
    case 35671:
      return A2;
    case 35668:
    case 35672:
      return b2;
    case 35669:
    case 35673:
      return R2;
    case 5125:
      return C2;
    case 36294:
      return P2;
    case 36295:
      return L2;
    case 36296:
      return I2;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return D2;
    case 35679:
    case 36299:
    case 36307:
      return N2;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return U2;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return O2;
  }
}
function k2(t, e) {
  t.uniform1fv(this.addr, e);
}
function B2(t, e) {
  const n = Oo(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function z2(t, e) {
  const n = Oo(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function H2(t, e) {
  const n = Oo(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function V2(t, e) {
  const n = Oo(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function G2(t, e) {
  const n = Oo(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function W2(t, e) {
  const n = Oo(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function j2(t, e) {
  t.uniform1iv(this.addr, e);
}
function X2(t, e) {
  t.uniform2iv(this.addr, e);
}
function Y2(t, e) {
  t.uniform3iv(this.addr, e);
}
function K2(t, e) {
  t.uniform4iv(this.addr, e);
}
function q2(t, e) {
  t.uniform1uiv(this.addr, e);
}
function $2(t, e) {
  t.uniform2uiv(this.addr, e);
}
function Z2(t, e) {
  t.uniform3uiv(this.addr, e);
}
function Q2(t, e) {
  t.uniform4uiv(this.addr, e);
}
function J2(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = wu(n, r);
  Dt(i, s) || (t.uniform1iv(this.addr, s), Nt(i, s));
  for (let o = 0; o !== r; ++o) n.setTexture2D(e[o] || gS, s[o]);
}
function eP(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = wu(n, r);
  Dt(i, s) || (t.uniform1iv(this.addr, s), Nt(i, s));
  for (let o = 0; o !== r; ++o) n.setTexture3D(e[o] || vS, s[o]);
}
function tP(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = wu(n, r);
  Dt(i, s) || (t.uniform1iv(this.addr, s), Nt(i, s));
  for (let o = 0; o !== r; ++o) n.setTextureCube(e[o] || yS, s[o]);
}
function nP(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = wu(n, r);
  Dt(i, s) || (t.uniform1iv(this.addr, s), Nt(i, s));
  for (let o = 0; o !== r; ++o) n.setTexture2DArray(e[o] || _S, s[o]);
}
function iP(t) {
  switch (t) {
    case 5126:
      return k2;
    case 35664:
      return B2;
    case 35665:
      return z2;
    case 35666:
      return H2;
    case 35674:
      return V2;
    case 35675:
      return G2;
    case 35676:
      return W2;
    case 5124:
    case 35670:
      return j2;
    case 35667:
    case 35671:
      return X2;
    case 35668:
    case 35672:
      return Y2;
    case 35669:
    case 35673:
      return K2;
    case 5125:
      return q2;
    case 36294:
      return $2;
    case 36295:
      return Z2;
    case 36296:
      return Q2;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return J2;
    case 35679:
    case 36299:
    case 36307:
      return eP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return tP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return nP;
  }
}
class rP {
  constructor(e, n, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = n.type),
      (this.setValue = F2(n.type));
  }
}
class sP {
  constructor(e, n, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = n.type),
      (this.size = n.size),
      (this.setValue = iP(n.type));
  }
}
class oP {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, n, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, n[a.id], i);
    }
  }
}
const Df = /(\w+)(\])?(\[|\.)?/g;
function s0(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function aP(t, e, n) {
  const i = t.name,
    r = i.length;
  for (Df.lastIndex = 0; ; ) {
    const s = Df.exec(i),
      o = Df.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === r))) {
      s0(n, c === void 0 ? new rP(a, t, e) : new sP(a, t, e));
      break;
    } else {
      let f = n.map[a];
      f === void 0 && ((f = new oP(a)), s0(n, f)), (n = f);
    }
  }
}
class Mc {
  constructor(e, n) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(n, r),
        o = e.getUniformLocation(n, s.name);
      aP(s, o, this);
    }
  }
  setValue(e, n, i, r) {
    const s = this.map[n];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, n, i) {
    const r = n[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, n, i, r) {
    for (let s = 0, o = n.length; s !== o; ++s) {
      const a = n[s],
        l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in n && i.push(o);
    }
    return i;
  }
}
function o0(t, e, n) {
  const i = t.createShader(e);
  return t.shaderSource(i, n), t.compileShader(i), i;
}
const lP = 37297;
let cP = 0;
function uP(t, e) {
  const n = t.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, n.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${n[o]}`);
  }
  return i.join(`
`);
}
const a0 = new ke();
function fP(t) {
  Xe._getMatrix(a0, Xe.workingColorSpace, t);
  const e = `mat3( ${a0.elements.map((n) => n.toFixed(4))} )`;
  switch (Xe.getTransfer(t)) {
    case Eu:
      return [e, "LinearTransferOETF"];
    case at:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", t),
        [e, "LinearTransferOETF"]
      );
  }
}
function l0(t, e, n) {
  const i = t.getShaderParameter(e, t.COMPILE_STATUS),
    r = t.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      n.toUpperCase() +
      `

` +
      r +
      `

` +
      uP(t.getShaderSource(e), o)
    );
  } else return r;
}
function dP(t, e) {
  const n = fP(e);
  return [
    `vec4 ${t}( vec4 value ) {`,
    `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function hP(t, e) {
  let n;
  switch (e) {
    case uA:
      n = "Linear";
      break;
    case fA:
      n = "Reinhard";
      break;
    case dA:
      n = "Cineon";
      break;
    case hA:
      n = "ACESFilmic";
      break;
    case mA:
      n = "AgX";
      break;
    case gA:
      n = "Neutral";
      break;
    case pA:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (n = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
const Yl = new D();
function pP() {
  Xe.getLuminanceCoefficients(Yl);
  const t = Yl.x.toFixed(4),
    e = Yl.y.toFixed(4),
    n = Yl.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${t}, ${e}, ${n} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function mP(t) {
  return [
    t.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(fa).join(`
`);
}
function gP(t) {
  const e = [];
  for (const n in t) {
    const i = t[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function _P(t, e) {
  const n = {},
    i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = t.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    s.type === t.FLOAT_MAT2 && (a = 2),
      s.type === t.FLOAT_MAT3 && (a = 3),
      s.type === t.FLOAT_MAT4 && (a = 4),
      (n[o] = {
        type: s.type,
        location: t.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return n;
}
function fa(t) {
  return t !== "";
}
function c0(t, e) {
  const n =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function u0(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const vP = /^[ \t]*#include +<([\w\d./]+)>/gm;
function zh(t) {
  return t.replace(vP, xP);
}
const yP = new Map();
function xP(t, e) {
  let n = He[e];
  if (n === void 0) {
    const i = yP.get(e);
    if (i !== void 0)
      (n = He[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return zh(n);
}
const SP =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function f0(t) {
  return t.replace(SP, MP);
}
function MP(t, e, n, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(n); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function d0(t) {
  let e = `precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	precision ${t.precision} sampler3D;
	precision ${t.precision} sampler2DArray;
	precision ${t.precision} sampler2DShadow;
	precision ${t.precision} samplerCubeShadow;
	precision ${t.precision} sampler2DArrayShadow;
	precision ${t.precision} isampler2D;
	precision ${t.precision} isampler3D;
	precision ${t.precision} isamplerCube;
	precision ${t.precision} isampler2DArray;
	precision ${t.precision} usampler2D;
	precision ${t.precision} usampler3D;
	precision ${t.precision} usamplerCube;
	precision ${t.precision} usampler2DArray;
	`;
  return (
    t.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : t.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : t.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function EP(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    t.shadowMapType === Hx
      ? (e = "SHADOWMAP_TYPE_PCF")
      : t.shadowMapType === Gw
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : t.shadowMapType === Ii && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function TP(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case Mo:
      case Eo:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Mu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function wP(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case Eo:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function AP(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case Vx:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case lA:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case cA:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function bP(t) {
  const e = t.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
    texelHeight: i,
    maxMip: n,
  };
}
function RP(t, e, n, i) {
  const r = t.getContext(),
    s = n.defines;
  let o = n.vertexShader,
    a = n.fragmentShader;
  const l = EP(n),
    c = TP(n),
    u = wP(n),
    f = AP(n),
    d = bP(n),
    p = mP(n),
    g = gP(s),
    v = r.createProgram();
  let m,
    h,
    _ = n.glslVersion
      ? "#version " +
        n.glslVersion +
        `
`
      : "";
  n.isRawShaderMaterial
    ? ((m = [
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        g,
      ].filter(fa).join(`
`)),
      m.length > 0 &&
        (m += `
`),
      (h = [
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        g,
      ].filter(fa).join(`
`)),
      h.length > 0 &&
        (h += `
`))
    : ((m = [
        d0(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        g,
        n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        n.batching ? "#define USE_BATCHING" : "",
        n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        n.instancing ? "#define USE_INSTANCING" : "",
        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + u : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.mapUv ? "#define MAP_UV " + n.mapUv : "",
        n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
        n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
        n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
        n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
        n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
        n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
        n.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
          : "",
        n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
        n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
        n.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
          : "",
        n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
        n.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
          : "",
        n.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
          : "",
        n.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
          : "",
        n.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv
          : "",
        n.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
          : "",
        n.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
          : "",
        n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
        n.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
          : "",
        n.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
          : "",
        n.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
          : "",
        n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.skinning ? "#define USE_SKINNING" : "",
        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n.morphNormals && n.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        n.morphColors ? "#define USE_MORPHCOLORS" : "",
        n.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
          : "",
        n.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
          : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(fa).join(`
`)),
      (h = [
        d0(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        g,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        n.map ? "#define USE_MAP" : "",
        n.matcap ? "#define USE_MATCAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + c : "",
        n.envMap ? "#define " + u : "",
        n.envMap ? "#define " + f : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoat ? "#define USE_CLEARCOAT" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.dispersion ? "#define USE_DISPERSION" : "",
        n.iridescence ? "#define USE_IRIDESCENCE" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaTest ? "#define USE_ALPHATEST" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.sheen ? "#define USE_SHEEN" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors || n.instancingColor || n.batchingColor
          ? "#define USE_COLOR"
          : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        n.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        n.toneMapping !== Lr ? "#define TONE_MAPPING" : "",
        n.toneMapping !== Lr ? He.tonemapping_pars_fragment : "",
        n.toneMapping !== Lr ? hP("toneMapping", n.toneMapping) : "",
        n.dithering ? "#define DITHERING" : "",
        n.opaque ? "#define OPAQUE" : "",
        He.colorspace_pars_fragment,
        dP("linearToOutputTexel", n.outputColorSpace),
        pP(),
        n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
        `
`,
      ].filter(fa).join(`
`))),
    (o = zh(o)),
    (o = c0(o, n)),
    (o = u0(o, n)),
    (a = zh(a)),
    (a = c0(a, n)),
    (a = u0(a, n)),
    (o = f0(o)),
    (a = f0(a)),
    n.isRawShaderMaterial !== !0 &&
      ((_ = `#version 300 es
`),
      (m =
        [
          p,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        m),
      (h =
        [
          "#define varying in",
          n.glslVersion === T_
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          n.glslVersion === T_ ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        h));
  const y = _ + m + o,
    x = _ + h + a,
    C = o0(r, r.VERTEX_SHADER, y),
    R = o0(r, r.FRAGMENT_SHADER, x);
  r.attachShader(v, C),
    r.attachShader(v, R),
    n.index0AttributeName !== void 0
      ? r.bindAttribLocation(v, 0, n.index0AttributeName)
      : n.morphTargets === !0 && r.bindAttribLocation(v, 0, "position"),
    r.linkProgram(v);
  function w(P) {
    if (t.debug.checkShaderErrors) {
      const G = r.getProgramInfoLog(v).trim(),
        F = r.getShaderInfoLog(C).trim(),
        H = r.getShaderInfoLog(R).trim();
      let X = !0,
        V = !0;
      if (r.getProgramParameter(v, r.LINK_STATUS) === !1)
        if (((X = !1), typeof t.debug.onShaderError == "function"))
          t.debug.onShaderError(r, v, C, R);
        else {
          const Z = l0(r, C, "vertex"),
            L = l0(r, R, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(v, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              P.name +
              `
Material Type: ` +
              P.type +
              `

Program Info Log: ` +
              G +
              `
` +
              Z +
              `
` +
              L
          );
        }
      else
        G !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", G)
          : (F === "" || H === "") && (V = !1);
      V &&
        (P.diagnostics = {
          runnable: X,
          programLog: G,
          vertexShader: { log: F, prefix: m },
          fragmentShader: { log: H, prefix: h },
        });
    }
    r.deleteShader(C), r.deleteShader(R), (A = new Mc(r, v)), (E = _P(r, v));
  }
  let A;
  this.getUniforms = function () {
    return A === void 0 && w(this), A;
  };
  let E;
  this.getAttributes = function () {
    return E === void 0 && w(this), E;
  };
  let S = n.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return S === !1 && (S = r.getProgramParameter(v, lP)), S;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(v),
        (this.program = void 0);
    }),
    (this.type = n.shaderType),
    (this.name = n.shaderName),
    (this.id = cP++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = v),
    (this.vertexShader = C),
    (this.fragmentShader = R),
    this
  );
}
let CP = 0;
class PP {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const n = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(n),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let i = n.get(e);
    return i === void 0 && ((i = new Set()), n.set(e, i)), i;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let i = n.get(e);
    return i === void 0 && ((i = new LP(e)), n.set(e, i)), i;
  }
}
class LP {
  constructor(e) {
    (this.id = CP++), (this.code = e), (this.usedTimes = 0);
  }
}
function IP(t, e, n, i, r, s, o) {
  const a = new aS(),
    l = new PP(),
    c = new Set(),
    u = [],
    f = r.logarithmicDepthBuffer,
    d = r.vertexTextures;
  let p = r.precision;
  const g = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function v(E) {
    return c.add(E), E === 0 ? "uv" : `uv${E}`;
  }
  function m(E, S, P, G, F) {
    const H = G.fog,
      X = F.geometry,
      V = E.isMeshStandardMaterial ? G.environment : null,
      Z = (E.isMeshStandardMaterial ? n : e).get(E.envMap || V),
      L = Z && Z.mapping === Mu ? Z.image.height : null,
      Y = g[E.type];
    E.precision !== null &&
      ((p = r.getMaxPrecision(E.precision)),
      p !== E.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          E.precision,
          "not supported, using",
          p,
          "instead."
        ));
    const q =
        X.morphAttributes.position ||
        X.morphAttributes.normal ||
        X.morphAttributes.color,
      oe = q !== void 0 ? q.length : 0;
    let pe = 0;
    X.morphAttributes.position !== void 0 && (pe = 1),
      X.morphAttributes.normal !== void 0 && (pe = 2),
      X.morphAttributes.color !== void 0 && (pe = 3);
    let Ne, j, ie, ge;
    if (Y) {
      const it = li[Y];
      (Ne = it.vertexShader), (j = it.fragmentShader);
    } else
      (Ne = E.vertexShader),
        (j = E.fragmentShader),
        l.update(E),
        (ie = l.getVertexShaderID(E)),
        (ge = l.getFragmentShaderID(E));
    const ae = t.getRenderTarget(),
      Ce = t.state.buffers.depth.getReversed(),
      Ue = F.isInstancedMesh === !0,
      Ve = F.isBatchedMesh === !0,
      yt = !!E.map,
      $e = !!E.matcap,
      At = !!Z,
      O = !!E.aoMap,
      In = !!E.lightMap,
      Ye = !!E.bumpMap,
      Ke = !!E.normalMap,
      be = !!E.displacementMap,
      dt = !!E.emissiveMap,
      Ae = !!E.metalnessMap,
      b = !!E.roughnessMap,
      M = E.anisotropy > 0,
      k = E.clearcoat > 0,
      Q = E.dispersion > 0,
      ee = E.iridescence > 0,
      $ = E.sheen > 0,
      Te = E.transmission > 0,
      ue = M && !!E.anisotropyMap,
      _e = k && !!E.clearcoatMap,
      Ze = k && !!E.clearcoatNormalMap,
      re = k && !!E.clearcoatRoughnessMap,
      ve = ee && !!E.iridescenceMap,
      Re = ee && !!E.iridescenceThicknessMap,
      Pe = $ && !!E.sheenColorMap,
      ye = $ && !!E.sheenRoughnessMap,
      qe = !!E.specularMap,
      ze = !!E.specularColorMap,
      ct = !!E.specularIntensityMap,
      I = Te && !!E.transmissionMap,
      ce = Te && !!E.thicknessMap,
      W = !!E.gradientMap,
      J = !!E.alphaMap,
      he = E.alphaTest > 0,
      fe = !!E.alphaHash,
      Oe = !!E.extensions;
    let Tt = Lr;
    E.toneMapped &&
      (ae === null || ae.isXRRenderTarget === !0) &&
      (Tt = t.toneMapping);
    const Xt = {
      shaderID: Y,
      shaderType: E.type,
      shaderName: E.name,
      vertexShader: Ne,
      fragmentShader: j,
      defines: E.defines,
      customVertexShaderID: ie,
      customFragmentShaderID: ge,
      isRawShaderMaterial: E.isRawShaderMaterial === !0,
      glslVersion: E.glslVersion,
      precision: p,
      batching: Ve,
      batchingColor: Ve && F._colorsTexture !== null,
      instancing: Ue,
      instancingColor: Ue && F.instanceColor !== null,
      instancingMorph: Ue && F.morphTexture !== null,
      supportsVertexTextures: d,
      outputColorSpace:
        ae === null
          ? t.outputColorSpace
          : ae.isXRRenderTarget === !0
          ? ae.texture.colorSpace
          : tn,
      alphaToCoverage: !!E.alphaToCoverage,
      map: yt,
      matcap: $e,
      envMap: At,
      envMapMode: At && Z.mapping,
      envMapCubeUVHeight: L,
      aoMap: O,
      lightMap: In,
      bumpMap: Ye,
      normalMap: Ke,
      displacementMap: d && be,
      emissiveMap: dt,
      normalMapObjectSpace: Ke && E.normalMapType === MA,
      normalMapTangentSpace: Ke && E.normalMapType === tS,
      metalnessMap: Ae,
      roughnessMap: b,
      anisotropy: M,
      anisotropyMap: ue,
      clearcoat: k,
      clearcoatMap: _e,
      clearcoatNormalMap: Ze,
      clearcoatRoughnessMap: re,
      dispersion: Q,
      iridescence: ee,
      iridescenceMap: ve,
      iridescenceThicknessMap: Re,
      sheen: $,
      sheenColorMap: Pe,
      sheenRoughnessMap: ye,
      specularMap: qe,
      specularColorMap: ze,
      specularIntensityMap: ct,
      transmission: Te,
      transmissionMap: I,
      thicknessMap: ce,
      gradientMap: W,
      opaque:
        E.transparent === !1 && E.blending === lo && E.alphaToCoverage === !1,
      alphaMap: J,
      alphaTest: he,
      alphaHash: fe,
      combine: E.combine,
      mapUv: yt && v(E.map.channel),
      aoMapUv: O && v(E.aoMap.channel),
      lightMapUv: In && v(E.lightMap.channel),
      bumpMapUv: Ye && v(E.bumpMap.channel),
      normalMapUv: Ke && v(E.normalMap.channel),
      displacementMapUv: be && v(E.displacementMap.channel),
      emissiveMapUv: dt && v(E.emissiveMap.channel),
      metalnessMapUv: Ae && v(E.metalnessMap.channel),
      roughnessMapUv: b && v(E.roughnessMap.channel),
      anisotropyMapUv: ue && v(E.anisotropyMap.channel),
      clearcoatMapUv: _e && v(E.clearcoatMap.channel),
      clearcoatNormalMapUv: Ze && v(E.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: re && v(E.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ve && v(E.iridescenceMap.channel),
      iridescenceThicknessMapUv: Re && v(E.iridescenceThicknessMap.channel),
      sheenColorMapUv: Pe && v(E.sheenColorMap.channel),
      sheenRoughnessMapUv: ye && v(E.sheenRoughnessMap.channel),
      specularMapUv: qe && v(E.specularMap.channel),
      specularColorMapUv: ze && v(E.specularColorMap.channel),
      specularIntensityMapUv: ct && v(E.specularIntensityMap.channel),
      transmissionMapUv: I && v(E.transmissionMap.channel),
      thicknessMapUv: ce && v(E.thicknessMap.channel),
      alphaMapUv: J && v(E.alphaMap.channel),
      vertexTangents: !!X.attributes.tangent && (Ke || M),
      vertexColors: E.vertexColors,
      vertexAlphas:
        E.vertexColors === !0 &&
        !!X.attributes.color &&
        X.attributes.color.itemSize === 4,
      pointsUvs: F.isPoints === !0 && !!X.attributes.uv && (yt || J),
      fog: !!H,
      useFog: E.fog === !0,
      fogExp2: !!H && H.isFogExp2,
      flatShading: E.flatShading === !0,
      sizeAttenuation: E.sizeAttenuation === !0,
      logarithmicDepthBuffer: f,
      reverseDepthBuffer: Ce,
      skinning: F.isSkinnedMesh === !0,
      morphTargets: X.morphAttributes.position !== void 0,
      morphNormals: X.morphAttributes.normal !== void 0,
      morphColors: X.morphAttributes.color !== void 0,
      morphTargetsCount: oe,
      morphTextureStride: pe,
      numDirLights: S.directional.length,
      numPointLights: S.point.length,
      numSpotLights: S.spot.length,
      numSpotLightMaps: S.spotLightMap.length,
      numRectAreaLights: S.rectArea.length,
      numHemiLights: S.hemi.length,
      numDirLightShadows: S.directionalShadowMap.length,
      numPointLightShadows: S.pointShadowMap.length,
      numSpotLightShadows: S.spotShadowMap.length,
      numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
      numLightProbes: S.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: E.dithering,
      shadowMapEnabled: t.shadowMap.enabled && P.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: Tt,
      decodeVideoTexture:
        yt &&
        E.map.isVideoTexture === !0 &&
        Xe.getTransfer(E.map.colorSpace) === at,
      decodeVideoTextureEmissive:
        dt &&
        E.emissiveMap.isVideoTexture === !0 &&
        Xe.getTransfer(E.emissiveMap.colorSpace) === at,
      premultipliedAlpha: E.premultipliedAlpha,
      doubleSided: E.side === ui,
      flipSided: E.side === xn,
      useDepthPacking: E.depthPacking >= 0,
      depthPacking: E.depthPacking || 0,
      index0AttributeName: E.index0AttributeName,
      extensionClipCullDistance:
        Oe &&
        E.extensions.clipCullDistance === !0 &&
        i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((Oe && E.extensions.multiDraw === !0) || Ve) &&
        i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: E.customProgramCacheKey(),
    };
    return (
      (Xt.vertexUv1s = c.has(1)),
      (Xt.vertexUv2s = c.has(2)),
      (Xt.vertexUv3s = c.has(3)),
      c.clear(),
      Xt
    );
  }
  function h(E) {
    const S = [];
    if (
      (E.shaderID
        ? S.push(E.shaderID)
        : (S.push(E.customVertexShaderID), S.push(E.customFragmentShaderID)),
      E.defines !== void 0)
    )
      for (const P in E.defines) S.push(P), S.push(E.defines[P]);
    return (
      E.isRawShaderMaterial === !1 &&
        (_(S, E), y(S, E), S.push(t.outputColorSpace)),
      S.push(E.customProgramCacheKey),
      S.join()
    );
  }
  function _(E, S) {
    E.push(S.precision),
      E.push(S.outputColorSpace),
      E.push(S.envMapMode),
      E.push(S.envMapCubeUVHeight),
      E.push(S.mapUv),
      E.push(S.alphaMapUv),
      E.push(S.lightMapUv),
      E.push(S.aoMapUv),
      E.push(S.bumpMapUv),
      E.push(S.normalMapUv),
      E.push(S.displacementMapUv),
      E.push(S.emissiveMapUv),
      E.push(S.metalnessMapUv),
      E.push(S.roughnessMapUv),
      E.push(S.anisotropyMapUv),
      E.push(S.clearcoatMapUv),
      E.push(S.clearcoatNormalMapUv),
      E.push(S.clearcoatRoughnessMapUv),
      E.push(S.iridescenceMapUv),
      E.push(S.iridescenceThicknessMapUv),
      E.push(S.sheenColorMapUv),
      E.push(S.sheenRoughnessMapUv),
      E.push(S.specularMapUv),
      E.push(S.specularColorMapUv),
      E.push(S.specularIntensityMapUv),
      E.push(S.transmissionMapUv),
      E.push(S.thicknessMapUv),
      E.push(S.combine),
      E.push(S.fogExp2),
      E.push(S.sizeAttenuation),
      E.push(S.morphTargetsCount),
      E.push(S.morphAttributeCount),
      E.push(S.numDirLights),
      E.push(S.numPointLights),
      E.push(S.numSpotLights),
      E.push(S.numSpotLightMaps),
      E.push(S.numHemiLights),
      E.push(S.numRectAreaLights),
      E.push(S.numDirLightShadows),
      E.push(S.numPointLightShadows),
      E.push(S.numSpotLightShadows),
      E.push(S.numSpotLightShadowsWithMaps),
      E.push(S.numLightProbes),
      E.push(S.shadowMapType),
      E.push(S.toneMapping),
      E.push(S.numClippingPlanes),
      E.push(S.numClipIntersection),
      E.push(S.depthPacking);
  }
  function y(E, S) {
    a.disableAll(),
      S.supportsVertexTextures && a.enable(0),
      S.instancing && a.enable(1),
      S.instancingColor && a.enable(2),
      S.instancingMorph && a.enable(3),
      S.matcap && a.enable(4),
      S.envMap && a.enable(5),
      S.normalMapObjectSpace && a.enable(6),
      S.normalMapTangentSpace && a.enable(7),
      S.clearcoat && a.enable(8),
      S.iridescence && a.enable(9),
      S.alphaTest && a.enable(10),
      S.vertexColors && a.enable(11),
      S.vertexAlphas && a.enable(12),
      S.vertexUv1s && a.enable(13),
      S.vertexUv2s && a.enable(14),
      S.vertexUv3s && a.enable(15),
      S.vertexTangents && a.enable(16),
      S.anisotropy && a.enable(17),
      S.alphaHash && a.enable(18),
      S.batching && a.enable(19),
      S.dispersion && a.enable(20),
      S.batchingColor && a.enable(21),
      E.push(a.mask),
      a.disableAll(),
      S.fog && a.enable(0),
      S.useFog && a.enable(1),
      S.flatShading && a.enable(2),
      S.logarithmicDepthBuffer && a.enable(3),
      S.reverseDepthBuffer && a.enable(4),
      S.skinning && a.enable(5),
      S.morphTargets && a.enable(6),
      S.morphNormals && a.enable(7),
      S.morphColors && a.enable(8),
      S.premultipliedAlpha && a.enable(9),
      S.shadowMapEnabled && a.enable(10),
      S.doubleSided && a.enable(11),
      S.flipSided && a.enable(12),
      S.useDepthPacking && a.enable(13),
      S.dithering && a.enable(14),
      S.transmission && a.enable(15),
      S.sheen && a.enable(16),
      S.opaque && a.enable(17),
      S.pointsUvs && a.enable(18),
      S.decodeVideoTexture && a.enable(19),
      S.decodeVideoTextureEmissive && a.enable(20),
      S.alphaToCoverage && a.enable(21),
      E.push(a.mask);
  }
  function x(E) {
    const S = g[E.type];
    let P;
    if (S) {
      const G = li[S];
      P = mb.clone(G.uniforms);
    } else P = E.uniforms;
    return P;
  }
  function C(E, S) {
    let P;
    for (let G = 0, F = u.length; G < F; G++) {
      const H = u[G];
      if (H.cacheKey === S) {
        (P = H), ++P.usedTimes;
        break;
      }
    }
    return P === void 0 && ((P = new RP(t, S, E, s)), u.push(P)), P;
  }
  function R(E) {
    if (--E.usedTimes === 0) {
      const S = u.indexOf(E);
      (u[S] = u[u.length - 1]), u.pop(), E.destroy();
    }
  }
  function w(E) {
    l.remove(E);
  }
  function A() {
    l.dispose();
  }
  return {
    getParameters: m,
    getProgramCacheKey: h,
    getUniforms: x,
    acquireProgram: C,
    releaseProgram: R,
    releaseShaderCache: w,
    programs: u,
    dispose: A,
  };
}
function DP() {
  let t = new WeakMap();
  function e(o) {
    return t.has(o);
  }
  function n(o) {
    let a = t.get(o);
    return a === void 0 && ((a = {}), t.set(o, a)), a;
  }
  function i(o) {
    t.delete(o);
  }
  function r(o, a, l) {
    t.get(o)[a] = l;
  }
  function s() {
    t = new WeakMap();
  }
  return { has: e, get: n, remove: i, update: r, dispose: s };
}
function NP(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function h0(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function p0() {
  const t = [];
  let e = 0;
  const n = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
  }
  function o(f, d, p, g, v, m) {
    let h = t[e];
    return (
      h === void 0
        ? ((h = {
            id: f.id,
            object: f,
            geometry: d,
            material: p,
            groupOrder: g,
            renderOrder: f.renderOrder,
            z: v,
            group: m,
          }),
          (t[e] = h))
        : ((h.id = f.id),
          (h.object = f),
          (h.geometry = d),
          (h.material = p),
          (h.groupOrder = g),
          (h.renderOrder = f.renderOrder),
          (h.z = v),
          (h.group = m)),
      e++,
      h
    );
  }
  function a(f, d, p, g, v, m) {
    const h = o(f, d, p, g, v, m);
    p.transmission > 0
      ? i.push(h)
      : p.transparent === !0
      ? r.push(h)
      : n.push(h);
  }
  function l(f, d, p, g, v, m) {
    const h = o(f, d, p, g, v, m);
    p.transmission > 0
      ? i.unshift(h)
      : p.transparent === !0
      ? r.unshift(h)
      : n.unshift(h);
  }
  function c(f, d) {
    n.length > 1 && n.sort(f || NP),
      i.length > 1 && i.sort(d || h0),
      r.length > 1 && r.sort(d || h0);
  }
  function u() {
    for (let f = e, d = t.length; f < d; f++) {
      const p = t[f];
      if (p.id === null) break;
      (p.id = null),
        (p.object = null),
        (p.geometry = null),
        (p.material = null),
        (p.group = null);
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function UP() {
  let t = new WeakMap();
  function e(i, r) {
    const s = t.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new p0()), t.set(i, [o]))
        : r >= s.length
        ? ((o = new p0()), s.push(o))
        : (o = s[r]),
      o
    );
  }
  function n() {
    t = new WeakMap();
  }
  return { get: e, dispose: n };
}
function OP() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = { direction: new D(), color: new De() };
          break;
        case "SpotLight":
          n = {
            position: new D(),
            direction: new D(),
            color: new De(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = { position: new D(), color: new De(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n = { direction: new D(), skyColor: new De(), groundColor: new De() };
          break;
        case "RectAreaLight":
          n = {
            color: new De(),
            position: new D(),
            halfWidth: new D(),
            halfHeight: new D(),
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
function FP() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le(),
          };
          break;
        case "SpotLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le(),
          };
          break;
        case "PointLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
let kP = 0;
function BP(t, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (t.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (t.map ? 1 : 0)
  );
}
function zP(t) {
  const e = new OP(),
    n = FP(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) i.probe.push(new D());
  const r = new D(),
    s = new Be(),
    o = new Be();
  function a(c) {
    let u = 0,
      f = 0,
      d = 0;
    for (let E = 0; E < 9; E++) i.probe[E].set(0, 0, 0);
    let p = 0,
      g = 0,
      v = 0,
      m = 0,
      h = 0,
      _ = 0,
      y = 0,
      x = 0,
      C = 0,
      R = 0,
      w = 0;
    c.sort(BP);
    for (let E = 0, S = c.length; E < S; E++) {
      const P = c[E],
        G = P.color,
        F = P.intensity,
        H = P.distance,
        X = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
      if (P.isAmbientLight) (u += G.r * F), (f += G.g * F), (d += G.b * F);
      else if (P.isLightProbe) {
        for (let V = 0; V < 9; V++)
          i.probe[V].addScaledVector(P.sh.coefficients[V], F);
        w++;
      } else if (P.isDirectionalLight) {
        const V = e.get(P);
        if ((V.color.copy(P.color).multiplyScalar(P.intensity), P.castShadow)) {
          const Z = P.shadow,
            L = n.get(P);
          (L.shadowIntensity = Z.intensity),
            (L.shadowBias = Z.bias),
            (L.shadowNormalBias = Z.normalBias),
            (L.shadowRadius = Z.radius),
            (L.shadowMapSize = Z.mapSize),
            (i.directionalShadow[p] = L),
            (i.directionalShadowMap[p] = X),
            (i.directionalShadowMatrix[p] = P.shadow.matrix),
            _++;
        }
        (i.directional[p] = V), p++;
      } else if (P.isSpotLight) {
        const V = e.get(P);
        V.position.setFromMatrixPosition(P.matrixWorld),
          V.color.copy(G).multiplyScalar(F),
          (V.distance = H),
          (V.coneCos = Math.cos(P.angle)),
          (V.penumbraCos = Math.cos(P.angle * (1 - P.penumbra))),
          (V.decay = P.decay),
          (i.spot[v] = V);
        const Z = P.shadow;
        if (
          (P.map &&
            ((i.spotLightMap[C] = P.map),
            C++,
            Z.updateMatrices(P),
            P.castShadow && R++),
          (i.spotLightMatrix[v] = Z.matrix),
          P.castShadow)
        ) {
          const L = n.get(P);
          (L.shadowIntensity = Z.intensity),
            (L.shadowBias = Z.bias),
            (L.shadowNormalBias = Z.normalBias),
            (L.shadowRadius = Z.radius),
            (L.shadowMapSize = Z.mapSize),
            (i.spotShadow[v] = L),
            (i.spotShadowMap[v] = X),
            x++;
        }
        v++;
      } else if (P.isRectAreaLight) {
        const V = e.get(P);
        V.color.copy(G).multiplyScalar(F),
          V.halfWidth.set(P.width * 0.5, 0, 0),
          V.halfHeight.set(0, P.height * 0.5, 0),
          (i.rectArea[m] = V),
          m++;
      } else if (P.isPointLight) {
        const V = e.get(P);
        if (
          (V.color.copy(P.color).multiplyScalar(P.intensity),
          (V.distance = P.distance),
          (V.decay = P.decay),
          P.castShadow)
        ) {
          const Z = P.shadow,
            L = n.get(P);
          (L.shadowIntensity = Z.intensity),
            (L.shadowBias = Z.bias),
            (L.shadowNormalBias = Z.normalBias),
            (L.shadowRadius = Z.radius),
            (L.shadowMapSize = Z.mapSize),
            (L.shadowCameraNear = Z.camera.near),
            (L.shadowCameraFar = Z.camera.far),
            (i.pointShadow[g] = L),
            (i.pointShadowMap[g] = X),
            (i.pointShadowMatrix[g] = P.shadow.matrix),
            y++;
        }
        (i.point[g] = V), g++;
      } else if (P.isHemisphereLight) {
        const V = e.get(P);
        V.skyColor.copy(P.color).multiplyScalar(F),
          V.groundColor.copy(P.groundColor).multiplyScalar(F),
          (i.hemi[h] = V),
          h++;
      }
    }
    m > 0 &&
      (t.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = le.LTC_FLOAT_1), (i.rectAreaLTC2 = le.LTC_FLOAT_2))
        : ((i.rectAreaLTC1 = le.LTC_HALF_1), (i.rectAreaLTC2 = le.LTC_HALF_2))),
      (i.ambient[0] = u),
      (i.ambient[1] = f),
      (i.ambient[2] = d);
    const A = i.hash;
    (A.directionalLength !== p ||
      A.pointLength !== g ||
      A.spotLength !== v ||
      A.rectAreaLength !== m ||
      A.hemiLength !== h ||
      A.numDirectionalShadows !== _ ||
      A.numPointShadows !== y ||
      A.numSpotShadows !== x ||
      A.numSpotMaps !== C ||
      A.numLightProbes !== w) &&
      ((i.directional.length = p),
      (i.spot.length = v),
      (i.rectArea.length = m),
      (i.point.length = g),
      (i.hemi.length = h),
      (i.directionalShadow.length = _),
      (i.directionalShadowMap.length = _),
      (i.pointShadow.length = y),
      (i.pointShadowMap.length = y),
      (i.spotShadow.length = x),
      (i.spotShadowMap.length = x),
      (i.directionalShadowMatrix.length = _),
      (i.pointShadowMatrix.length = y),
      (i.spotLightMatrix.length = x + C - R),
      (i.spotLightMap.length = C),
      (i.numSpotLightShadowsWithMaps = R),
      (i.numLightProbes = w),
      (A.directionalLength = p),
      (A.pointLength = g),
      (A.spotLength = v),
      (A.rectAreaLength = m),
      (A.hemiLength = h),
      (A.numDirectionalShadows = _),
      (A.numPointShadows = y),
      (A.numSpotShadows = x),
      (A.numSpotMaps = C),
      (A.numLightProbes = w),
      (i.version = kP++));
  }
  function l(c, u) {
    let f = 0,
      d = 0,
      p = 0,
      g = 0,
      v = 0;
    const m = u.matrixWorldInverse;
    for (let h = 0, _ = c.length; h < _; h++) {
      const y = c[h];
      if (y.isDirectionalLight) {
        const x = i.directional[f];
        x.direction.setFromMatrixPosition(y.matrixWorld),
          r.setFromMatrixPosition(y.target.matrixWorld),
          x.direction.sub(r),
          x.direction.transformDirection(m),
          f++;
      } else if (y.isSpotLight) {
        const x = i.spot[p];
        x.position.setFromMatrixPosition(y.matrixWorld),
          x.position.applyMatrix4(m),
          x.direction.setFromMatrixPosition(y.matrixWorld),
          r.setFromMatrixPosition(y.target.matrixWorld),
          x.direction.sub(r),
          x.direction.transformDirection(m),
          p++;
      } else if (y.isRectAreaLight) {
        const x = i.rectArea[g];
        x.position.setFromMatrixPosition(y.matrixWorld),
          x.position.applyMatrix4(m),
          o.identity(),
          s.copy(y.matrixWorld),
          s.premultiply(m),
          o.extractRotation(s),
          x.halfWidth.set(y.width * 0.5, 0, 0),
          x.halfHeight.set(0, y.height * 0.5, 0),
          x.halfWidth.applyMatrix4(o),
          x.halfHeight.applyMatrix4(o),
          g++;
      } else if (y.isPointLight) {
        const x = i.point[d];
        x.position.setFromMatrixPosition(y.matrixWorld),
          x.position.applyMatrix4(m),
          d++;
      } else if (y.isHemisphereLight) {
        const x = i.hemi[v];
        x.direction.setFromMatrixPosition(y.matrixWorld),
          x.direction.transformDirection(m),
          v++;
      }
    }
  }
  return { setup: a, setupView: l, state: i };
}
function m0(t) {
  const e = new zP(t),
    n = [],
    i = [];
  function r(u) {
    (c.camera = u), (n.length = 0), (i.length = 0);
  }
  function s(u) {
    n.push(u);
  }
  function o(u) {
    i.push(u);
  }
  function a() {
    e.setup(n);
  }
  function l(u) {
    e.setupView(n, u);
  }
  const c = {
    lightsArray: n,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: r,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: s,
    pushShadow: o,
  };
}
function HP(t) {
  let e = new WeakMap();
  function n(r, s = 0) {
    const o = e.get(r);
    let a;
    return (
      o === void 0
        ? ((a = new m0(t)), e.set(r, [a]))
        : s >= o.length
        ? ((a = new m0(t)), o.push(a))
        : (a = o[s]),
      a
    );
  }
  function i() {
    e = new WeakMap();
  }
  return { get: n, dispose: i };
}
class VP extends _i {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.depthPacking = xA),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class GP extends _i {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const WP = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  jP = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function XP(t, e, n) {
  let i = new om();
  const r = new Le(),
    s = new Le(),
    o = new et(),
    a = new VP({ depthPacking: SA }),
    l = new GP(),
    c = {},
    u = n.maxTextureSize,
    f = { [Zi]: xn, [xn]: Zi, [ui]: ui },
    d = new Fr({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Le() },
        radius: { value: 4 },
      },
      vertexShader: WP,
      fragmentShader: jP,
    }),
    p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const g = new Si();
  g.setAttribute(
    "position",
    new cn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const v = new An(g, d),
    m = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Hx);
  let h = this.type;
  this.render = function (R, w, A) {
    if (
      m.enabled === !1 ||
      (m.autoUpdate === !1 && m.needsUpdate === !1) ||
      R.length === 0
    )
      return;
    const E = t.getRenderTarget(),
      S = t.getActiveCubeFace(),
      P = t.getActiveMipmapLevel(),
      G = t.state;
    G.setBlending(Pr),
      G.buffers.color.setClear(1, 1, 1, 1),
      G.buffers.depth.setTest(!0),
      G.setScissorTest(!1);
    const F = h !== Ii && this.type === Ii,
      H = h === Ii && this.type !== Ii;
    for (let X = 0, V = R.length; X < V; X++) {
      const Z = R[X],
        L = Z.shadow;
      if (L === void 0) {
        console.warn("THREE.WebGLShadowMap:", Z, "has no shadow.");
        continue;
      }
      if (L.autoUpdate === !1 && L.needsUpdate === !1) continue;
      r.copy(L.mapSize);
      const Y = L.getFrameExtents();
      if (
        (r.multiply(Y),
        s.copy(L.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u &&
            ((s.x = Math.floor(u / Y.x)),
            (r.x = s.x * Y.x),
            (L.mapSize.x = s.x)),
          r.y > u &&
            ((s.y = Math.floor(u / Y.y)),
            (r.y = s.y * Y.y),
            (L.mapSize.y = s.y))),
        L.map === null || F === !0 || H === !0)
      ) {
        const oe = this.type !== Ii ? { minFilter: ln, magFilter: ln } : {};
        L.map !== null && L.map.dispose(),
          (L.map = new gs(r.x, r.y, oe)),
          (L.map.texture.name = Z.name + ".shadowMap"),
          L.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(L.map), t.clear();
      const q = L.getViewportCount();
      for (let oe = 0; oe < q; oe++) {
        const pe = L.getViewport(oe);
        o.set(s.x * pe.x, s.y * pe.y, s.x * pe.z, s.y * pe.w),
          G.viewport(o),
          L.updateMatrices(Z, oe),
          (i = L.getFrustum()),
          x(w, A, L.camera, Z, this.type);
      }
      L.isPointLightShadow !== !0 && this.type === Ii && _(L, A),
        (L.needsUpdate = !1);
    }
    (h = this.type), (m.needsUpdate = !1), t.setRenderTarget(E, S, P);
  };
  function _(R, w) {
    const A = e.update(v);
    d.defines.VSM_SAMPLES !== R.blurSamples &&
      ((d.defines.VSM_SAMPLES = R.blurSamples),
      (p.defines.VSM_SAMPLES = R.blurSamples),
      (d.needsUpdate = !0),
      (p.needsUpdate = !0)),
      R.mapPass === null && (R.mapPass = new gs(r.x, r.y)),
      (d.uniforms.shadow_pass.value = R.map.texture),
      (d.uniforms.resolution.value = R.mapSize),
      (d.uniforms.radius.value = R.radius),
      t.setRenderTarget(R.mapPass),
      t.clear(),
      t.renderBufferDirect(w, null, A, d, v, null),
      (p.uniforms.shadow_pass.value = R.mapPass.texture),
      (p.uniforms.resolution.value = R.mapSize),
      (p.uniforms.radius.value = R.radius),
      t.setRenderTarget(R.map),
      t.clear(),
      t.renderBufferDirect(w, null, A, p, v, null);
  }
  function y(R, w, A, E) {
    let S = null;
    const P =
      A.isPointLight === !0 ? R.customDistanceMaterial : R.customDepthMaterial;
    if (P !== void 0) S = P;
    else if (
      ((S = A.isPointLight === !0 ? l : a),
      (t.localClippingEnabled &&
        w.clipShadows === !0 &&
        Array.isArray(w.clippingPlanes) &&
        w.clippingPlanes.length !== 0) ||
        (w.displacementMap && w.displacementScale !== 0) ||
        (w.alphaMap && w.alphaTest > 0) ||
        (w.map && w.alphaTest > 0))
    ) {
      const G = S.uuid,
        F = w.uuid;
      let H = c[G];
      H === void 0 && ((H = {}), (c[G] = H));
      let X = H[F];
      X === void 0 &&
        ((X = S.clone()), (H[F] = X), w.addEventListener("dispose", C)),
        (S = X);
    }
    if (
      ((S.visible = w.visible),
      (S.wireframe = w.wireframe),
      E === Ii
        ? (S.side = w.shadowSide !== null ? w.shadowSide : w.side)
        : (S.side = w.shadowSide !== null ? w.shadowSide : f[w.side]),
      (S.alphaMap = w.alphaMap),
      (S.alphaTest = w.alphaTest),
      (S.map = w.map),
      (S.clipShadows = w.clipShadows),
      (S.clippingPlanes = w.clippingPlanes),
      (S.clipIntersection = w.clipIntersection),
      (S.displacementMap = w.displacementMap),
      (S.displacementScale = w.displacementScale),
      (S.displacementBias = w.displacementBias),
      (S.wireframeLinewidth = w.wireframeLinewidth),
      (S.linewidth = w.linewidth),
      A.isPointLight === !0 && S.isMeshDistanceMaterial === !0)
    ) {
      const G = t.properties.get(S);
      G.light = A;
    }
    return S;
  }
  function x(R, w, A, E, S) {
    if (R.visible === !1) return;
    if (
      R.layers.test(w.layers) &&
      (R.isMesh || R.isLine || R.isPoints) &&
      (R.castShadow || (R.receiveShadow && S === Ii)) &&
      (!R.frustumCulled || i.intersectsObject(R))
    ) {
      R.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, R.matrixWorld);
      const F = e.update(R),
        H = R.material;
      if (Array.isArray(H)) {
        const X = F.groups;
        for (let V = 0, Z = X.length; V < Z; V++) {
          const L = X[V],
            Y = H[L.materialIndex];
          if (Y && Y.visible) {
            const q = y(R, Y, E, S);
            R.onBeforeShadow(t, R, w, A, F, q, L),
              t.renderBufferDirect(A, null, F, q, R, L),
              R.onAfterShadow(t, R, w, A, F, q, L);
          }
        }
      } else if (H.visible) {
        const X = y(R, H, E, S);
        R.onBeforeShadow(t, R, w, A, F, X, null),
          t.renderBufferDirect(A, null, F, X, R, null),
          R.onAfterShadow(t, R, w, A, F, X, null);
      }
    }
    const G = R.children;
    for (let F = 0, H = G.length; F < H; F++) x(G[F], w, A, E, S);
  }
  function C(R) {
    R.target.removeEventListener("dispose", C);
    for (const A in c) {
      const E = c[A],
        S = R.target.uuid;
      S in E && (E[S].dispose(), delete E[S]);
    }
  }
}
const YP = {
  [rh]: sh,
  [oh]: ch,
  [ah]: uh,
  [So]: lh,
  [sh]: rh,
  [ch]: oh,
  [uh]: ah,
  [lh]: So,
};
function KP(t, e) {
  function n() {
    let I = !1;
    const ce = new et();
    let W = null;
    const J = new et(0, 0, 0, 0);
    return {
      setMask: function (he) {
        W !== he && !I && (t.colorMask(he, he, he, he), (W = he));
      },
      setLocked: function (he) {
        I = he;
      },
      setClear: function (he, fe, Oe, Tt, Xt) {
        Xt === !0 && ((he *= Tt), (fe *= Tt), (Oe *= Tt)),
          ce.set(he, fe, Oe, Tt),
          J.equals(ce) === !1 && (t.clearColor(he, fe, Oe, Tt), J.copy(ce));
      },
      reset: function () {
        (I = !1), (W = null), J.set(-1, 0, 0, 0);
      },
    };
  }
  function i() {
    let I = !1,
      ce = !1,
      W = null,
      J = null,
      he = null;
    return {
      setReversed: function (fe) {
        if (ce !== fe) {
          const Oe = e.get("EXT_clip_control");
          ce
            ? Oe.clipControlEXT(Oe.LOWER_LEFT_EXT, Oe.ZERO_TO_ONE_EXT)
            : Oe.clipControlEXT(Oe.LOWER_LEFT_EXT, Oe.NEGATIVE_ONE_TO_ONE_EXT);
          const Tt = he;
          (he = null), this.setClear(Tt);
        }
        ce = fe;
      },
      getReversed: function () {
        return ce;
      },
      setTest: function (fe) {
        fe ? ae(t.DEPTH_TEST) : Ce(t.DEPTH_TEST);
      },
      setMask: function (fe) {
        W !== fe && !I && (t.depthMask(fe), (W = fe));
      },
      setFunc: function (fe) {
        if ((ce && (fe = YP[fe]), J !== fe)) {
          switch (fe) {
            case rh:
              t.depthFunc(t.NEVER);
              break;
            case sh:
              t.depthFunc(t.ALWAYS);
              break;
            case oh:
              t.depthFunc(t.LESS);
              break;
            case So:
              t.depthFunc(t.LEQUAL);
              break;
            case ah:
              t.depthFunc(t.EQUAL);
              break;
            case lh:
              t.depthFunc(t.GEQUAL);
              break;
            case ch:
              t.depthFunc(t.GREATER);
              break;
            case uh:
              t.depthFunc(t.NOTEQUAL);
              break;
            default:
              t.depthFunc(t.LEQUAL);
          }
          J = fe;
        }
      },
      setLocked: function (fe) {
        I = fe;
      },
      setClear: function (fe) {
        he !== fe && (ce && (fe = 1 - fe), t.clearDepth(fe), (he = fe));
      },
      reset: function () {
        (I = !1), (W = null), (J = null), (he = null), (ce = !1);
      },
    };
  }
  function r() {
    let I = !1,
      ce = null,
      W = null,
      J = null,
      he = null,
      fe = null,
      Oe = null,
      Tt = null,
      Xt = null;
    return {
      setTest: function (it) {
        I || (it ? ae(t.STENCIL_TEST) : Ce(t.STENCIL_TEST));
      },
      setMask: function (it) {
        ce !== it && !I && (t.stencilMask(it), (ce = it));
      },
      setFunc: function (it, Gn, Ti) {
        (W !== it || J !== Gn || he !== Ti) &&
          (t.stencilFunc(it, Gn, Ti), (W = it), (J = Gn), (he = Ti));
      },
      setOp: function (it, Gn, Ti) {
        (fe !== it || Oe !== Gn || Tt !== Ti) &&
          (t.stencilOp(it, Gn, Ti), (fe = it), (Oe = Gn), (Tt = Ti));
      },
      setLocked: function (it) {
        I = it;
      },
      setClear: function (it) {
        Xt !== it && (t.clearStencil(it), (Xt = it));
      },
      reset: function () {
        (I = !1),
          (ce = null),
          (W = null),
          (J = null),
          (he = null),
          (fe = null),
          (Oe = null),
          (Tt = null),
          (Xt = null);
      },
    };
  }
  const s = new n(),
    o = new i(),
    a = new r(),
    l = new WeakMap(),
    c = new WeakMap();
  let u = {},
    f = {},
    d = new WeakMap(),
    p = [],
    g = null,
    v = !1,
    m = null,
    h = null,
    _ = null,
    y = null,
    x = null,
    C = null,
    R = null,
    w = new De(0, 0, 0),
    A = 0,
    E = !1,
    S = null,
    P = null,
    G = null,
    F = null,
    H = null;
  const X = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = !1,
    Z = 0;
  const L = t.getParameter(t.VERSION);
  L.indexOf("WebGL") !== -1
    ? ((Z = parseFloat(/^WebGL (\d)/.exec(L)[1])), (V = Z >= 1))
    : L.indexOf("OpenGL ES") !== -1 &&
      ((Z = parseFloat(/^OpenGL ES (\d)/.exec(L)[1])), (V = Z >= 2));
  let Y = null,
    q = {};
  const oe = t.getParameter(t.SCISSOR_BOX),
    pe = t.getParameter(t.VIEWPORT),
    Ne = new et().fromArray(oe),
    j = new et().fromArray(pe);
  function ie(I, ce, W, J) {
    const he = new Uint8Array(4),
      fe = t.createTexture();
    t.bindTexture(I, fe),
      t.texParameteri(I, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(I, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (let Oe = 0; Oe < W; Oe++)
      I === t.TEXTURE_3D || I === t.TEXTURE_2D_ARRAY
        ? t.texImage3D(ce, 0, t.RGBA, 1, 1, J, 0, t.RGBA, t.UNSIGNED_BYTE, he)
        : t.texImage2D(
            ce + Oe,
            0,
            t.RGBA,
            1,
            1,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            he
          );
    return fe;
  }
  const ge = {};
  (ge[t.TEXTURE_2D] = ie(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
    (ge[t.TEXTURE_CUBE_MAP] = ie(
      t.TEXTURE_CUBE_MAP,
      t.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (ge[t.TEXTURE_2D_ARRAY] = ie(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1)),
    (ge[t.TEXTURE_3D] = ie(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    ae(t.DEPTH_TEST),
    o.setFunc(So),
    Ye(!1),
    Ke(m_),
    ae(t.CULL_FACE),
    O(Pr);
  function ae(I) {
    u[I] !== !0 && (t.enable(I), (u[I] = !0));
  }
  function Ce(I) {
    u[I] !== !1 && (t.disable(I), (u[I] = !1));
  }
  function Ue(I, ce) {
    return f[I] !== ce
      ? (t.bindFramebuffer(I, ce),
        (f[I] = ce),
        I === t.DRAW_FRAMEBUFFER && (f[t.FRAMEBUFFER] = ce),
        I === t.FRAMEBUFFER && (f[t.DRAW_FRAMEBUFFER] = ce),
        !0)
      : !1;
  }
  function Ve(I, ce) {
    let W = p,
      J = !1;
    if (I) {
      (W = d.get(ce)), W === void 0 && ((W = []), d.set(ce, W));
      const he = I.textures;
      if (W.length !== he.length || W[0] !== t.COLOR_ATTACHMENT0) {
        for (let fe = 0, Oe = he.length; fe < Oe; fe++)
          W[fe] = t.COLOR_ATTACHMENT0 + fe;
        (W.length = he.length), (J = !0);
      }
    } else W[0] !== t.BACK && ((W[0] = t.BACK), (J = !0));
    J && t.drawBuffers(W);
  }
  function yt(I) {
    return g !== I ? (t.useProgram(I), (g = I), !0) : !1;
  }
  const $e = {
    [Qr]: t.FUNC_ADD,
    [jw]: t.FUNC_SUBTRACT,
    [Xw]: t.FUNC_REVERSE_SUBTRACT,
  };
  ($e[Yw] = t.MIN), ($e[Kw] = t.MAX);
  const At = {
    [qw]: t.ZERO,
    [$w]: t.ONE,
    [Zw]: t.SRC_COLOR,
    [nh]: t.SRC_ALPHA,
    [iA]: t.SRC_ALPHA_SATURATE,
    [tA]: t.DST_COLOR,
    [Jw]: t.DST_ALPHA,
    [Qw]: t.ONE_MINUS_SRC_COLOR,
    [ih]: t.ONE_MINUS_SRC_ALPHA,
    [nA]: t.ONE_MINUS_DST_COLOR,
    [eA]: t.ONE_MINUS_DST_ALPHA,
    [rA]: t.CONSTANT_COLOR,
    [sA]: t.ONE_MINUS_CONSTANT_COLOR,
    [oA]: t.CONSTANT_ALPHA,
    [aA]: t.ONE_MINUS_CONSTANT_ALPHA,
  };
  function O(I, ce, W, J, he, fe, Oe, Tt, Xt, it) {
    if (I === Pr) {
      v === !0 && (Ce(t.BLEND), (v = !1));
      return;
    }
    if ((v === !1 && (ae(t.BLEND), (v = !0)), I !== Ww)) {
      if (I !== m || it !== E) {
        if (
          ((h !== Qr || x !== Qr) &&
            (t.blendEquation(t.FUNC_ADD), (h = Qr), (x = Qr)),
          it)
        )
          switch (I) {
            case lo:
              t.blendFuncSeparate(
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case g_:
              t.blendFunc(t.ONE, t.ONE);
              break;
            case __:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case v_:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", I);
              break;
          }
        else
          switch (I) {
            case lo:
              t.blendFuncSeparate(
                t.SRC_ALPHA,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case g_:
              t.blendFunc(t.SRC_ALPHA, t.ONE);
              break;
            case __:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case v_:
              t.blendFunc(t.ZERO, t.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", I);
              break;
          }
        (_ = null),
          (y = null),
          (C = null),
          (R = null),
          w.set(0, 0, 0),
          (A = 0),
          (m = I),
          (E = it);
      }
      return;
    }
    (he = he || ce),
      (fe = fe || W),
      (Oe = Oe || J),
      (ce !== h || he !== x) &&
        (t.blendEquationSeparate($e[ce], $e[he]), (h = ce), (x = he)),
      (W !== _ || J !== y || fe !== C || Oe !== R) &&
        (t.blendFuncSeparate(At[W], At[J], At[fe], At[Oe]),
        (_ = W),
        (y = J),
        (C = fe),
        (R = Oe)),
      (Tt.equals(w) === !1 || Xt !== A) &&
        (t.blendColor(Tt.r, Tt.g, Tt.b, Xt), w.copy(Tt), (A = Xt)),
      (m = I),
      (E = !1);
  }
  function In(I, ce) {
    I.side === ui ? Ce(t.CULL_FACE) : ae(t.CULL_FACE);
    let W = I.side === xn;
    ce && (W = !W),
      Ye(W),
      I.blending === lo && I.transparent === !1
        ? O(Pr)
        : O(
            I.blending,
            I.blendEquation,
            I.blendSrc,
            I.blendDst,
            I.blendEquationAlpha,
            I.blendSrcAlpha,
            I.blendDstAlpha,
            I.blendColor,
            I.blendAlpha,
            I.premultipliedAlpha
          ),
      o.setFunc(I.depthFunc),
      o.setTest(I.depthTest),
      o.setMask(I.depthWrite),
      s.setMask(I.colorWrite);
    const J = I.stencilWrite;
    a.setTest(J),
      J &&
        (a.setMask(I.stencilWriteMask),
        a.setFunc(I.stencilFunc, I.stencilRef, I.stencilFuncMask),
        a.setOp(I.stencilFail, I.stencilZFail, I.stencilZPass)),
      dt(I.polygonOffset, I.polygonOffsetFactor, I.polygonOffsetUnits),
      I.alphaToCoverage === !0
        ? ae(t.SAMPLE_ALPHA_TO_COVERAGE)
        : Ce(t.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ye(I) {
    S !== I && (I ? t.frontFace(t.CW) : t.frontFace(t.CCW), (S = I));
  }
  function Ke(I) {
    I !== Hw
      ? (ae(t.CULL_FACE),
        I !== P &&
          (I === m_
            ? t.cullFace(t.BACK)
            : I === Vw
            ? t.cullFace(t.FRONT)
            : t.cullFace(t.FRONT_AND_BACK)))
      : Ce(t.CULL_FACE),
      (P = I);
  }
  function be(I) {
    I !== G && (V && t.lineWidth(I), (G = I));
  }
  function dt(I, ce, W) {
    I
      ? (ae(t.POLYGON_OFFSET_FILL),
        (F !== ce || H !== W) && (t.polygonOffset(ce, W), (F = ce), (H = W)))
      : Ce(t.POLYGON_OFFSET_FILL);
  }
  function Ae(I) {
    I ? ae(t.SCISSOR_TEST) : Ce(t.SCISSOR_TEST);
  }
  function b(I) {
    I === void 0 && (I = t.TEXTURE0 + X - 1),
      Y !== I && (t.activeTexture(I), (Y = I));
  }
  function M(I, ce, W) {
    W === void 0 && (Y === null ? (W = t.TEXTURE0 + X - 1) : (W = Y));
    let J = q[W];
    J === void 0 && ((J = { type: void 0, texture: void 0 }), (q[W] = J)),
      (J.type !== I || J.texture !== ce) &&
        (Y !== W && (t.activeTexture(W), (Y = W)),
        t.bindTexture(I, ce || ge[I]),
        (J.type = I),
        (J.texture = ce));
  }
  function k() {
    const I = q[Y];
    I !== void 0 &&
      I.type !== void 0 &&
      (t.bindTexture(I.type, null), (I.type = void 0), (I.texture = void 0));
  }
  function Q() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function ee() {
    try {
      t.compressedTexImage3D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function $() {
    try {
      t.texSubImage2D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function Te() {
    try {
      t.texSubImage3D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function ue() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function _e() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function Ze() {
    try {
      t.texStorage2D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function re() {
    try {
      t.texStorage3D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function ve() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function Re() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (I) {
      console.error("THREE.WebGLState:", I);
    }
  }
  function Pe(I) {
    Ne.equals(I) === !1 && (t.scissor(I.x, I.y, I.z, I.w), Ne.copy(I));
  }
  function ye(I) {
    j.equals(I) === !1 && (t.viewport(I.x, I.y, I.z, I.w), j.copy(I));
  }
  function qe(I, ce) {
    let W = c.get(ce);
    W === void 0 && ((W = new WeakMap()), c.set(ce, W));
    let J = W.get(I);
    J === void 0 && ((J = t.getUniformBlockIndex(ce, I.name)), W.set(I, J));
  }
  function ze(I, ce) {
    const J = c.get(ce).get(I);
    l.get(ce) !== J &&
      (t.uniformBlockBinding(ce, J, I.__bindingPointIndex), l.set(ce, J));
  }
  function ct() {
    t.disable(t.BLEND),
      t.disable(t.CULL_FACE),
      t.disable(t.DEPTH_TEST),
      t.disable(t.POLYGON_OFFSET_FILL),
      t.disable(t.SCISSOR_TEST),
      t.disable(t.STENCIL_TEST),
      t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
      t.blendEquation(t.FUNC_ADD),
      t.blendFunc(t.ONE, t.ZERO),
      t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
      t.blendColor(0, 0, 0, 0),
      t.colorMask(!0, !0, !0, !0),
      t.clearColor(0, 0, 0, 0),
      t.depthMask(!0),
      t.depthFunc(t.LESS),
      o.setReversed(!1),
      t.clearDepth(1),
      t.stencilMask(4294967295),
      t.stencilFunc(t.ALWAYS, 0, 4294967295),
      t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
      t.clearStencil(0),
      t.cullFace(t.BACK),
      t.frontFace(t.CCW),
      t.polygonOffset(0, 0),
      t.activeTexture(t.TEXTURE0),
      t.bindFramebuffer(t.FRAMEBUFFER, null),
      t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
      t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
      t.useProgram(null),
      t.lineWidth(1),
      t.scissor(0, 0, t.canvas.width, t.canvas.height),
      t.viewport(0, 0, t.canvas.width, t.canvas.height),
      (u = {}),
      (Y = null),
      (q = {}),
      (f = {}),
      (d = new WeakMap()),
      (p = []),
      (g = null),
      (v = !1),
      (m = null),
      (h = null),
      (_ = null),
      (y = null),
      (x = null),
      (C = null),
      (R = null),
      (w = new De(0, 0, 0)),
      (A = 0),
      (E = !1),
      (S = null),
      (P = null),
      (G = null),
      (F = null),
      (H = null),
      Ne.set(0, 0, t.canvas.width, t.canvas.height),
      j.set(0, 0, t.canvas.width, t.canvas.height),
      s.reset(),
      o.reset(),
      a.reset();
  }
  return {
    buffers: { color: s, depth: o, stencil: a },
    enable: ae,
    disable: Ce,
    bindFramebuffer: Ue,
    drawBuffers: Ve,
    useProgram: yt,
    setBlending: O,
    setMaterial: In,
    setFlipSided: Ye,
    setCullFace: Ke,
    setLineWidth: be,
    setPolygonOffset: dt,
    setScissorTest: Ae,
    activeTexture: b,
    bindTexture: M,
    unbindTexture: k,
    compressedTexImage2D: Q,
    compressedTexImage3D: ee,
    texImage2D: ve,
    texImage3D: Re,
    updateUBOMapping: qe,
    uniformBlockBinding: ze,
    texStorage2D: Ze,
    texStorage3D: re,
    texSubImage2D: $,
    texSubImage3D: Te,
    compressedTexSubImage2D: ue,
    compressedTexSubImage3D: _e,
    scissor: Pe,
    viewport: ye,
    reset: ct,
  };
}
function g0(t, e, n, i) {
  const r = qP(i);
  switch (n) {
    case Kx:
      return t * e;
    case $x:
      return t * e;
    case Zx:
      return t * e * 2;
    case tm:
      return ((t * e) / r.components) * r.byteLength;
    case nm:
      return ((t * e) / r.components) * r.byteLength;
    case Qx:
      return ((t * e * 2) / r.components) * r.byteLength;
    case im:
      return ((t * e * 2) / r.components) * r.byteLength;
    case qx:
      return ((t * e * 3) / r.components) * r.byteLength;
    case Bn:
      return ((t * e * 4) / r.components) * r.byteLength;
    case rm:
      return ((t * e * 4) / r.components) * r.byteLength;
    case _c:
    case vc:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case yc:
    case xc:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case hh:
    case mh:
      return (Math.max(t, 16) * Math.max(e, 8)) / 4;
    case dh:
    case ph:
      return (Math.max(t, 8) * Math.max(e, 8)) / 2;
    case gh:
    case _h:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case vh:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case yh:
      return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case xh:
      return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Sh:
      return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Mh:
      return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Eh:
      return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Th:
      return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case wh:
      return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Ah:
      return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case bh:
      return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Rh:
      return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Ch:
      return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Ph:
      return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Lh:
      return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Ih:
      return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Sc:
    case Dh:
    case Nh:
      return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
    case Jx:
    case Uh:
      return Math.ceil(t / 4) * Math.ceil(e / 4) * 8;
    case Oh:
    case Fh:
      return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${n} format.`);
}
function qP(t) {
  switch (t) {
    case Qi:
    case jx:
      return { byteLength: 1, components: 1 };
    case ja:
    case Xx:
    case zi:
      return { byteLength: 2, components: 1 };
    case Jp:
    case em:
      return { byteLength: 2, components: 4 };
    case ms:
    case Qp:
    case gn:
      return { byteLength: 4, components: 1 };
    case Yx:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${t}.`);
}
function $P(t, e, n, i, r, s, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new Le(),
    u = new WeakMap();
  let f;
  const d = new WeakMap();
  let p = !1;
  try {
    p =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function g(b, M) {
    return p ? new OffscreenCanvas(b, M) : Ka("canvas");
  }
  function v(b, M, k) {
    let Q = 1;
    const ee = Ae(b);
    if (
      ((ee.width > k || ee.height > k) &&
        (Q = k / Math.max(ee.width, ee.height)),
      Q < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && b instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && b instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && b instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && b instanceof VideoFrame)
      ) {
        const $ = Math.floor(Q * ee.width),
          Te = Math.floor(Q * ee.height);
        f === void 0 && (f = g($, Te));
        const ue = M ? g($, Te) : f;
        return (
          (ue.width = $),
          (ue.height = Te),
          ue.getContext("2d").drawImage(b, 0, 0, $, Te),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              ee.width +
              "x" +
              ee.height +
              ") to (" +
              $ +
              "x" +
              Te +
              ")."
          ),
          ue
        );
      } else
        return (
          "data" in b &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                ee.width +
                "x" +
                ee.height +
                ")."
            ),
          b
        );
    return b;
  }
  function m(b) {
    return b.generateMipmaps;
  }
  function h(b) {
    t.generateMipmap(b);
  }
  function _(b) {
    return b.isWebGLCubeRenderTarget
      ? t.TEXTURE_CUBE_MAP
      : b.isWebGL3DRenderTarget
      ? t.TEXTURE_3D
      : b.isWebGLArrayRenderTarget || b.isCompressedArrayTexture
      ? t.TEXTURE_2D_ARRAY
      : t.TEXTURE_2D;
  }
  function y(b, M, k, Q, ee = !1) {
    if (b !== null) {
      if (t[b] !== void 0) return t[b];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          b +
          "'"
      );
    }
    let $ = M;
    if (
      (M === t.RED &&
        (k === t.FLOAT && ($ = t.R32F),
        k === t.HALF_FLOAT && ($ = t.R16F),
        k === t.UNSIGNED_BYTE && ($ = t.R8)),
      M === t.RED_INTEGER &&
        (k === t.UNSIGNED_BYTE && ($ = t.R8UI),
        k === t.UNSIGNED_SHORT && ($ = t.R16UI),
        k === t.UNSIGNED_INT && ($ = t.R32UI),
        k === t.BYTE && ($ = t.R8I),
        k === t.SHORT && ($ = t.R16I),
        k === t.INT && ($ = t.R32I)),
      M === t.RG &&
        (k === t.FLOAT && ($ = t.RG32F),
        k === t.HALF_FLOAT && ($ = t.RG16F),
        k === t.UNSIGNED_BYTE && ($ = t.RG8)),
      M === t.RG_INTEGER &&
        (k === t.UNSIGNED_BYTE && ($ = t.RG8UI),
        k === t.UNSIGNED_SHORT && ($ = t.RG16UI),
        k === t.UNSIGNED_INT && ($ = t.RG32UI),
        k === t.BYTE && ($ = t.RG8I),
        k === t.SHORT && ($ = t.RG16I),
        k === t.INT && ($ = t.RG32I)),
      M === t.RGB_INTEGER &&
        (k === t.UNSIGNED_BYTE && ($ = t.RGB8UI),
        k === t.UNSIGNED_SHORT && ($ = t.RGB16UI),
        k === t.UNSIGNED_INT && ($ = t.RGB32UI),
        k === t.BYTE && ($ = t.RGB8I),
        k === t.SHORT && ($ = t.RGB16I),
        k === t.INT && ($ = t.RGB32I)),
      M === t.RGBA_INTEGER &&
        (k === t.UNSIGNED_BYTE && ($ = t.RGBA8UI),
        k === t.UNSIGNED_SHORT && ($ = t.RGBA16UI),
        k === t.UNSIGNED_INT && ($ = t.RGBA32UI),
        k === t.BYTE && ($ = t.RGBA8I),
        k === t.SHORT && ($ = t.RGBA16I),
        k === t.INT && ($ = t.RGBA32I)),
      M === t.RGB && k === t.UNSIGNED_INT_5_9_9_9_REV && ($ = t.RGB9_E5),
      M === t.RGBA)
    ) {
      const Te = ee ? Eu : Xe.getTransfer(Q);
      k === t.FLOAT && ($ = t.RGBA32F),
        k === t.HALF_FLOAT && ($ = t.RGBA16F),
        k === t.UNSIGNED_BYTE && ($ = Te === at ? t.SRGB8_ALPHA8 : t.RGBA8),
        k === t.UNSIGNED_SHORT_4_4_4_4 && ($ = t.RGBA4),
        k === t.UNSIGNED_SHORT_5_5_5_1 && ($ = t.RGB5_A1);
    }
    return (
      ($ === t.R16F ||
        $ === t.R32F ||
        $ === t.RG16F ||
        $ === t.RG32F ||
        $ === t.RGBA16F ||
        $ === t.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      $
    );
  }
  function x(b, M) {
    let k;
    return (
      b
        ? M === null || M === ms || M === wo
          ? (k = t.DEPTH24_STENCIL8)
          : M === gn
          ? (k = t.DEPTH32F_STENCIL8)
          : M === ja &&
            ((k = t.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : M === null || M === ms || M === wo
        ? (k = t.DEPTH_COMPONENT24)
        : M === gn
        ? (k = t.DEPTH_COMPONENT32F)
        : M === ja && (k = t.DEPTH_COMPONENT16),
      k
    );
  }
  function C(b, M) {
    return m(b) === !0 ||
      (b.isFramebufferTexture && b.minFilter !== ln && b.minFilter !== kt)
      ? Math.log2(Math.max(M.width, M.height)) + 1
      : b.mipmaps !== void 0 && b.mipmaps.length > 0
      ? b.mipmaps.length
      : b.isCompressedTexture && Array.isArray(b.image)
      ? M.mipmaps.length
      : 1;
  }
  function R(b) {
    const M = b.target;
    M.removeEventListener("dispose", R), A(M), M.isVideoTexture && u.delete(M);
  }
  function w(b) {
    const M = b.target;
    M.removeEventListener("dispose", w), S(M);
  }
  function A(b) {
    const M = i.get(b);
    if (M.__webglInit === void 0) return;
    const k = b.source,
      Q = d.get(k);
    if (Q) {
      const ee = Q[M.__cacheKey];
      ee.usedTimes--,
        ee.usedTimes === 0 && E(b),
        Object.keys(Q).length === 0 && d.delete(k);
    }
    i.remove(b);
  }
  function E(b) {
    const M = i.get(b);
    t.deleteTexture(M.__webglTexture);
    const k = b.source,
      Q = d.get(k);
    delete Q[M.__cacheKey], o.memory.textures--;
  }
  function S(b) {
    const M = i.get(b);
    if (
      (b.depthTexture && (b.depthTexture.dispose(), i.remove(b.depthTexture)),
      b.isWebGLCubeRenderTarget)
    )
      for (let Q = 0; Q < 6; Q++) {
        if (Array.isArray(M.__webglFramebuffer[Q]))
          for (let ee = 0; ee < M.__webglFramebuffer[Q].length; ee++)
            t.deleteFramebuffer(M.__webglFramebuffer[Q][ee]);
        else t.deleteFramebuffer(M.__webglFramebuffer[Q]);
        M.__webglDepthbuffer && t.deleteRenderbuffer(M.__webglDepthbuffer[Q]);
      }
    else {
      if (Array.isArray(M.__webglFramebuffer))
        for (let Q = 0; Q < M.__webglFramebuffer.length; Q++)
          t.deleteFramebuffer(M.__webglFramebuffer[Q]);
      else t.deleteFramebuffer(M.__webglFramebuffer);
      if (
        (M.__webglDepthbuffer && t.deleteRenderbuffer(M.__webglDepthbuffer),
        M.__webglMultisampledFramebuffer &&
          t.deleteFramebuffer(M.__webglMultisampledFramebuffer),
        M.__webglColorRenderbuffer)
      )
        for (let Q = 0; Q < M.__webglColorRenderbuffer.length; Q++)
          M.__webglColorRenderbuffer[Q] &&
            t.deleteRenderbuffer(M.__webglColorRenderbuffer[Q]);
      M.__webglDepthRenderbuffer &&
        t.deleteRenderbuffer(M.__webglDepthRenderbuffer);
    }
    const k = b.textures;
    for (let Q = 0, ee = k.length; Q < ee; Q++) {
      const $ = i.get(k[Q]);
      $.__webglTexture &&
        (t.deleteTexture($.__webglTexture), o.memory.textures--),
        i.remove(k[Q]);
    }
    i.remove(b);
  }
  let P = 0;
  function G() {
    P = 0;
  }
  function F() {
    const b = P;
    return (
      b >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            b +
            " texture units while this GPU supports only " +
            r.maxTextures
        ),
      (P += 1),
      b
    );
  }
  function H(b) {
    const M = [];
    return (
      M.push(b.wrapS),
      M.push(b.wrapT),
      M.push(b.wrapR || 0),
      M.push(b.magFilter),
      M.push(b.minFilter),
      M.push(b.anisotropy),
      M.push(b.internalFormat),
      M.push(b.format),
      M.push(b.type),
      M.push(b.generateMipmaps),
      M.push(b.premultiplyAlpha),
      M.push(b.flipY),
      M.push(b.unpackAlignment),
      M.push(b.colorSpace),
      M.join()
    );
  }
  function X(b, M) {
    const k = i.get(b);
    if (
      (b.isVideoTexture && be(b),
      b.isRenderTargetTexture === !1 &&
        b.version > 0 &&
        k.__version !== b.version)
    ) {
      const Q = b.image;
      if (Q === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Q.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        j(k, b, M);
        return;
      }
    }
    n.bindTexture(t.TEXTURE_2D, k.__webglTexture, t.TEXTURE0 + M);
  }
  function V(b, M) {
    const k = i.get(b);
    if (b.version > 0 && k.__version !== b.version) {
      j(k, b, M);
      return;
    }
    n.bindTexture(t.TEXTURE_2D_ARRAY, k.__webglTexture, t.TEXTURE0 + M);
  }
  function Z(b, M) {
    const k = i.get(b);
    if (b.version > 0 && k.__version !== b.version) {
      j(k, b, M);
      return;
    }
    n.bindTexture(t.TEXTURE_3D, k.__webglTexture, t.TEXTURE0 + M);
  }
  function L(b, M) {
    const k = i.get(b);
    if (b.version > 0 && k.__version !== b.version) {
      ie(k, b, M);
      return;
    }
    n.bindTexture(t.TEXTURE_CUBE_MAP, k.__webglTexture, t.TEXTURE0 + M);
  }
  const Y = { [To]: t.REPEAT, [hi]: t.CLAMP_TO_EDGE, [Zc]: t.MIRRORED_REPEAT },
    q = {
      [ln]: t.NEAREST,
      [Wx]: t.NEAREST_MIPMAP_NEAREST,
      [ca]: t.NEAREST_MIPMAP_LINEAR,
      [kt]: t.LINEAR,
      [gc]: t.LINEAR_MIPMAP_NEAREST,
      [pi]: t.LINEAR_MIPMAP_LINEAR,
    },
    oe = {
      [EA]: t.NEVER,
      [CA]: t.ALWAYS,
      [TA]: t.LESS,
      [nS]: t.LEQUAL,
      [wA]: t.EQUAL,
      [RA]: t.GEQUAL,
      [AA]: t.GREATER,
      [bA]: t.NOTEQUAL,
    };
  function pe(b, M) {
    if (
      (M.type === gn &&
        e.has("OES_texture_float_linear") === !1 &&
        (M.magFilter === kt ||
          M.magFilter === gc ||
          M.magFilter === ca ||
          M.magFilter === pi ||
          M.minFilter === kt ||
          M.minFilter === gc ||
          M.minFilter === ca ||
          M.minFilter === pi) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      t.texParameteri(b, t.TEXTURE_WRAP_S, Y[M.wrapS]),
      t.texParameteri(b, t.TEXTURE_WRAP_T, Y[M.wrapT]),
      (b === t.TEXTURE_3D || b === t.TEXTURE_2D_ARRAY) &&
        t.texParameteri(b, t.TEXTURE_WRAP_R, Y[M.wrapR]),
      t.texParameteri(b, t.TEXTURE_MAG_FILTER, q[M.magFilter]),
      t.texParameteri(b, t.TEXTURE_MIN_FILTER, q[M.minFilter]),
      M.compareFunction &&
        (t.texParameteri(b, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri(b, t.TEXTURE_COMPARE_FUNC, oe[M.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        M.magFilter === ln ||
        (M.minFilter !== ca && M.minFilter !== pi) ||
        (M.type === gn && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (M.anisotropy > 1 || i.get(M).__currentAnisotropy) {
        const k = e.get("EXT_texture_filter_anisotropic");
        t.texParameterf(
          b,
          k.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(M.anisotropy, r.getMaxAnisotropy())
        ),
          (i.get(M).__currentAnisotropy = M.anisotropy);
      }
    }
  }
  function Ne(b, M) {
    let k = !1;
    b.__webglInit === void 0 &&
      ((b.__webglInit = !0), M.addEventListener("dispose", R));
    const Q = M.source;
    let ee = d.get(Q);
    ee === void 0 && ((ee = {}), d.set(Q, ee));
    const $ = H(M);
    if ($ !== b.__cacheKey) {
      ee[$] === void 0 &&
        ((ee[$] = { texture: t.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (k = !0)),
        ee[$].usedTimes++;
      const Te = ee[b.__cacheKey];
      Te !== void 0 &&
        (ee[b.__cacheKey].usedTimes--, Te.usedTimes === 0 && E(M)),
        (b.__cacheKey = $),
        (b.__webglTexture = ee[$].texture);
    }
    return k;
  }
  function j(b, M, k) {
    let Q = t.TEXTURE_2D;
    (M.isDataArrayTexture || M.isCompressedArrayTexture) &&
      (Q = t.TEXTURE_2D_ARRAY),
      M.isData3DTexture && (Q = t.TEXTURE_3D);
    const ee = Ne(b, M),
      $ = M.source;
    n.bindTexture(Q, b.__webglTexture, t.TEXTURE0 + k);
    const Te = i.get($);
    if ($.version !== Te.__version || ee === !0) {
      n.activeTexture(t.TEXTURE0 + k);
      const ue = Xe.getPrimaries(Xe.workingColorSpace),
        _e = M.colorSpace === vr ? null : Xe.getPrimaries(M.colorSpace),
        Ze =
          M.colorSpace === vr || ue === _e ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, M.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, M.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ze);
      let re = v(M.image, !1, r.maxTextureSize);
      re = dt(M, re);
      const ve = s.convert(M.format, M.colorSpace),
        Re = s.convert(M.type);
      let Pe = y(M.internalFormat, ve, Re, M.colorSpace, M.isVideoTexture);
      pe(Q, M);
      let ye;
      const qe = M.mipmaps,
        ze = M.isVideoTexture !== !0,
        ct = Te.__version === void 0 || ee === !0,
        I = $.dataReady,
        ce = C(M, re);
      if (M.isDepthTexture)
        (Pe = x(M.format === Ao, M.type)),
          ct &&
            (ze
              ? n.texStorage2D(t.TEXTURE_2D, 1, Pe, re.width, re.height)
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  Pe,
                  re.width,
                  re.height,
                  0,
                  ve,
                  Re,
                  null
                ));
      else if (M.isDataTexture)
        if (qe.length > 0) {
          ze &&
            ct &&
            n.texStorage2D(t.TEXTURE_2D, ce, Pe, qe[0].width, qe[0].height);
          for (let W = 0, J = qe.length; W < J; W++)
            (ye = qe[W]),
              ze
                ? I &&
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    W,
                    0,
                    0,
                    ye.width,
                    ye.height,
                    ve,
                    Re,
                    ye.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    W,
                    Pe,
                    ye.width,
                    ye.height,
                    0,
                    ve,
                    Re,
                    ye.data
                  );
          M.generateMipmaps = !1;
        } else
          ze
            ? (ct && n.texStorage2D(t.TEXTURE_2D, ce, Pe, re.width, re.height),
              I &&
                n.texSubImage2D(
                  t.TEXTURE_2D,
                  0,
                  0,
                  0,
                  re.width,
                  re.height,
                  ve,
                  Re,
                  re.data
                ))
            : n.texImage2D(
                t.TEXTURE_2D,
                0,
                Pe,
                re.width,
                re.height,
                0,
                ve,
                Re,
                re.data
              );
      else if (M.isCompressedTexture)
        if (M.isCompressedArrayTexture) {
          ze &&
            ct &&
            n.texStorage3D(
              t.TEXTURE_2D_ARRAY,
              ce,
              Pe,
              qe[0].width,
              qe[0].height,
              re.depth
            );
          for (let W = 0, J = qe.length; W < J; W++)
            if (((ye = qe[W]), M.format !== Bn))
              if (ve !== null)
                if (ze) {
                  if (I)
                    if (M.layerUpdates.size > 0) {
                      const he = g0(ye.width, ye.height, M.format, M.type);
                      for (const fe of M.layerUpdates) {
                        const Oe = ye.data.subarray(
                          (fe * he) / ye.data.BYTES_PER_ELEMENT,
                          ((fe + 1) * he) / ye.data.BYTES_PER_ELEMENT
                        );
                        n.compressedTexSubImage3D(
                          t.TEXTURE_2D_ARRAY,
                          W,
                          0,
                          0,
                          fe,
                          ye.width,
                          ye.height,
                          1,
                          ve,
                          Oe
                        );
                      }
                      M.clearLayerUpdates();
                    } else
                      n.compressedTexSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        W,
                        0,
                        0,
                        0,
                        ye.width,
                        ye.height,
                        re.depth,
                        ve,
                        ye.data
                      );
                } else
                  n.compressedTexImage3D(
                    t.TEXTURE_2D_ARRAY,
                    W,
                    Pe,
                    ye.width,
                    ye.height,
                    re.depth,
                    0,
                    ye.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              ze
                ? I &&
                  n.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    W,
                    0,
                    0,
                    0,
                    ye.width,
                    ye.height,
                    re.depth,
                    ve,
                    Re,
                    ye.data
                  )
                : n.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    W,
                    Pe,
                    ye.width,
                    ye.height,
                    re.depth,
                    0,
                    ve,
                    Re,
                    ye.data
                  );
        } else {
          ze &&
            ct &&
            n.texStorage2D(t.TEXTURE_2D, ce, Pe, qe[0].width, qe[0].height);
          for (let W = 0, J = qe.length; W < J; W++)
            (ye = qe[W]),
              M.format !== Bn
                ? ve !== null
                  ? ze
                    ? I &&
                      n.compressedTexSubImage2D(
                        t.TEXTURE_2D,
                        W,
                        0,
                        0,
                        ye.width,
                        ye.height,
                        ve,
                        ye.data
                      )
                    : n.compressedTexImage2D(
                        t.TEXTURE_2D,
                        W,
                        Pe,
                        ye.width,
                        ye.height,
                        0,
                        ye.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ze
                ? I &&
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    W,
                    0,
                    0,
                    ye.width,
                    ye.height,
                    ve,
                    Re,
                    ye.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    W,
                    Pe,
                    ye.width,
                    ye.height,
                    0,
                    ve,
                    Re,
                    ye.data
                  );
        }
      else if (M.isDataArrayTexture)
        if (ze) {
          if (
            (ct &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                ce,
                Pe,
                re.width,
                re.height,
                re.depth
              ),
            I)
          )
            if (M.layerUpdates.size > 0) {
              const W = g0(re.width, re.height, M.format, M.type);
              for (const J of M.layerUpdates) {
                const he = re.data.subarray(
                  (J * W) / re.data.BYTES_PER_ELEMENT,
                  ((J + 1) * W) / re.data.BYTES_PER_ELEMENT
                );
                n.texSubImage3D(
                  t.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  J,
                  re.width,
                  re.height,
                  1,
                  ve,
                  Re,
                  he
                );
              }
              M.clearLayerUpdates();
            } else
              n.texSubImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                re.width,
                re.height,
                re.depth,
                ve,
                Re,
                re.data
              );
        } else
          n.texImage3D(
            t.TEXTURE_2D_ARRAY,
            0,
            Pe,
            re.width,
            re.height,
            re.depth,
            0,
            ve,
            Re,
            re.data
          );
      else if (M.isData3DTexture)
        ze
          ? (ct &&
              n.texStorage3D(
                t.TEXTURE_3D,
                ce,
                Pe,
                re.width,
                re.height,
                re.depth
              ),
            I &&
              n.texSubImage3D(
                t.TEXTURE_3D,
                0,
                0,
                0,
                0,
                re.width,
                re.height,
                re.depth,
                ve,
                Re,
                re.data
              ))
          : n.texImage3D(
              t.TEXTURE_3D,
              0,
              Pe,
              re.width,
              re.height,
              re.depth,
              0,
              ve,
              Re,
              re.data
            );
      else if (M.isFramebufferTexture) {
        if (ct)
          if (ze) n.texStorage2D(t.TEXTURE_2D, ce, Pe, re.width, re.height);
          else {
            let W = re.width,
              J = re.height;
            for (let he = 0; he < ce; he++)
              n.texImage2D(t.TEXTURE_2D, he, Pe, W, J, 0, ve, Re, null),
                (W >>= 1),
                (J >>= 1);
          }
      } else if (qe.length > 0) {
        if (ze && ct) {
          const W = Ae(qe[0]);
          n.texStorage2D(t.TEXTURE_2D, ce, Pe, W.width, W.height);
        }
        for (let W = 0, J = qe.length; W < J; W++)
          (ye = qe[W]),
            ze
              ? I && n.texSubImage2D(t.TEXTURE_2D, W, 0, 0, ve, Re, ye)
              : n.texImage2D(t.TEXTURE_2D, W, Pe, ve, Re, ye);
        M.generateMipmaps = !1;
      } else if (ze) {
        if (ct) {
          const W = Ae(re);
          n.texStorage2D(t.TEXTURE_2D, ce, Pe, W.width, W.height);
        }
        I && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, ve, Re, re);
      } else n.texImage2D(t.TEXTURE_2D, 0, Pe, ve, Re, re);
      m(M) && h(Q), (Te.__version = $.version), M.onUpdate && M.onUpdate(M);
    }
    b.__version = M.version;
  }
  function ie(b, M, k) {
    if (M.image.length !== 6) return;
    const Q = Ne(b, M),
      ee = M.source;
    n.bindTexture(t.TEXTURE_CUBE_MAP, b.__webglTexture, t.TEXTURE0 + k);
    const $ = i.get(ee);
    if (ee.version !== $.__version || Q === !0) {
      n.activeTexture(t.TEXTURE0 + k);
      const Te = Xe.getPrimaries(Xe.workingColorSpace),
        ue = M.colorSpace === vr ? null : Xe.getPrimaries(M.colorSpace),
        _e =
          M.colorSpace === vr || Te === ue ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, M.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, M.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, _e);
      const Ze = M.isCompressedTexture || M.image[0].isCompressedTexture,
        re = M.image[0] && M.image[0].isDataTexture,
        ve = [];
      for (let J = 0; J < 6; J++)
        !Ze && !re
          ? (ve[J] = v(M.image[J], !0, r.maxCubemapSize))
          : (ve[J] = re ? M.image[J].image : M.image[J]),
          (ve[J] = dt(M, ve[J]));
      const Re = ve[0],
        Pe = s.convert(M.format, M.colorSpace),
        ye = s.convert(M.type),
        qe = y(M.internalFormat, Pe, ye, M.colorSpace),
        ze = M.isVideoTexture !== !0,
        ct = $.__version === void 0 || Q === !0,
        I = ee.dataReady;
      let ce = C(M, Re);
      pe(t.TEXTURE_CUBE_MAP, M);
      let W;
      if (Ze) {
        ze &&
          ct &&
          n.texStorage2D(t.TEXTURE_CUBE_MAP, ce, qe, Re.width, Re.height);
        for (let J = 0; J < 6; J++) {
          W = ve[J].mipmaps;
          for (let he = 0; he < W.length; he++) {
            const fe = W[he];
            M.format !== Bn
              ? Pe !== null
                ? ze
                  ? I &&
                    n.compressedTexSubImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                      he,
                      0,
                      0,
                      fe.width,
                      fe.height,
                      Pe,
                      fe.data
                    )
                  : n.compressedTexImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                      he,
                      qe,
                      fe.width,
                      fe.height,
                      0,
                      fe.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : ze
              ? I &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                  he,
                  0,
                  0,
                  fe.width,
                  fe.height,
                  Pe,
                  ye,
                  fe.data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                  he,
                  qe,
                  fe.width,
                  fe.height,
                  0,
                  Pe,
                  ye,
                  fe.data
                );
          }
        }
      } else {
        if (((W = M.mipmaps), ze && ct)) {
          W.length > 0 && ce++;
          const J = Ae(ve[0]);
          n.texStorage2D(t.TEXTURE_CUBE_MAP, ce, qe, J.width, J.height);
        }
        for (let J = 0; J < 6; J++)
          if (re) {
            ze
              ? I &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                  0,
                  0,
                  0,
                  ve[J].width,
                  ve[J].height,
                  Pe,
                  ye,
                  ve[J].data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                  0,
                  qe,
                  ve[J].width,
                  ve[J].height,
                  0,
                  Pe,
                  ye,
                  ve[J].data
                );
            for (let he = 0; he < W.length; he++) {
              const Oe = W[he].image[J].image;
              ze
                ? I &&
                  n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                    he + 1,
                    0,
                    0,
                    Oe.width,
                    Oe.height,
                    Pe,
                    ye,
                    Oe.data
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                    he + 1,
                    qe,
                    Oe.width,
                    Oe.height,
                    0,
                    Pe,
                    ye,
                    Oe.data
                  );
            }
          } else {
            ze
              ? I &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                  0,
                  0,
                  0,
                  Pe,
                  ye,
                  ve[J]
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                  0,
                  qe,
                  Pe,
                  ye,
                  ve[J]
                );
            for (let he = 0; he < W.length; he++) {
              const fe = W[he];
              ze
                ? I &&
                  n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                    he + 1,
                    0,
                    0,
                    Pe,
                    ye,
                    fe.image[J]
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + J,
                    he + 1,
                    qe,
                    Pe,
                    ye,
                    fe.image[J]
                  );
            }
          }
      }
      m(M) && h(t.TEXTURE_CUBE_MAP),
        ($.__version = ee.version),
        M.onUpdate && M.onUpdate(M);
    }
    b.__version = M.version;
  }
  function ge(b, M, k, Q, ee, $) {
    const Te = s.convert(k.format, k.colorSpace),
      ue = s.convert(k.type),
      _e = y(k.internalFormat, Te, ue, k.colorSpace),
      Ze = i.get(M),
      re = i.get(k);
    if (((re.__renderTarget = M), !Ze.__hasExternalTextures)) {
      const ve = Math.max(1, M.width >> $),
        Re = Math.max(1, M.height >> $);
      ee === t.TEXTURE_3D || ee === t.TEXTURE_2D_ARRAY
        ? n.texImage3D(ee, $, _e, ve, Re, M.depth, 0, Te, ue, null)
        : n.texImage2D(ee, $, _e, ve, Re, 0, Te, ue, null);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, b),
      Ke(M)
        ? a.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            Q,
            ee,
            re.__webglTexture,
            0,
            Ye(M)
          )
        : (ee === t.TEXTURE_2D ||
            (ee >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
              ee <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          t.framebufferTexture2D(t.FRAMEBUFFER, Q, ee, re.__webglTexture, $),
      n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function ae(b, M, k) {
    if ((t.bindRenderbuffer(t.RENDERBUFFER, b), M.depthBuffer)) {
      const Q = M.depthTexture,
        ee = Q && Q.isDepthTexture ? Q.type : null,
        $ = x(M.stencilBuffer, ee),
        Te = M.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
        ue = Ye(M);
      Ke(M)
        ? a.renderbufferStorageMultisampleEXT(
            t.RENDERBUFFER,
            ue,
            $,
            M.width,
            M.height
          )
        : k
        ? t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            ue,
            $,
            M.width,
            M.height
          )
        : t.renderbufferStorage(t.RENDERBUFFER, $, M.width, M.height),
        t.framebufferRenderbuffer(t.FRAMEBUFFER, Te, t.RENDERBUFFER, b);
    } else {
      const Q = M.textures;
      for (let ee = 0; ee < Q.length; ee++) {
        const $ = Q[ee],
          Te = s.convert($.format, $.colorSpace),
          ue = s.convert($.type),
          _e = y($.internalFormat, Te, ue, $.colorSpace),
          Ze = Ye(M);
        k && Ke(M) === !1
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              Ze,
              _e,
              M.width,
              M.height
            )
          : Ke(M)
          ? a.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              Ze,
              _e,
              M.width,
              M.height
            )
          : t.renderbufferStorage(t.RENDERBUFFER, _e, M.width, M.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function Ce(b, M) {
    if (M && M.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (n.bindFramebuffer(t.FRAMEBUFFER, b),
      !(M.depthTexture && M.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    const Q = i.get(M.depthTexture);
    (Q.__renderTarget = M),
      (!Q.__webglTexture ||
        M.depthTexture.image.width !== M.width ||
        M.depthTexture.image.height !== M.height) &&
        ((M.depthTexture.image.width = M.width),
        (M.depthTexture.image.height = M.height),
        (M.depthTexture.needsUpdate = !0)),
      X(M.depthTexture, 0);
    const ee = Q.__webglTexture,
      $ = Ye(M);
    if (M.depthTexture.format === co)
      Ke(M)
        ? a.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            ee,
            0,
            $
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            ee,
            0
          );
    else if (M.depthTexture.format === Ao)
      Ke(M)
        ? a.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            ee,
            0,
            $
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            ee,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function Ue(b) {
    const M = i.get(b),
      k = b.isWebGLCubeRenderTarget === !0;
    if (M.__boundDepthTexture !== b.depthTexture) {
      const Q = b.depthTexture;
      if ((M.__depthDisposeCallback && M.__depthDisposeCallback(), Q)) {
        const ee = () => {
          delete M.__boundDepthTexture,
            delete M.__depthDisposeCallback,
            Q.removeEventListener("dispose", ee);
        };
        Q.addEventListener("dispose", ee), (M.__depthDisposeCallback = ee);
      }
      M.__boundDepthTexture = Q;
    }
    if (b.depthTexture && !M.__autoAllocateDepthBuffer) {
      if (k)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Ce(M.__webglFramebuffer, b);
    } else if (k) {
      M.__webglDepthbuffer = [];
      for (let Q = 0; Q < 6; Q++)
        if (
          (n.bindFramebuffer(t.FRAMEBUFFER, M.__webglFramebuffer[Q]),
          M.__webglDepthbuffer[Q] === void 0)
        )
          (M.__webglDepthbuffer[Q] = t.createRenderbuffer()),
            ae(M.__webglDepthbuffer[Q], b, !1);
        else {
          const ee = b.stencilBuffer
              ? t.DEPTH_STENCIL_ATTACHMENT
              : t.DEPTH_ATTACHMENT,
            $ = M.__webglDepthbuffer[Q];
          t.bindRenderbuffer(t.RENDERBUFFER, $),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, ee, t.RENDERBUFFER, $);
        }
    } else if (
      (n.bindFramebuffer(t.FRAMEBUFFER, M.__webglFramebuffer),
      M.__webglDepthbuffer === void 0)
    )
      (M.__webglDepthbuffer = t.createRenderbuffer()),
        ae(M.__webglDepthbuffer, b, !1);
    else {
      const Q = b.stencilBuffer
          ? t.DEPTH_STENCIL_ATTACHMENT
          : t.DEPTH_ATTACHMENT,
        ee = M.__webglDepthbuffer;
      t.bindRenderbuffer(t.RENDERBUFFER, ee),
        t.framebufferRenderbuffer(t.FRAMEBUFFER, Q, t.RENDERBUFFER, ee);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function Ve(b, M, k) {
    const Q = i.get(b);
    M !== void 0 &&
      ge(
        Q.__webglFramebuffer,
        b,
        b.texture,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        0
      ),
      k !== void 0 && Ue(b);
  }
  function yt(b) {
    const M = b.texture,
      k = i.get(b),
      Q = i.get(M);
    b.addEventListener("dispose", w);
    const ee = b.textures,
      $ = b.isWebGLCubeRenderTarget === !0,
      Te = ee.length > 1;
    if (
      (Te ||
        (Q.__webglTexture === void 0 && (Q.__webglTexture = t.createTexture()),
        (Q.__version = M.version),
        o.memory.textures++),
      $)
    ) {
      k.__webglFramebuffer = [];
      for (let ue = 0; ue < 6; ue++)
        if (M.mipmaps && M.mipmaps.length > 0) {
          k.__webglFramebuffer[ue] = [];
          for (let _e = 0; _e < M.mipmaps.length; _e++)
            k.__webglFramebuffer[ue][_e] = t.createFramebuffer();
        } else k.__webglFramebuffer[ue] = t.createFramebuffer();
    } else {
      if (M.mipmaps && M.mipmaps.length > 0) {
        k.__webglFramebuffer = [];
        for (let ue = 0; ue < M.mipmaps.length; ue++)
          k.__webglFramebuffer[ue] = t.createFramebuffer();
      } else k.__webglFramebuffer = t.createFramebuffer();
      if (Te)
        for (let ue = 0, _e = ee.length; ue < _e; ue++) {
          const Ze = i.get(ee[ue]);
          Ze.__webglTexture === void 0 &&
            ((Ze.__webglTexture = t.createTexture()), o.memory.textures++);
        }
      if (b.samples > 0 && Ke(b) === !1) {
        (k.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (k.__webglColorRenderbuffer = []),
          n.bindFramebuffer(t.FRAMEBUFFER, k.__webglMultisampledFramebuffer);
        for (let ue = 0; ue < ee.length; ue++) {
          const _e = ee[ue];
          (k.__webglColorRenderbuffer[ue] = t.createRenderbuffer()),
            t.bindRenderbuffer(t.RENDERBUFFER, k.__webglColorRenderbuffer[ue]);
          const Ze = s.convert(_e.format, _e.colorSpace),
            re = s.convert(_e.type),
            ve = y(
              _e.internalFormat,
              Ze,
              re,
              _e.colorSpace,
              b.isXRRenderTarget === !0
            ),
            Re = Ye(b);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            Re,
            ve,
            b.width,
            b.height
          ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + ue,
              t.RENDERBUFFER,
              k.__webglColorRenderbuffer[ue]
            );
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null),
          b.depthBuffer &&
            ((k.__webglDepthRenderbuffer = t.createRenderbuffer()),
            ae(k.__webglDepthRenderbuffer, b, !0)),
          n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if ($) {
      n.bindTexture(t.TEXTURE_CUBE_MAP, Q.__webglTexture),
        pe(t.TEXTURE_CUBE_MAP, M);
      for (let ue = 0; ue < 6; ue++)
        if (M.mipmaps && M.mipmaps.length > 0)
          for (let _e = 0; _e < M.mipmaps.length; _e++)
            ge(
              k.__webglFramebuffer[ue][_e],
              b,
              M,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_CUBE_MAP_POSITIVE_X + ue,
              _e
            );
        else
          ge(
            k.__webglFramebuffer[ue],
            b,
            M,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_CUBE_MAP_POSITIVE_X + ue,
            0
          );
      m(M) && h(t.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (Te) {
      for (let ue = 0, _e = ee.length; ue < _e; ue++) {
        const Ze = ee[ue],
          re = i.get(Ze);
        n.bindTexture(t.TEXTURE_2D, re.__webglTexture),
          pe(t.TEXTURE_2D, Ze),
          ge(
            k.__webglFramebuffer,
            b,
            Ze,
            t.COLOR_ATTACHMENT0 + ue,
            t.TEXTURE_2D,
            0
          ),
          m(Ze) && h(t.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let ue = t.TEXTURE_2D;
      if (
        ((b.isWebGL3DRenderTarget || b.isWebGLArrayRenderTarget) &&
          (ue = b.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
        n.bindTexture(ue, Q.__webglTexture),
        pe(ue, M),
        M.mipmaps && M.mipmaps.length > 0)
      )
        for (let _e = 0; _e < M.mipmaps.length; _e++)
          ge(k.__webglFramebuffer[_e], b, M, t.COLOR_ATTACHMENT0, ue, _e);
      else ge(k.__webglFramebuffer, b, M, t.COLOR_ATTACHMENT0, ue, 0);
      m(M) && h(ue), n.unbindTexture();
    }
    b.depthBuffer && Ue(b);
  }
  function $e(b) {
    const M = b.textures;
    for (let k = 0, Q = M.length; k < Q; k++) {
      const ee = M[k];
      if (m(ee)) {
        const $ = _(b),
          Te = i.get(ee).__webglTexture;
        n.bindTexture($, Te), h($), n.unbindTexture();
      }
    }
  }
  const At = [],
    O = [];
  function In(b) {
    if (b.samples > 0) {
      if (Ke(b) === !1) {
        const M = b.textures,
          k = b.width,
          Q = b.height;
        let ee = t.COLOR_BUFFER_BIT;
        const $ = b.stencilBuffer
            ? t.DEPTH_STENCIL_ATTACHMENT
            : t.DEPTH_ATTACHMENT,
          Te = i.get(b),
          ue = M.length > 1;
        if (ue)
          for (let _e = 0; _e < M.length; _e++)
            n.bindFramebuffer(t.FRAMEBUFFER, Te.__webglMultisampledFramebuffer),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + _e,
                t.RENDERBUFFER,
                null
              ),
              n.bindFramebuffer(t.FRAMEBUFFER, Te.__webglFramebuffer),
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + _e,
                t.TEXTURE_2D,
                null,
                0
              );
        n.bindFramebuffer(
          t.READ_FRAMEBUFFER,
          Te.__webglMultisampledFramebuffer
        ),
          n.bindFramebuffer(t.DRAW_FRAMEBUFFER, Te.__webglFramebuffer);
        for (let _e = 0; _e < M.length; _e++) {
          if (
            (b.resolveDepthBuffer &&
              (b.depthBuffer && (ee |= t.DEPTH_BUFFER_BIT),
              b.stencilBuffer &&
                b.resolveStencilBuffer &&
                (ee |= t.STENCIL_BUFFER_BIT)),
            ue)
          ) {
            t.framebufferRenderbuffer(
              t.READ_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.RENDERBUFFER,
              Te.__webglColorRenderbuffer[_e]
            );
            const Ze = i.get(M[_e]).__webglTexture;
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_2D,
              Ze,
              0
            );
          }
          t.blitFramebuffer(0, 0, k, Q, 0, 0, k, Q, ee, t.NEAREST),
            l === !0 &&
              ((At.length = 0),
              (O.length = 0),
              At.push(t.COLOR_ATTACHMENT0 + _e),
              b.depthBuffer &&
                b.resolveDepthBuffer === !1 &&
                (At.push($),
                O.push($),
                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, O)),
              t.invalidateFramebuffer(t.READ_FRAMEBUFFER, At));
        }
        if (
          (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
          n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
          ue)
        )
          for (let _e = 0; _e < M.length; _e++) {
            n.bindFramebuffer(t.FRAMEBUFFER, Te.__webglMultisampledFramebuffer),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + _e,
                t.RENDERBUFFER,
                Te.__webglColorRenderbuffer[_e]
              );
            const Ze = i.get(M[_e]).__webglTexture;
            n.bindFramebuffer(t.FRAMEBUFFER, Te.__webglFramebuffer),
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + _e,
                t.TEXTURE_2D,
                Ze,
                0
              );
          }
        n.bindFramebuffer(
          t.DRAW_FRAMEBUFFER,
          Te.__webglMultisampledFramebuffer
        );
      } else if (b.depthBuffer && b.resolveDepthBuffer === !1 && l) {
        const M = b.stencilBuffer
          ? t.DEPTH_STENCIL_ATTACHMENT
          : t.DEPTH_ATTACHMENT;
        t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [M]);
      }
    }
  }
  function Ye(b) {
    return Math.min(r.maxSamples, b.samples);
  }
  function Ke(b) {
    const M = i.get(b);
    return (
      b.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      M.__useRenderToTexture !== !1
    );
  }
  function be(b) {
    const M = o.render.frame;
    u.get(b) !== M && (u.set(b, M), b.update());
  }
  function dt(b, M) {
    const k = b.colorSpace,
      Q = b.format,
      ee = b.type;
    return (
      b.isCompressedTexture === !0 ||
        b.isVideoTexture === !0 ||
        (k !== tn &&
          k !== vr &&
          (Xe.getTransfer(k) === at
            ? (Q !== Bn || ee !== Qi) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                k
              ))),
      M
    );
  }
  function Ae(b) {
    return (
      typeof HTMLImageElement < "u" && b instanceof HTMLImageElement
        ? ((c.width = b.naturalWidth || b.width),
          (c.height = b.naturalHeight || b.height))
        : typeof VideoFrame < "u" && b instanceof VideoFrame
        ? ((c.width = b.displayWidth), (c.height = b.displayHeight))
        : ((c.width = b.width), (c.height = b.height)),
      c
    );
  }
  (this.allocateTextureUnit = F),
    (this.resetTextureUnits = G),
    (this.setTexture2D = X),
    (this.setTexture2DArray = V),
    (this.setTexture3D = Z),
    (this.setTextureCube = L),
    (this.rebindTextures = Ve),
    (this.setupRenderTarget = yt),
    (this.updateRenderTargetMipmap = $e),
    (this.updateMultisampleRenderTarget = In),
    (this.setupDepthRenderbuffer = Ue),
    (this.setupFrameBufferTexture = ge),
    (this.useMultisampledRTT = Ke);
}
function ZP(t, e) {
  function n(i, r = vr) {
    let s;
    const o = Xe.getTransfer(r);
    if (i === Qi) return t.UNSIGNED_BYTE;
    if (i === Jp) return t.UNSIGNED_SHORT_4_4_4_4;
    if (i === em) return t.UNSIGNED_SHORT_5_5_5_1;
    if (i === Yx) return t.UNSIGNED_INT_5_9_9_9_REV;
    if (i === jx) return t.BYTE;
    if (i === Xx) return t.SHORT;
    if (i === ja) return t.UNSIGNED_SHORT;
    if (i === Qp) return t.INT;
    if (i === ms) return t.UNSIGNED_INT;
    if (i === gn) return t.FLOAT;
    if (i === zi) return t.HALF_FLOAT;
    if (i === Kx) return t.ALPHA;
    if (i === qx) return t.RGB;
    if (i === Bn) return t.RGBA;
    if (i === $x) return t.LUMINANCE;
    if (i === Zx) return t.LUMINANCE_ALPHA;
    if (i === co) return t.DEPTH_COMPONENT;
    if (i === Ao) return t.DEPTH_STENCIL;
    if (i === tm) return t.RED;
    if (i === nm) return t.RED_INTEGER;
    if (i === Qx) return t.RG;
    if (i === im) return t.RG_INTEGER;
    if (i === rm) return t.RGBA_INTEGER;
    if (i === _c || i === vc || i === yc || i === xc)
      if (o === at)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (i === _c) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === vc) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === yc) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === xc) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (i === _c) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === vc) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === yc) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === xc) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (i === dh || i === hh || i === ph || i === mh)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (i === dh) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === hh) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === ph) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === mh) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (i === gh || i === _h || i === vh)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (i === gh || i === _h)
          return o === at ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (i === vh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      i === yh ||
      i === xh ||
      i === Sh ||
      i === Mh ||
      i === Eh ||
      i === Th ||
      i === wh ||
      i === Ah ||
      i === bh ||
      i === Rh ||
      i === Ch ||
      i === Ph ||
      i === Lh ||
      i === Ih
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (i === yh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === xh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === Sh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === Mh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === Eh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === Th)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === wh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === Ah)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === bh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Rh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === Ch)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Ph)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === Lh)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === Ih)
          return o === at
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (i === Sc || i === Dh || i === Nh)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (i === Sc)
          return o === at
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === Dh) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === Nh) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (i === Jx || i === Uh || i === Oh || i === Fh)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (i === Sc) return s.COMPRESSED_RED_RGTC1_EXT;
        if (i === Uh) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === Oh) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Fh) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return i === wo ? t.UNSIGNED_INT_24_8 : t[i] !== void 0 ? t[i] : null;
  }
  return { convert: n };
}
class QP extends on {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ss extends Mt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const JP = { type: "move" };
class Nf {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new ss()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new ss()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new D()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new D())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new ss()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new D()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new D())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n) for (const i of e.hand.values()) this._getHandJoint(n, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, n, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const v of e.hand.values()) {
          const m = n.getJointPose(v, i),
            h = this._getHandJoint(c, v);
          m !== null &&
            (h.matrix.fromArray(m.transform.matrix),
            h.matrix.decompose(h.position, h.rotation, h.scale),
            (h.matrixWorldNeedsUpdate = !0),
            (h.jointRadius = m.radius)),
            (h.visible = m !== null);
        }
        const u = c.joints["index-finger-tip"],
          f = c.joints["thumb-tip"],
          d = u.position.distanceTo(f.position),
          p = 0.02,
          g = 0.005;
        c.inputState.pinching && d > p + g
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            d <= p - g &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = n.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((r = n.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(JP)));
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const i = new ss();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[n.jointName] = i),
        e.add(i);
    }
    return e.joints[n.jointName];
  }
}
const eL = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  tL = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class nL {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, n, i) {
    if (this.texture === null) {
      const r = new zt(),
        s = e.properties.get(r);
      (s.__webglTexture = n.texture),
        (n.depthNear != i.depthNear || n.depthFar != i.depthFar) &&
          ((this.depthNear = n.depthNear), (this.depthFar = n.depthFar)),
        (this.texture = r);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const n = e.cameras[0].viewport,
        i = new Fr({
          vertexShader: eL,
          fragmentShader: tL,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: n.z },
            depthHeight: { value: n.w },
          },
        });
      this.mesh = new An(new Tu(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class iL extends ys {
  constructor(e, n) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      c = null,
      u = null,
      f = null,
      d = null,
      p = null,
      g = null;
    const v = new nL(),
      m = n.getContextAttributes();
    let h = null,
      _ = null;
    const y = [],
      x = [],
      C = new Le();
    let R = null;
    const w = new on();
    w.viewport = new et();
    const A = new on();
    A.viewport = new et();
    const E = [w, A],
      S = new QP();
    let P = null,
      G = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (j) {
        let ie = y[j];
        return (
          ie === void 0 && ((ie = new Nf()), (y[j] = ie)),
          ie.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (j) {
        let ie = y[j];
        return (
          ie === void 0 && ((ie = new Nf()), (y[j] = ie)), ie.getGripSpace()
        );
      }),
      (this.getHand = function (j) {
        let ie = y[j];
        return (
          ie === void 0 && ((ie = new Nf()), (y[j] = ie)), ie.getHandSpace()
        );
      });
    function F(j) {
      const ie = x.indexOf(j.inputSource);
      if (ie === -1) return;
      const ge = y[ie];
      ge !== void 0 &&
        (ge.update(j.inputSource, j.frame, c || o),
        ge.dispatchEvent({ type: j.type, data: j.inputSource }));
    }
    function H() {
      r.removeEventListener("select", F),
        r.removeEventListener("selectstart", F),
        r.removeEventListener("selectend", F),
        r.removeEventListener("squeeze", F),
        r.removeEventListener("squeezestart", F),
        r.removeEventListener("squeezeend", F),
        r.removeEventListener("end", H),
        r.removeEventListener("inputsourceschange", X);
      for (let j = 0; j < y.length; j++) {
        const ie = x[j];
        ie !== null && ((x[j] = null), y[j].disconnect(ie));
      }
      (P = null),
        (G = null),
        v.reset(),
        e.setRenderTarget(h),
        (p = null),
        (d = null),
        (f = null),
        (r = null),
        (_ = null),
        Ne.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(R),
        e.setSize(C.width, C.height, !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (j) {
      (s = j),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (j) {
        (a = j),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || o;
      }),
      (this.setReferenceSpace = function (j) {
        c = j;
      }),
      (this.getBaseLayer = function () {
        return d !== null ? d : p;
      }),
      (this.getBinding = function () {
        return f;
      }),
      (this.getFrame = function () {
        return g;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (j) {
        if (((r = j), r !== null)) {
          if (
            ((h = e.getRenderTarget()),
            r.addEventListener("select", F),
            r.addEventListener("selectstart", F),
            r.addEventListener("selectend", F),
            r.addEventListener("squeeze", F),
            r.addEventListener("squeezestart", F),
            r.addEventListener("squeezeend", F),
            r.addEventListener("end", H),
            r.addEventListener("inputsourceschange", X),
            m.xrCompatible !== !0 && (await n.makeXRCompatible()),
            (R = e.getPixelRatio()),
            e.getSize(C),
            r.renderState.layers === void 0)
          ) {
            const ie = {
              antialias: m.antialias,
              alpha: !0,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: s,
            };
            (p = new XRWebGLLayer(r, n, ie)),
              r.updateRenderState({ baseLayer: p }),
              e.setPixelRatio(1),
              e.setSize(p.framebufferWidth, p.framebufferHeight, !1),
              (_ = new gs(p.framebufferWidth, p.framebufferHeight, {
                format: Bn,
                type: Qi,
                colorSpace: e.outputColorSpace,
                stencilBuffer: m.stencil,
              }));
          } else {
            let ie = null,
              ge = null,
              ae = null;
            m.depth &&
              ((ae = m.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24),
              (ie = m.stencil ? Ao : co),
              (ge = m.stencil ? wo : ms));
            const Ce = {
              colorFormat: n.RGBA8,
              depthFormat: ae,
              scaleFactor: s,
            };
            (f = new XRWebGLBinding(r, n)),
              (d = f.createProjectionLayer(Ce)),
              r.updateRenderState({ layers: [d] }),
              e.setPixelRatio(1),
              e.setSize(d.textureWidth, d.textureHeight, !1),
              (_ = new gs(d.textureWidth, d.textureHeight, {
                format: Bn,
                type: Qi,
                depthTexture: new mS(
                  d.textureWidth,
                  d.textureHeight,
                  ge,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ie
                ),
                stencilBuffer: m.stencil,
                colorSpace: e.outputColorSpace,
                samples: m.antialias ? 4 : 0,
                resolveDepthBuffer: d.ignoreDepthValues === !1,
              }));
          }
          (_.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await r.requestReferenceSpace(a)),
            Ne.setContext(r),
            Ne.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return v.getDepthTexture();
      });
    function X(j) {
      for (let ie = 0; ie < j.removed.length; ie++) {
        const ge = j.removed[ie],
          ae = x.indexOf(ge);
        ae >= 0 && ((x[ae] = null), y[ae].disconnect(ge));
      }
      for (let ie = 0; ie < j.added.length; ie++) {
        const ge = j.added[ie];
        let ae = x.indexOf(ge);
        if (ae === -1) {
          for (let Ue = 0; Ue < y.length; Ue++)
            if (Ue >= x.length) {
              x.push(ge), (ae = Ue);
              break;
            } else if (x[Ue] === null) {
              (x[Ue] = ge), (ae = Ue);
              break;
            }
          if (ae === -1) break;
        }
        const Ce = y[ae];
        Ce && Ce.connect(ge);
      }
    }
    const V = new D(),
      Z = new D();
    function L(j, ie, ge) {
      V.setFromMatrixPosition(ie.matrixWorld),
        Z.setFromMatrixPosition(ge.matrixWorld);
      const ae = V.distanceTo(Z),
        Ce = ie.projectionMatrix.elements,
        Ue = ge.projectionMatrix.elements,
        Ve = Ce[14] / (Ce[10] - 1),
        yt = Ce[14] / (Ce[10] + 1),
        $e = (Ce[9] + 1) / Ce[5],
        At = (Ce[9] - 1) / Ce[5],
        O = (Ce[8] - 1) / Ce[0],
        In = (Ue[8] + 1) / Ue[0],
        Ye = Ve * O,
        Ke = Ve * In,
        be = ae / (-O + In),
        dt = be * -O;
      if (
        (ie.matrixWorld.decompose(j.position, j.quaternion, j.scale),
        j.translateX(dt),
        j.translateZ(be),
        j.matrixWorld.compose(j.position, j.quaternion, j.scale),
        j.matrixWorldInverse.copy(j.matrixWorld).invert(),
        Ce[10] === -1)
      )
        j.projectionMatrix.copy(ie.projectionMatrix),
          j.projectionMatrixInverse.copy(ie.projectionMatrixInverse);
      else {
        const Ae = Ve + be,
          b = yt + be,
          M = Ye - dt,
          k = Ke + (ae - dt),
          Q = (($e * yt) / b) * Ae,
          ee = ((At * yt) / b) * Ae;
        j.projectionMatrix.makePerspective(M, k, Q, ee, Ae, b),
          j.projectionMatrixInverse.copy(j.projectionMatrix).invert();
      }
    }
    function Y(j, ie) {
      ie === null
        ? j.matrixWorld.copy(j.matrix)
        : j.matrixWorld.multiplyMatrices(ie.matrixWorld, j.matrix),
        j.matrixWorldInverse.copy(j.matrixWorld).invert();
    }
    this.updateCamera = function (j) {
      if (r === null) return;
      let ie = j.near,
        ge = j.far;
      v.texture !== null &&
        (v.depthNear > 0 && (ie = v.depthNear),
        v.depthFar > 0 && (ge = v.depthFar)),
        (S.near = A.near = w.near = ie),
        (S.far = A.far = w.far = ge),
        (P !== S.near || G !== S.far) &&
          (r.updateRenderState({ depthNear: S.near, depthFar: S.far }),
          (P = S.near),
          (G = S.far)),
        (w.layers.mask = j.layers.mask | 2),
        (A.layers.mask = j.layers.mask | 4),
        (S.layers.mask = w.layers.mask | A.layers.mask);
      const ae = j.parent,
        Ce = S.cameras;
      Y(S, ae);
      for (let Ue = 0; Ue < Ce.length; Ue++) Y(Ce[Ue], ae);
      Ce.length === 2
        ? L(S, w, A)
        : S.projectionMatrix.copy(w.projectionMatrix),
        q(j, S, ae);
    };
    function q(j, ie, ge) {
      ge === null
        ? j.matrix.copy(ie.matrixWorld)
        : (j.matrix.copy(ge.matrixWorld),
          j.matrix.invert(),
          j.matrix.multiply(ie.matrixWorld)),
        j.matrix.decompose(j.position, j.quaternion, j.scale),
        j.updateMatrixWorld(!0),
        j.projectionMatrix.copy(ie.projectionMatrix),
        j.projectionMatrixInverse.copy(ie.projectionMatrixInverse),
        j.isPerspectiveCamera &&
          ((j.fov = bo * 2 * Math.atan(1 / j.projectionMatrix.elements[5])),
          (j.zoom = 1));
    }
    (this.getCamera = function () {
      return S;
    }),
      (this.getFoveation = function () {
        if (!(d === null && p === null)) return l;
      }),
      (this.setFoveation = function (j) {
        (l = j),
          d !== null && (d.fixedFoveation = j),
          p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = j);
      }),
      (this.hasDepthSensing = function () {
        return v.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return v.getMesh(S);
      });
    let oe = null;
    function pe(j, ie) {
      if (((u = ie.getViewerPose(c || o)), (g = ie), u !== null)) {
        const ge = u.views;
        p !== null &&
          (e.setRenderTargetFramebuffer(_, p.framebuffer),
          e.setRenderTarget(_));
        let ae = !1;
        ge.length !== S.cameras.length && ((S.cameras.length = 0), (ae = !0));
        for (let Ue = 0; Ue < ge.length; Ue++) {
          const Ve = ge[Ue];
          let yt = null;
          if (p !== null) yt = p.getViewport(Ve);
          else {
            const At = f.getViewSubImage(d, Ve);
            (yt = At.viewport),
              Ue === 0 &&
                (e.setRenderTargetTextures(
                  _,
                  At.colorTexture,
                  d.ignoreDepthValues ? void 0 : At.depthStencilTexture
                ),
                e.setRenderTarget(_));
          }
          let $e = E[Ue];
          $e === void 0 &&
            (($e = new on()),
            $e.layers.enable(Ue),
            ($e.viewport = new et()),
            (E[Ue] = $e)),
            $e.matrix.fromArray(Ve.transform.matrix),
            $e.matrix.decompose($e.position, $e.quaternion, $e.scale),
            $e.projectionMatrix.fromArray(Ve.projectionMatrix),
            $e.projectionMatrixInverse.copy($e.projectionMatrix).invert(),
            $e.viewport.set(yt.x, yt.y, yt.width, yt.height),
            Ue === 0 &&
              (S.matrix.copy($e.matrix),
              S.matrix.decompose(S.position, S.quaternion, S.scale)),
            ae === !0 && S.cameras.push($e);
        }
        const Ce = r.enabledFeatures;
        if (Ce && Ce.includes("depth-sensing")) {
          const Ue = f.getDepthInformation(ge[0]);
          Ue && Ue.isValid && Ue.texture && v.init(e, Ue, r.renderState);
        }
      }
      for (let ge = 0; ge < y.length; ge++) {
        const ae = x[ge],
          Ce = y[ge];
        ae !== null && Ce !== void 0 && Ce.update(ae, ie, c || o);
      }
      oe && oe(j, ie),
        ie.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: ie }),
        (g = null);
    }
    const Ne = new pS();
    Ne.setAnimationLoop(pe),
      (this.setAnimationLoop = function (j) {
        oe = j;
      }),
      (this.dispose = function () {});
  }
}
const Yr = new yi(),
  rL = new Be();
function sL(t, e) {
  function n(m, h) {
    m.matrixAutoUpdate === !0 && m.updateMatrix(), h.value.copy(m.matrix);
  }
  function i(m, h) {
    h.color.getRGB(m.fogColor.value, fS(t)),
      h.isFog
        ? ((m.fogNear.value = h.near), (m.fogFar.value = h.far))
        : h.isFogExp2 && (m.fogDensity.value = h.density);
  }
  function r(m, h, _, y, x) {
    h.isMeshBasicMaterial || h.isMeshLambertMaterial
      ? s(m, h)
      : h.isMeshToonMaterial
      ? (s(m, h), f(m, h))
      : h.isMeshPhongMaterial
      ? (s(m, h), u(m, h))
      : h.isMeshStandardMaterial
      ? (s(m, h), d(m, h), h.isMeshPhysicalMaterial && p(m, h, x))
      : h.isMeshMatcapMaterial
      ? (s(m, h), g(m, h))
      : h.isMeshDepthMaterial
      ? s(m, h)
      : h.isMeshDistanceMaterial
      ? (s(m, h), v(m, h))
      : h.isMeshNormalMaterial
      ? s(m, h)
      : h.isLineBasicMaterial
      ? (o(m, h), h.isLineDashedMaterial && a(m, h))
      : h.isPointsMaterial
      ? l(m, h, _, y)
      : h.isSpriteMaterial
      ? c(m, h)
      : h.isShadowMaterial
      ? (m.color.value.copy(h.color), (m.opacity.value = h.opacity))
      : h.isShaderMaterial && (h.uniformsNeedUpdate = !1);
  }
  function s(m, h) {
    (m.opacity.value = h.opacity),
      h.color && m.diffuse.value.copy(h.color),
      h.emissive &&
        m.emissive.value.copy(h.emissive).multiplyScalar(h.emissiveIntensity),
      h.map && ((m.map.value = h.map), n(h.map, m.mapTransform)),
      h.alphaMap &&
        ((m.alphaMap.value = h.alphaMap), n(h.alphaMap, m.alphaMapTransform)),
      h.bumpMap &&
        ((m.bumpMap.value = h.bumpMap),
        n(h.bumpMap, m.bumpMapTransform),
        (m.bumpScale.value = h.bumpScale),
        h.side === xn && (m.bumpScale.value *= -1)),
      h.normalMap &&
        ((m.normalMap.value = h.normalMap),
        n(h.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(h.normalScale),
        h.side === xn && m.normalScale.value.negate()),
      h.displacementMap &&
        ((m.displacementMap.value = h.displacementMap),
        n(h.displacementMap, m.displacementMapTransform),
        (m.displacementScale.value = h.displacementScale),
        (m.displacementBias.value = h.displacementBias)),
      h.emissiveMap &&
        ((m.emissiveMap.value = h.emissiveMap),
        n(h.emissiveMap, m.emissiveMapTransform)),
      h.specularMap &&
        ((m.specularMap.value = h.specularMap),
        n(h.specularMap, m.specularMapTransform)),
      h.alphaTest > 0 && (m.alphaTest.value = h.alphaTest);
    const _ = e.get(h),
      y = _.envMap,
      x = _.envMapRotation;
    y &&
      ((m.envMap.value = y),
      Yr.copy(x),
      (Yr.x *= -1),
      (Yr.y *= -1),
      (Yr.z *= -1),
      y.isCubeTexture &&
        y.isRenderTargetTexture === !1 &&
        ((Yr.y *= -1), (Yr.z *= -1)),
      m.envMapRotation.value.setFromMatrix4(rL.makeRotationFromEuler(Yr)),
      (m.flipEnvMap.value =
        y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
      (m.reflectivity.value = h.reflectivity),
      (m.ior.value = h.ior),
      (m.refractionRatio.value = h.refractionRatio)),
      h.lightMap &&
        ((m.lightMap.value = h.lightMap),
        (m.lightMapIntensity.value = h.lightMapIntensity),
        n(h.lightMap, m.lightMapTransform)),
      h.aoMap &&
        ((m.aoMap.value = h.aoMap),
        (m.aoMapIntensity.value = h.aoMapIntensity),
        n(h.aoMap, m.aoMapTransform));
  }
  function o(m, h) {
    m.diffuse.value.copy(h.color),
      (m.opacity.value = h.opacity),
      h.map && ((m.map.value = h.map), n(h.map, m.mapTransform));
  }
  function a(m, h) {
    (m.dashSize.value = h.dashSize),
      (m.totalSize.value = h.dashSize + h.gapSize),
      (m.scale.value = h.scale);
  }
  function l(m, h, _, y) {
    m.diffuse.value.copy(h.color),
      (m.opacity.value = h.opacity),
      (m.size.value = h.size * _),
      (m.scale.value = y * 0.5),
      h.map && ((m.map.value = h.map), n(h.map, m.uvTransform)),
      h.alphaMap &&
        ((m.alphaMap.value = h.alphaMap), n(h.alphaMap, m.alphaMapTransform)),
      h.alphaTest > 0 && (m.alphaTest.value = h.alphaTest);
  }
  function c(m, h) {
    m.diffuse.value.copy(h.color),
      (m.opacity.value = h.opacity),
      (m.rotation.value = h.rotation),
      h.map && ((m.map.value = h.map), n(h.map, m.mapTransform)),
      h.alphaMap &&
        ((m.alphaMap.value = h.alphaMap), n(h.alphaMap, m.alphaMapTransform)),
      h.alphaTest > 0 && (m.alphaTest.value = h.alphaTest);
  }
  function u(m, h) {
    m.specular.value.copy(h.specular),
      (m.shininess.value = Math.max(h.shininess, 1e-4));
  }
  function f(m, h) {
    h.gradientMap && (m.gradientMap.value = h.gradientMap);
  }
  function d(m, h) {
    (m.metalness.value = h.metalness),
      h.metalnessMap &&
        ((m.metalnessMap.value = h.metalnessMap),
        n(h.metalnessMap, m.metalnessMapTransform)),
      (m.roughness.value = h.roughness),
      h.roughnessMap &&
        ((m.roughnessMap.value = h.roughnessMap),
        n(h.roughnessMap, m.roughnessMapTransform)),
      h.envMap && (m.envMapIntensity.value = h.envMapIntensity);
  }
  function p(m, h, _) {
    (m.ior.value = h.ior),
      h.sheen > 0 &&
        (m.sheenColor.value.copy(h.sheenColor).multiplyScalar(h.sheen),
        (m.sheenRoughness.value = h.sheenRoughness),
        h.sheenColorMap &&
          ((m.sheenColorMap.value = h.sheenColorMap),
          n(h.sheenColorMap, m.sheenColorMapTransform)),
        h.sheenRoughnessMap &&
          ((m.sheenRoughnessMap.value = h.sheenRoughnessMap),
          n(h.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
      h.clearcoat > 0 &&
        ((m.clearcoat.value = h.clearcoat),
        (m.clearcoatRoughness.value = h.clearcoatRoughness),
        h.clearcoatMap &&
          ((m.clearcoatMap.value = h.clearcoatMap),
          n(h.clearcoatMap, m.clearcoatMapTransform)),
        h.clearcoatRoughnessMap &&
          ((m.clearcoatRoughnessMap.value = h.clearcoatRoughnessMap),
          n(h.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        h.clearcoatNormalMap &&
          ((m.clearcoatNormalMap.value = h.clearcoatNormalMap),
          n(h.clearcoatNormalMap, m.clearcoatNormalMapTransform),
          m.clearcoatNormalScale.value.copy(h.clearcoatNormalScale),
          h.side === xn && m.clearcoatNormalScale.value.negate())),
      h.dispersion > 0 && (m.dispersion.value = h.dispersion),
      h.iridescence > 0 &&
        ((m.iridescence.value = h.iridescence),
        (m.iridescenceIOR.value = h.iridescenceIOR),
        (m.iridescenceThicknessMinimum.value = h.iridescenceThicknessRange[0]),
        (m.iridescenceThicknessMaximum.value = h.iridescenceThicknessRange[1]),
        h.iridescenceMap &&
          ((m.iridescenceMap.value = h.iridescenceMap),
          n(h.iridescenceMap, m.iridescenceMapTransform)),
        h.iridescenceThicknessMap &&
          ((m.iridescenceThicknessMap.value = h.iridescenceThicknessMap),
          n(h.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
      h.transmission > 0 &&
        ((m.transmission.value = h.transmission),
        (m.transmissionSamplerMap.value = _.texture),
        m.transmissionSamplerSize.value.set(_.width, _.height),
        h.transmissionMap &&
          ((m.transmissionMap.value = h.transmissionMap),
          n(h.transmissionMap, m.transmissionMapTransform)),
        (m.thickness.value = h.thickness),
        h.thicknessMap &&
          ((m.thicknessMap.value = h.thicknessMap),
          n(h.thicknessMap, m.thicknessMapTransform)),
        (m.attenuationDistance.value = h.attenuationDistance),
        m.attenuationColor.value.copy(h.attenuationColor)),
      h.anisotropy > 0 &&
        (m.anisotropyVector.value.set(
          h.anisotropy * Math.cos(h.anisotropyRotation),
          h.anisotropy * Math.sin(h.anisotropyRotation)
        ),
        h.anisotropyMap &&
          ((m.anisotropyMap.value = h.anisotropyMap),
          n(h.anisotropyMap, m.anisotropyMapTransform))),
      (m.specularIntensity.value = h.specularIntensity),
      m.specularColor.value.copy(h.specularColor),
      h.specularColorMap &&
        ((m.specularColorMap.value = h.specularColorMap),
        n(h.specularColorMap, m.specularColorMapTransform)),
      h.specularIntensityMap &&
        ((m.specularIntensityMap.value = h.specularIntensityMap),
        n(h.specularIntensityMap, m.specularIntensityMapTransform));
  }
  function g(m, h) {
    h.matcap && (m.matcap.value = h.matcap);
  }
  function v(m, h) {
    const _ = e.get(h).light;
    m.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
      (m.nearDistance.value = _.shadow.camera.near),
      (m.farDistance.value = _.shadow.camera.far);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function oL(t, e, n, i) {
  let r = {},
    s = {},
    o = [];
  const a = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(_, y) {
    const x = y.program;
    i.uniformBlockBinding(_, x);
  }
  function c(_, y) {
    let x = r[_.id];
    x === void 0 &&
      (g(_), (x = u(_)), (r[_.id] = x), _.addEventListener("dispose", m));
    const C = y.program;
    i.updateUBOMapping(_, C);
    const R = e.render.frame;
    s[_.id] !== R && (d(_), (s[_.id] = R));
  }
  function u(_) {
    const y = f();
    _.__bindingPointIndex = y;
    const x = t.createBuffer(),
      C = _.__size,
      R = _.usage;
    return (
      t.bindBuffer(t.UNIFORM_BUFFER, x),
      t.bufferData(t.UNIFORM_BUFFER, C, R),
      t.bindBuffer(t.UNIFORM_BUFFER, null),
      t.bindBufferBase(t.UNIFORM_BUFFER, y, x),
      x
    );
  }
  function f() {
    for (let _ = 0; _ < a; _++) if (o.indexOf(_) === -1) return o.push(_), _;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function d(_) {
    const y = r[_.id],
      x = _.uniforms,
      C = _.__cache;
    t.bindBuffer(t.UNIFORM_BUFFER, y);
    for (let R = 0, w = x.length; R < w; R++) {
      const A = Array.isArray(x[R]) ? x[R] : [x[R]];
      for (let E = 0, S = A.length; E < S; E++) {
        const P = A[E];
        if (p(P, R, E, C) === !0) {
          const G = P.__offset,
            F = Array.isArray(P.value) ? P.value : [P.value];
          let H = 0;
          for (let X = 0; X < F.length; X++) {
            const V = F[X],
              Z = v(V);
            typeof V == "number" || typeof V == "boolean"
              ? ((P.__data[0] = V),
                t.bufferSubData(t.UNIFORM_BUFFER, G + H, P.__data))
              : V.isMatrix3
              ? ((P.__data[0] = V.elements[0]),
                (P.__data[1] = V.elements[1]),
                (P.__data[2] = V.elements[2]),
                (P.__data[3] = 0),
                (P.__data[4] = V.elements[3]),
                (P.__data[5] = V.elements[4]),
                (P.__data[6] = V.elements[5]),
                (P.__data[7] = 0),
                (P.__data[8] = V.elements[6]),
                (P.__data[9] = V.elements[7]),
                (P.__data[10] = V.elements[8]),
                (P.__data[11] = 0))
              : (V.toArray(P.__data, H),
                (H += Z.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          t.bufferSubData(t.UNIFORM_BUFFER, G, P.__data);
        }
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  function p(_, y, x, C) {
    const R = _.value,
      w = y + "_" + x;
    if (C[w] === void 0)
      return (
        typeof R == "number" || typeof R == "boolean"
          ? (C[w] = R)
          : (C[w] = R.clone()),
        !0
      );
    {
      const A = C[w];
      if (typeof R == "number" || typeof R == "boolean") {
        if (A !== R) return (C[w] = R), !0;
      } else if (A.equals(R) === !1) return A.copy(R), !0;
    }
    return !1;
  }
  function g(_) {
    const y = _.uniforms;
    let x = 0;
    const C = 16;
    for (let w = 0, A = y.length; w < A; w++) {
      const E = Array.isArray(y[w]) ? y[w] : [y[w]];
      for (let S = 0, P = E.length; S < P; S++) {
        const G = E[S],
          F = Array.isArray(G.value) ? G.value : [G.value];
        for (let H = 0, X = F.length; H < X; H++) {
          const V = F[H],
            Z = v(V),
            L = x % C,
            Y = L % Z.boundary,
            q = L + Y;
          (x += Y),
            q !== 0 && C - q < Z.storage && (x += C - q),
            (G.__data = new Float32Array(
              Z.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (G.__offset = x),
            (x += Z.storage);
        }
      }
    }
    const R = x % C;
    return R > 0 && (x += C - R), (_.__size = x), (_.__cache = {}), this;
  }
  function v(_) {
    const y = { boundary: 0, storage: 0 };
    return (
      typeof _ == "number" || typeof _ == "boolean"
        ? ((y.boundary = 4), (y.storage = 4))
        : _.isVector2
        ? ((y.boundary = 8), (y.storage = 8))
        : _.isVector3 || _.isColor
        ? ((y.boundary = 16), (y.storage = 12))
        : _.isVector4
        ? ((y.boundary = 16), (y.storage = 16))
        : _.isMatrix3
        ? ((y.boundary = 48), (y.storage = 48))
        : _.isMatrix4
        ? ((y.boundary = 64), (y.storage = 64))
        : _.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            _
          ),
      y
    );
  }
  function m(_) {
    const y = _.target;
    y.removeEventListener("dispose", m);
    const x = o.indexOf(y.__bindingPointIndex);
    o.splice(x, 1), t.deleteBuffer(r[y.id]), delete r[y.id], delete s[y.id];
  }
  function h() {
    for (const _ in r) t.deleteBuffer(r[_]);
    (o = []), (r = {}), (s = {});
  }
  return { bind: l, update: c, dispose: h };
}
class aL {
  constructor(e = {}) {
    const {
      canvas: n = XA(),
      context: i = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: f = !1,
      reverseDepthBuffer: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    if (i !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        i instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      p = i.getContextAttributes().alpha;
    } else p = o;
    const g = new Uint32Array(4),
      v = new Int32Array(4);
    let m = null,
      h = null;
    const _ = [],
      y = [];
    (this.domElement = n),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Gt),
      (this.toneMapping = Lr),
      (this.toneMappingExposure = 1);
    const x = this;
    let C = !1,
      R = 0,
      w = 0,
      A = null,
      E = -1,
      S = null;
    const P = new et(),
      G = new et();
    let F = null;
    const H = new De(0);
    let X = 0,
      V = n.width,
      Z = n.height,
      L = 1,
      Y = null,
      q = null;
    const oe = new et(0, 0, V, Z),
      pe = new et(0, 0, V, Z);
    let Ne = !1;
    const j = new om();
    let ie = !1,
      ge = !1;
    const ae = new Be(),
      Ce = new Be(),
      Ue = new D(),
      Ve = new et(),
      yt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let $e = !1;
    function At() {
      return A === null ? L : 1;
    }
    let O = i;
    function In(T, N) {
      return n.getContext(T, N);
    }
    try {
      const T = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: f,
      };
      if (
        ("setAttribute" in n &&
          n.setAttribute("data-engine", `three.js r${Zp}`),
        n.addEventListener("webglcontextlost", J, !1),
        n.addEventListener("webglcontextrestored", he, !1),
        n.addEventListener("webglcontextcreationerror", fe, !1),
        O === null)
      ) {
        const N = "webgl2";
        if (((O = In(N, T)), O === null))
          throw In(N)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (T) {
      throw (console.error("THREE.WebGLRenderer: " + T.message), T);
    }
    let Ye,
      Ke,
      be,
      dt,
      Ae,
      b,
      M,
      k,
      Q,
      ee,
      $,
      Te,
      ue,
      _e,
      Ze,
      re,
      ve,
      Re,
      Pe,
      ye,
      qe,
      ze,
      ct,
      I;
    function ce() {
      (Ye = new d2(O)),
        Ye.init(),
        (ze = new ZP(O, Ye)),
        (Ke = new o2(O, Ye, e, ze)),
        (be = new KP(O, Ye)),
        Ke.reverseDepthBuffer && d && be.buffers.depth.setReversed(!0),
        (dt = new m2(O)),
        (Ae = new DP()),
        (b = new $P(O, Ye, be, Ae, Ke, ze, dt)),
        (M = new l2(x)),
        (k = new f2(x)),
        (Q = new Mb(O)),
        (ct = new r2(O, Q)),
        (ee = new h2(O, Q, dt, ct)),
        ($ = new _2(O, ee, Q, dt)),
        (Pe = new g2(O, Ke, b)),
        (re = new a2(Ae)),
        (Te = new IP(x, M, k, Ye, Ke, ct, re)),
        (ue = new sL(x, Ae)),
        (_e = new UP()),
        (Ze = new HP(Ye)),
        (Re = new i2(x, M, k, be, $, p, l)),
        (ve = new XP(x, $, Ke)),
        (I = new oL(O, dt, Ke, be)),
        (ye = new s2(O, Ye, dt)),
        (qe = new p2(O, Ye, dt)),
        (dt.programs = Te.programs),
        (x.capabilities = Ke),
        (x.extensions = Ye),
        (x.properties = Ae),
        (x.renderLists = _e),
        (x.shadowMap = ve),
        (x.state = be),
        (x.info = dt);
    }
    ce();
    const W = new iL(x, O);
    (this.xr = W),
      (this.getContext = function () {
        return O;
      }),
      (this.getContextAttributes = function () {
        return O.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const T = Ye.get("WEBGL_lose_context");
        T && T.loseContext();
      }),
      (this.forceContextRestore = function () {
        const T = Ye.get("WEBGL_lose_context");
        T && T.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return L;
      }),
      (this.setPixelRatio = function (T) {
        T !== void 0 && ((L = T), this.setSize(V, Z, !1));
      }),
      (this.getSize = function (T) {
        return T.set(V, Z);
      }),
      (this.setSize = function (T, N, B = !0) {
        if (W.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (V = T),
          (Z = N),
          (n.width = Math.floor(T * L)),
          (n.height = Math.floor(N * L)),
          B === !0 && ((n.style.width = T + "px"), (n.style.height = N + "px")),
          this.setViewport(0, 0, T, N);
      }),
      (this.getDrawingBufferSize = function (T) {
        return T.set(V * L, Z * L).floor();
      }),
      (this.setDrawingBufferSize = function (T, N, B) {
        (V = T),
          (Z = N),
          (L = B),
          (n.width = Math.floor(T * B)),
          (n.height = Math.floor(N * B)),
          this.setViewport(0, 0, T, N);
      }),
      (this.getCurrentViewport = function (T) {
        return T.copy(P);
      }),
      (this.getViewport = function (T) {
        return T.copy(oe);
      }),
      (this.setViewport = function (T, N, B, z) {
        T.isVector4 ? oe.set(T.x, T.y, T.z, T.w) : oe.set(T, N, B, z),
          be.viewport(P.copy(oe).multiplyScalar(L).round());
      }),
      (this.getScissor = function (T) {
        return T.copy(pe);
      }),
      (this.setScissor = function (T, N, B, z) {
        T.isVector4 ? pe.set(T.x, T.y, T.z, T.w) : pe.set(T, N, B, z),
          be.scissor(G.copy(pe).multiplyScalar(L).round());
      }),
      (this.getScissorTest = function () {
        return Ne;
      }),
      (this.setScissorTest = function (T) {
        be.setScissorTest((Ne = T));
      }),
      (this.setOpaqueSort = function (T) {
        Y = T;
      }),
      (this.setTransparentSort = function (T) {
        q = T;
      }),
      (this.getClearColor = function (T) {
        return T.copy(Re.getClearColor());
      }),
      (this.setClearColor = function () {
        Re.setClearColor.apply(Re, arguments);
      }),
      (this.getClearAlpha = function () {
        return Re.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Re.setClearAlpha.apply(Re, arguments);
      }),
      (this.clear = function (T = !0, N = !0, B = !0) {
        let z = 0;
        if (T) {
          let U = !1;
          if (A !== null) {
            const se = A.texture.format;
            U = se === rm || se === im || se === nm;
          }
          if (U) {
            const se = A.texture.type,
              de =
                se === Qi ||
                se === ms ||
                se === ja ||
                se === wo ||
                se === Jp ||
                se === em,
              xe = Re.getClearColor(),
              Se = Re.getClearAlpha(),
              Ie = xe.r,
              Fe = xe.g,
              Me = xe.b;
            de
              ? ((g[0] = Ie),
                (g[1] = Fe),
                (g[2] = Me),
                (g[3] = Se),
                O.clearBufferuiv(O.COLOR, 0, g))
              : ((v[0] = Ie),
                (v[1] = Fe),
                (v[2] = Me),
                (v[3] = Se),
                O.clearBufferiv(O.COLOR, 0, v));
          } else z |= O.COLOR_BUFFER_BIT;
        }
        N && (z |= O.DEPTH_BUFFER_BIT),
          B &&
            ((z |= O.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          O.clear(z);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        n.removeEventListener("webglcontextlost", J, !1),
          n.removeEventListener("webglcontextrestored", he, !1),
          n.removeEventListener("webglcontextcreationerror", fe, !1),
          _e.dispose(),
          Ze.dispose(),
          Ae.dispose(),
          M.dispose(),
          k.dispose(),
          $.dispose(),
          ct.dispose(),
          I.dispose(),
          Te.dispose(),
          W.dispose(),
          W.removeEventListener("sessionstart", xm),
          W.removeEventListener("sessionend", Sm),
          Hr.stop();
      });
    function J(T) {
      T.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (C = !0);
    }
    function he() {
      console.log("THREE.WebGLRenderer: Context Restored."), (C = !1);
      const T = dt.autoReset,
        N = ve.enabled,
        B = ve.autoUpdate,
        z = ve.needsUpdate,
        U = ve.type;
      ce(),
        (dt.autoReset = T),
        (ve.enabled = N),
        (ve.autoUpdate = B),
        (ve.needsUpdate = z),
        (ve.type = U);
    }
    function fe(T) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        T.statusMessage
      );
    }
    function Oe(T) {
      const N = T.target;
      N.removeEventListener("dispose", Oe), Tt(N);
    }
    function Tt(T) {
      Xt(T), Ae.remove(T);
    }
    function Xt(T) {
      const N = Ae.get(T).programs;
      N !== void 0 &&
        (N.forEach(function (B) {
          Te.releaseProgram(B);
        }),
        T.isShaderMaterial && Te.releaseShaderCache(T));
    }
    this.renderBufferDirect = function (T, N, B, z, U, se) {
      N === null && (N = yt);
      const de = U.isMesh && U.matrixWorld.determinant() < 0,
        xe = CS(T, N, B, z, U);
      be.setMaterial(z, de);
      let Se = B.index,
        Ie = 1;
      if (z.wireframe === !0) {
        if (((Se = ee.getWireframeAttribute(B)), Se === void 0)) return;
        Ie = 2;
      }
      const Fe = B.drawRange,
        Me = B.attributes.position;
      let Je = Fe.start * Ie,
        ut = (Fe.start + Fe.count) * Ie;
      se !== null &&
        ((Je = Math.max(Je, se.start * Ie)),
        (ut = Math.min(ut, (se.start + se.count) * Ie))),
        Se !== null
          ? ((Je = Math.max(Je, 0)), (ut = Math.min(ut, Se.count)))
          : Me != null &&
            ((Je = Math.max(Je, 0)), (ut = Math.min(ut, Me.count)));
      const ht = ut - Je;
      if (ht < 0 || ht === 1 / 0) return;
      ct.setup(U, z, xe, B, Se);
      let dn,
        tt = ye;
      if (
        (Se !== null && ((dn = Q.get(Se)), (tt = qe), tt.setIndex(dn)),
        U.isMesh)
      )
        z.wireframe === !0
          ? (be.setLineWidth(z.wireframeLinewidth * At()), tt.setMode(O.LINES))
          : tt.setMode(O.TRIANGLES);
      else if (U.isLine) {
        let we = z.linewidth;
        we === void 0 && (we = 1),
          be.setLineWidth(we * At()),
          U.isLineSegments
            ? tt.setMode(O.LINES)
            : U.isLineLoop
            ? tt.setMode(O.LINE_LOOP)
            : tt.setMode(O.LINE_STRIP);
      } else
        U.isPoints
          ? tt.setMode(O.POINTS)
          : U.isSprite && tt.setMode(O.TRIANGLES);
      if (U.isBatchedMesh)
        if (U._multiDrawInstances !== null)
          tt.renderMultiDrawInstances(
            U._multiDrawStarts,
            U._multiDrawCounts,
            U._multiDrawCount,
            U._multiDrawInstances
          );
        else if (Ye.get("WEBGL_multi_draw"))
          tt.renderMultiDraw(
            U._multiDrawStarts,
            U._multiDrawCounts,
            U._multiDrawCount
          );
        else {
          const we = U._multiDrawStarts,
            wi = U._multiDrawCounts,
            nt = U._multiDrawCount,
            Wn = Se ? Q.get(Se).bytesPerElement : 1,
            Ss = Ae.get(z).currentProgram.getUniforms();
          for (let Sn = 0; Sn < nt; Sn++)
            Ss.setValue(O, "_gl_DrawID", Sn), tt.render(we[Sn] / Wn, wi[Sn]);
        }
      else if (U.isInstancedMesh) tt.renderInstances(Je, ht, U.count);
      else if (B.isInstancedBufferGeometry) {
        const we = B._maxInstanceCount !== void 0 ? B._maxInstanceCount : 1 / 0,
          wi = Math.min(B.instanceCount, we);
        tt.renderInstances(Je, ht, wi);
      } else tt.render(Je, ht);
    };
    function it(T, N, B) {
      T.transparent === !0 && T.side === ui && T.forceSinglePass === !1
        ? ((T.side = xn),
          (T.needsUpdate = !0),
          ol(T, N, B),
          (T.side = Zi),
          (T.needsUpdate = !0),
          ol(T, N, B),
          (T.side = ui))
        : ol(T, N, B);
    }
    (this.compile = function (T, N, B = null) {
      B === null && (B = T),
        (h = Ze.get(B)),
        h.init(N),
        y.push(h),
        B.traverseVisible(function (U) {
          U.isLight &&
            U.layers.test(N.layers) &&
            (h.pushLight(U), U.castShadow && h.pushShadow(U));
        }),
        T !== B &&
          T.traverseVisible(function (U) {
            U.isLight &&
              U.layers.test(N.layers) &&
              (h.pushLight(U), U.castShadow && h.pushShadow(U));
          }),
        h.setupLights();
      const z = new Set();
      return (
        T.traverse(function (U) {
          if (!(U.isMesh || U.isPoints || U.isLine || U.isSprite)) return;
          const se = U.material;
          if (se)
            if (Array.isArray(se))
              for (let de = 0; de < se.length; de++) {
                const xe = se[de];
                it(xe, B, U), z.add(xe);
              }
            else it(se, B, U), z.add(se);
        }),
        y.pop(),
        (h = null),
        z
      );
    }),
      (this.compileAsync = function (T, N, B = null) {
        const z = this.compile(T, N, B);
        return new Promise((U) => {
          function se() {
            if (
              (z.forEach(function (de) {
                Ae.get(de).currentProgram.isReady() && z.delete(de);
              }),
              z.size === 0)
            ) {
              U(T);
              return;
            }
            setTimeout(se, 10);
          }
          Ye.get("KHR_parallel_shader_compile") !== null
            ? se()
            : setTimeout(se, 10);
        });
      });
    let Gn = null;
    function Ti(T) {
      Gn && Gn(T);
    }
    function xm() {
      Hr.stop();
    }
    function Sm() {
      Hr.start();
    }
    const Hr = new pS();
    Hr.setAnimationLoop(Ti),
      typeof self < "u" && Hr.setContext(self),
      (this.setAnimationLoop = function (T) {
        (Gn = T), W.setAnimationLoop(T), T === null ? Hr.stop() : Hr.start();
      }),
      W.addEventListener("sessionstart", xm),
      W.addEventListener("sessionend", Sm),
      (this.render = function (T, N) {
        if (N !== void 0 && N.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (C === !0) return;
        if (
          (T.matrixWorldAutoUpdate === !0 && T.updateMatrixWorld(),
          N.parent === null &&
            N.matrixWorldAutoUpdate === !0 &&
            N.updateMatrixWorld(),
          W.enabled === !0 &&
            W.isPresenting === !0 &&
            (W.cameraAutoUpdate === !0 && W.updateCamera(N),
            (N = W.getCamera())),
          T.isScene === !0 && T.onBeforeRender(x, T, N, A),
          (h = Ze.get(T, y.length)),
          h.init(N),
          y.push(h),
          Ce.multiplyMatrices(N.projectionMatrix, N.matrixWorldInverse),
          j.setFromProjectionMatrix(Ce),
          (ge = this.localClippingEnabled),
          (ie = re.init(this.clippingPlanes, ge)),
          (m = _e.get(T, _.length)),
          m.init(),
          _.push(m),
          W.enabled === !0 && W.isPresenting === !0)
        ) {
          const se = x.xr.getDepthSensingMesh();
          se !== null && Au(se, N, -1 / 0, x.sortObjects);
        }
        Au(T, N, 0, x.sortObjects),
          m.finish(),
          x.sortObjects === !0 && m.sort(Y, q),
          ($e =
            W.enabled === !1 ||
            W.isPresenting === !1 ||
            W.hasDepthSensing() === !1),
          $e && Re.addToRenderList(m, T),
          this.info.render.frame++,
          ie === !0 && re.beginShadows();
        const B = h.state.shadowsArray;
        ve.render(B, T, N),
          ie === !0 && re.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const z = m.opaque,
          U = m.transmissive;
        if ((h.setupLights(), N.isArrayCamera)) {
          const se = N.cameras;
          if (U.length > 0)
            for (let de = 0, xe = se.length; de < xe; de++) {
              const Se = se[de];
              Em(z, U, T, Se);
            }
          $e && Re.render(T);
          for (let de = 0, xe = se.length; de < xe; de++) {
            const Se = se[de];
            Mm(m, T, Se, Se.viewport);
          }
        } else U.length > 0 && Em(z, U, T, N), $e && Re.render(T), Mm(m, T, N);
        A !== null &&
          (b.updateMultisampleRenderTarget(A), b.updateRenderTargetMipmap(A)),
          T.isScene === !0 && T.onAfterRender(x, T, N),
          ct.resetDefaultState(),
          (E = -1),
          (S = null),
          y.pop(),
          y.length > 0
            ? ((h = y[y.length - 1]),
              ie === !0 && re.setGlobalState(x.clippingPlanes, h.state.camera))
            : (h = null),
          _.pop(),
          _.length > 0 ? (m = _[_.length - 1]) : (m = null);
      });
    function Au(T, N, B, z) {
      if (T.visible === !1) return;
      if (T.layers.test(N.layers)) {
        if (T.isGroup) B = T.renderOrder;
        else if (T.isLOD) T.autoUpdate === !0 && T.update(N);
        else if (T.isLight) h.pushLight(T), T.castShadow && h.pushShadow(T);
        else if (T.isSprite) {
          if (!T.frustumCulled || j.intersectsSprite(T)) {
            z && Ve.setFromMatrixPosition(T.matrixWorld).applyMatrix4(Ce);
            const de = $.update(T),
              xe = T.material;
            xe.visible && m.push(T, de, xe, B, Ve.z, null);
          }
        } else if (
          (T.isMesh || T.isLine || T.isPoints) &&
          (!T.frustumCulled || j.intersectsObject(T))
        ) {
          const de = $.update(T),
            xe = T.material;
          if (
            (z &&
              (T.boundingSphere !== void 0
                ? (T.boundingSphere === null && T.computeBoundingSphere(),
                  Ve.copy(T.boundingSphere.center))
                : (de.boundingSphere === null && de.computeBoundingSphere(),
                  Ve.copy(de.boundingSphere.center)),
              Ve.applyMatrix4(T.matrixWorld).applyMatrix4(Ce)),
            Array.isArray(xe))
          ) {
            const Se = de.groups;
            for (let Ie = 0, Fe = Se.length; Ie < Fe; Ie++) {
              const Me = Se[Ie],
                Je = xe[Me.materialIndex];
              Je && Je.visible && m.push(T, de, Je, B, Ve.z, Me);
            }
          } else xe.visible && m.push(T, de, xe, B, Ve.z, null);
        }
      }
      const se = T.children;
      for (let de = 0, xe = se.length; de < xe; de++) Au(se[de], N, B, z);
    }
    function Mm(T, N, B, z) {
      const U = T.opaque,
        se = T.transmissive,
        de = T.transparent;
      h.setupLightsView(B),
        ie === !0 && re.setGlobalState(x.clippingPlanes, B),
        z && be.viewport(P.copy(z)),
        U.length > 0 && sl(U, N, B),
        se.length > 0 && sl(se, N, B),
        de.length > 0 && sl(de, N, B),
        be.buffers.depth.setTest(!0),
        be.buffers.depth.setMask(!0),
        be.buffers.color.setMask(!0),
        be.setPolygonOffset(!1);
    }
    function Em(T, N, B, z) {
      if ((B.isScene === !0 ? B.overrideMaterial : null) !== null) return;
      h.state.transmissionRenderTarget[z.id] === void 0 &&
        (h.state.transmissionRenderTarget[z.id] = new gs(1, 1, {
          generateMipmaps: !0,
          type:
            Ye.has("EXT_color_buffer_half_float") ||
            Ye.has("EXT_color_buffer_float")
              ? zi
              : Qi,
          minFilter: pi,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Xe.workingColorSpace,
        }));
      const se = h.state.transmissionRenderTarget[z.id],
        de = z.viewport || P;
      se.setSize(de.z, de.w);
      const xe = x.getRenderTarget();
      x.setRenderTarget(se),
        x.getClearColor(H),
        (X = x.getClearAlpha()),
        X < 1 && x.setClearColor(16777215, 0.5),
        x.clear(),
        $e && Re.render(B);
      const Se = x.toneMapping;
      x.toneMapping = Lr;
      const Ie = z.viewport;
      if (
        (z.viewport !== void 0 && (z.viewport = void 0),
        h.setupLightsView(z),
        ie === !0 && re.setGlobalState(x.clippingPlanes, z),
        sl(T, B, z),
        b.updateMultisampleRenderTarget(se),
        b.updateRenderTargetMipmap(se),
        Ye.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let Fe = !1;
        for (let Me = 0, Je = N.length; Me < Je; Me++) {
          const ut = N[Me],
            ht = ut.object,
            dn = ut.geometry,
            tt = ut.material,
            we = ut.group;
          if (tt.side === ui && ht.layers.test(z.layers)) {
            const wi = tt.side;
            (tt.side = xn),
              (tt.needsUpdate = !0),
              Tm(ht, B, z, dn, tt, we),
              (tt.side = wi),
              (tt.needsUpdate = !0),
              (Fe = !0);
          }
        }
        Fe === !0 &&
          (b.updateMultisampleRenderTarget(se), b.updateRenderTargetMipmap(se));
      }
      x.setRenderTarget(xe),
        x.setClearColor(H, X),
        Ie !== void 0 && (z.viewport = Ie),
        (x.toneMapping = Se);
    }
    function sl(T, N, B) {
      const z = N.isScene === !0 ? N.overrideMaterial : null;
      for (let U = 0, se = T.length; U < se; U++) {
        const de = T[U],
          xe = de.object,
          Se = de.geometry,
          Ie = z === null ? de.material : z,
          Fe = de.group;
        xe.layers.test(B.layers) && Tm(xe, N, B, Se, Ie, Fe);
      }
    }
    function Tm(T, N, B, z, U, se) {
      T.onBeforeRender(x, N, B, z, U, se),
        T.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, T.matrixWorld),
        T.normalMatrix.getNormalMatrix(T.modelViewMatrix),
        U.onBeforeRender(x, N, B, z, T, se),
        U.transparent === !0 && U.side === ui && U.forceSinglePass === !1
          ? ((U.side = xn),
            (U.needsUpdate = !0),
            x.renderBufferDirect(B, N, z, U, T, se),
            (U.side = Zi),
            (U.needsUpdate = !0),
            x.renderBufferDirect(B, N, z, U, T, se),
            (U.side = ui))
          : x.renderBufferDirect(B, N, z, U, T, se),
        T.onAfterRender(x, N, B, z, U, se);
    }
    function ol(T, N, B) {
      N.isScene !== !0 && (N = yt);
      const z = Ae.get(T),
        U = h.state.lights,
        se = h.state.shadowsArray,
        de = U.state.version,
        xe = Te.getParameters(T, U.state, se, N, B),
        Se = Te.getProgramCacheKey(xe);
      let Ie = z.programs;
      (z.environment = T.isMeshStandardMaterial ? N.environment : null),
        (z.fog = N.fog),
        (z.envMap = (T.isMeshStandardMaterial ? k : M).get(
          T.envMap || z.environment
        )),
        (z.envMapRotation =
          z.environment !== null && T.envMap === null
            ? N.environmentRotation
            : T.envMapRotation),
        Ie === void 0 &&
          (T.addEventListener("dispose", Oe),
          (Ie = new Map()),
          (z.programs = Ie));
      let Fe = Ie.get(Se);
      if (Fe !== void 0) {
        if (z.currentProgram === Fe && z.lightsStateVersion === de)
          return Am(T, xe), Fe;
      } else
        (xe.uniforms = Te.getUniforms(T)),
          T.onBeforeCompile(xe, x),
          (Fe = Te.acquireProgram(xe, Se)),
          Ie.set(Se, Fe),
          (z.uniforms = xe.uniforms);
      const Me = z.uniforms;
      return (
        ((!T.isShaderMaterial && !T.isRawShaderMaterial) ||
          T.clipping === !0) &&
          (Me.clippingPlanes = re.uniform),
        Am(T, xe),
        (z.needsLights = LS(T)),
        (z.lightsStateVersion = de),
        z.needsLights &&
          ((Me.ambientLightColor.value = U.state.ambient),
          (Me.lightProbe.value = U.state.probe),
          (Me.directionalLights.value = U.state.directional),
          (Me.directionalLightShadows.value = U.state.directionalShadow),
          (Me.spotLights.value = U.state.spot),
          (Me.spotLightShadows.value = U.state.spotShadow),
          (Me.rectAreaLights.value = U.state.rectArea),
          (Me.ltc_1.value = U.state.rectAreaLTC1),
          (Me.ltc_2.value = U.state.rectAreaLTC2),
          (Me.pointLights.value = U.state.point),
          (Me.pointLightShadows.value = U.state.pointShadow),
          (Me.hemisphereLights.value = U.state.hemi),
          (Me.directionalShadowMap.value = U.state.directionalShadowMap),
          (Me.directionalShadowMatrix.value = U.state.directionalShadowMatrix),
          (Me.spotShadowMap.value = U.state.spotShadowMap),
          (Me.spotLightMatrix.value = U.state.spotLightMatrix),
          (Me.spotLightMap.value = U.state.spotLightMap),
          (Me.pointShadowMap.value = U.state.pointShadowMap),
          (Me.pointShadowMatrix.value = U.state.pointShadowMatrix)),
        (z.currentProgram = Fe),
        (z.uniformsList = null),
        Fe
      );
    }
    function wm(T) {
      if (T.uniformsList === null) {
        const N = T.currentProgram.getUniforms();
        T.uniformsList = Mc.seqWithValue(N.seq, T.uniforms);
      }
      return T.uniformsList;
    }
    function Am(T, N) {
      const B = Ae.get(T);
      (B.outputColorSpace = N.outputColorSpace),
        (B.batching = N.batching),
        (B.batchingColor = N.batchingColor),
        (B.instancing = N.instancing),
        (B.instancingColor = N.instancingColor),
        (B.instancingMorph = N.instancingMorph),
        (B.skinning = N.skinning),
        (B.morphTargets = N.morphTargets),
        (B.morphNormals = N.morphNormals),
        (B.morphColors = N.morphColors),
        (B.morphTargetsCount = N.morphTargetsCount),
        (B.numClippingPlanes = N.numClippingPlanes),
        (B.numIntersection = N.numClipIntersection),
        (B.vertexAlphas = N.vertexAlphas),
        (B.vertexTangents = N.vertexTangents),
        (B.toneMapping = N.toneMapping);
    }
    function CS(T, N, B, z, U) {
      N.isScene !== !0 && (N = yt), b.resetTextureUnits();
      const se = N.fog,
        de = z.isMeshStandardMaterial ? N.environment : null,
        xe =
          A === null
            ? x.outputColorSpace
            : A.isXRRenderTarget === !0
            ? A.texture.colorSpace
            : tn,
        Se = (z.isMeshStandardMaterial ? k : M).get(z.envMap || de),
        Ie =
          z.vertexColors === !0 &&
          !!B.attributes.color &&
          B.attributes.color.itemSize === 4,
        Fe = !!B.attributes.tangent && (!!z.normalMap || z.anisotropy > 0),
        Me = !!B.morphAttributes.position,
        Je = !!B.morphAttributes.normal,
        ut = !!B.morphAttributes.color;
      let ht = Lr;
      z.toneMapped &&
        (A === null || A.isXRRenderTarget === !0) &&
        (ht = x.toneMapping);
      const dn =
          B.morphAttributes.position ||
          B.morphAttributes.normal ||
          B.morphAttributes.color,
        tt = dn !== void 0 ? dn.length : 0,
        we = Ae.get(z),
        wi = h.state.lights;
      if (ie === !0 && (ge === !0 || T !== S)) {
        const Dn = T === S && z.id === E;
        re.setState(z, T, Dn);
      }
      let nt = !1;
      z.version === we.__version
        ? ((we.needsLights && we.lightsStateVersion !== wi.state.version) ||
            we.outputColorSpace !== xe ||
            (U.isBatchedMesh && we.batching === !1) ||
            (!U.isBatchedMesh && we.batching === !0) ||
            (U.isBatchedMesh &&
              we.batchingColor === !0 &&
              U.colorTexture === null) ||
            (U.isBatchedMesh &&
              we.batchingColor === !1 &&
              U.colorTexture !== null) ||
            (U.isInstancedMesh && we.instancing === !1) ||
            (!U.isInstancedMesh && we.instancing === !0) ||
            (U.isSkinnedMesh && we.skinning === !1) ||
            (!U.isSkinnedMesh && we.skinning === !0) ||
            (U.isInstancedMesh &&
              we.instancingColor === !0 &&
              U.instanceColor === null) ||
            (U.isInstancedMesh &&
              we.instancingColor === !1 &&
              U.instanceColor !== null) ||
            (U.isInstancedMesh &&
              we.instancingMorph === !0 &&
              U.morphTexture === null) ||
            (U.isInstancedMesh &&
              we.instancingMorph === !1 &&
              U.morphTexture !== null) ||
            we.envMap !== Se ||
            (z.fog === !0 && we.fog !== se) ||
            (we.numClippingPlanes !== void 0 &&
              (we.numClippingPlanes !== re.numPlanes ||
                we.numIntersection !== re.numIntersection)) ||
            we.vertexAlphas !== Ie ||
            we.vertexTangents !== Fe ||
            we.morphTargets !== Me ||
            we.morphNormals !== Je ||
            we.morphColors !== ut ||
            we.toneMapping !== ht ||
            we.morphTargetsCount !== tt) &&
          (nt = !0)
        : ((nt = !0), (we.__version = z.version));
      let Wn = we.currentProgram;
      nt === !0 && (Wn = ol(z, N, U));
      let Ss = !1,
        Sn = !1,
        Bo = !1;
      const pt = Wn.getUniforms(),
        ri = we.uniforms;
      if (
        (be.useProgram(Wn.program) && ((Ss = !0), (Sn = !0), (Bo = !0)),
        z.id !== E && ((E = z.id), (Sn = !0)),
        Ss || S !== T)
      ) {
        be.buffers.depth.getReversed()
          ? (ae.copy(T.projectionMatrix),
            KA(ae),
            qA(ae),
            pt.setValue(O, "projectionMatrix", ae))
          : pt.setValue(O, "projectionMatrix", T.projectionMatrix),
          pt.setValue(O, "viewMatrix", T.matrixWorldInverse);
        const nr = pt.map.cameraPosition;
        nr !== void 0 &&
          nr.setValue(O, Ue.setFromMatrixPosition(T.matrixWorld)),
          Ke.logarithmicDepthBuffer &&
            pt.setValue(
              O,
              "logDepthBufFC",
              2 / (Math.log(T.far + 1) / Math.LN2)
            ),
          (z.isMeshPhongMaterial ||
            z.isMeshToonMaterial ||
            z.isMeshLambertMaterial ||
            z.isMeshBasicMaterial ||
            z.isMeshStandardMaterial ||
            z.isShaderMaterial) &&
            pt.setValue(O, "isOrthographic", T.isOrthographicCamera === !0),
          S !== T && ((S = T), (Sn = !0), (Bo = !0));
      }
      if (U.isSkinnedMesh) {
        pt.setOptional(O, U, "bindMatrix"),
          pt.setOptional(O, U, "bindMatrixInverse");
        const Dn = U.skeleton;
        Dn &&
          (Dn.boneTexture === null && Dn.computeBoneTexture(),
          pt.setValue(O, "boneTexture", Dn.boneTexture, b));
      }
      U.isBatchedMesh &&
        (pt.setOptional(O, U, "batchingTexture"),
        pt.setValue(O, "batchingTexture", U._matricesTexture, b),
        pt.setOptional(O, U, "batchingIdTexture"),
        pt.setValue(O, "batchingIdTexture", U._indirectTexture, b),
        pt.setOptional(O, U, "batchingColorTexture"),
        U._colorsTexture !== null &&
          pt.setValue(O, "batchingColorTexture", U._colorsTexture, b));
      const zo = B.morphAttributes;
      if (
        ((zo.position !== void 0 ||
          zo.normal !== void 0 ||
          zo.color !== void 0) &&
          Pe.update(U, B, Wn),
        (Sn || we.receiveShadow !== U.receiveShadow) &&
          ((we.receiveShadow = U.receiveShadow),
          pt.setValue(O, "receiveShadow", U.receiveShadow)),
        z.isMeshGouraudMaterial &&
          z.envMap !== null &&
          ((ri.envMap.value = Se),
          (ri.flipEnvMap.value =
            Se.isCubeTexture && Se.isRenderTargetTexture === !1 ? -1 : 1)),
        z.isMeshStandardMaterial &&
          z.envMap === null &&
          N.environment !== null &&
          (ri.envMapIntensity.value = N.environmentIntensity),
        Sn &&
          (pt.setValue(O, "toneMappingExposure", x.toneMappingExposure),
          we.needsLights && PS(ri, Bo),
          se && z.fog === !0 && ue.refreshFogUniforms(ri, se),
          ue.refreshMaterialUniforms(
            ri,
            z,
            L,
            Z,
            h.state.transmissionRenderTarget[T.id]
          ),
          Mc.upload(O, wm(we), ri, b)),
        z.isShaderMaterial &&
          z.uniformsNeedUpdate === !0 &&
          (Mc.upload(O, wm(we), ri, b), (z.uniformsNeedUpdate = !1)),
        z.isSpriteMaterial && pt.setValue(O, "center", U.center),
        pt.setValue(O, "modelViewMatrix", U.modelViewMatrix),
        pt.setValue(O, "normalMatrix", U.normalMatrix),
        pt.setValue(O, "modelMatrix", U.matrixWorld),
        z.isShaderMaterial || z.isRawShaderMaterial)
      ) {
        const Dn = z.uniformsGroups;
        for (let nr = 0, ir = Dn.length; nr < ir; nr++) {
          const bm = Dn[nr];
          I.update(bm, Wn), I.bind(bm, Wn);
        }
      }
      return Wn;
    }
    function PS(T, N) {
      (T.ambientLightColor.needsUpdate = N),
        (T.lightProbe.needsUpdate = N),
        (T.directionalLights.needsUpdate = N),
        (T.directionalLightShadows.needsUpdate = N),
        (T.pointLights.needsUpdate = N),
        (T.pointLightShadows.needsUpdate = N),
        (T.spotLights.needsUpdate = N),
        (T.spotLightShadows.needsUpdate = N),
        (T.rectAreaLights.needsUpdate = N),
        (T.hemisphereLights.needsUpdate = N);
    }
    function LS(T) {
      return (
        T.isMeshLambertMaterial ||
        T.isMeshToonMaterial ||
        T.isMeshPhongMaterial ||
        T.isMeshStandardMaterial ||
        T.isShadowMaterial ||
        (T.isShaderMaterial && T.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return R;
    }),
      (this.getActiveMipmapLevel = function () {
        return w;
      }),
      (this.getRenderTarget = function () {
        return A;
      }),
      (this.setRenderTargetTextures = function (T, N, B) {
        (Ae.get(T.texture).__webglTexture = N),
          (Ae.get(T.depthTexture).__webglTexture = B);
        const z = Ae.get(T);
        (z.__hasExternalTextures = !0),
          (z.__autoAllocateDepthBuffer = B === void 0),
          z.__autoAllocateDepthBuffer ||
            (Ye.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (z.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (T, N) {
        const B = Ae.get(T);
        (B.__webglFramebuffer = N), (B.__useDefaultFramebuffer = N === void 0);
      }),
      (this.setRenderTarget = function (T, N = 0, B = 0) {
        (A = T), (R = N), (w = B);
        let z = !0,
          U = null,
          se = !1,
          de = !1;
        if (T) {
          const Se = Ae.get(T);
          if (Se.__useDefaultFramebuffer !== void 0)
            be.bindFramebuffer(O.FRAMEBUFFER, null), (z = !1);
          else if (Se.__webglFramebuffer === void 0) b.setupRenderTarget(T);
          else if (Se.__hasExternalTextures)
            b.rebindTextures(
              T,
              Ae.get(T.texture).__webglTexture,
              Ae.get(T.depthTexture).__webglTexture
            );
          else if (T.depthBuffer) {
            const Me = T.depthTexture;
            if (Se.__boundDepthTexture !== Me) {
              if (
                Me !== null &&
                Ae.has(Me) &&
                (T.width !== Me.image.width || T.height !== Me.image.height)
              )
                throw new Error(
                  "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
                );
              b.setupDepthRenderbuffer(T);
            }
          }
          const Ie = T.texture;
          (Ie.isData3DTexture ||
            Ie.isDataArrayTexture ||
            Ie.isCompressedArrayTexture) &&
            (de = !0);
          const Fe = Ae.get(T).__webglFramebuffer;
          T.isWebGLCubeRenderTarget
            ? (Array.isArray(Fe[N]) ? (U = Fe[N][B]) : (U = Fe[N]), (se = !0))
            : T.samples > 0 && b.useMultisampledRTT(T) === !1
            ? (U = Ae.get(T).__webglMultisampledFramebuffer)
            : Array.isArray(Fe)
            ? (U = Fe[B])
            : (U = Fe),
            P.copy(T.viewport),
            G.copy(T.scissor),
            (F = T.scissorTest);
        } else
          P.copy(oe).multiplyScalar(L).floor(),
            G.copy(pe).multiplyScalar(L).floor(),
            (F = Ne);
        if (
          (be.bindFramebuffer(O.FRAMEBUFFER, U) && z && be.drawBuffers(T, U),
          be.viewport(P),
          be.scissor(G),
          be.setScissorTest(F),
          se)
        ) {
          const Se = Ae.get(T.texture);
          O.framebufferTexture2D(
            O.FRAMEBUFFER,
            O.COLOR_ATTACHMENT0,
            O.TEXTURE_CUBE_MAP_POSITIVE_X + N,
            Se.__webglTexture,
            B
          );
        } else if (de) {
          const Se = Ae.get(T.texture),
            Ie = N || 0;
          O.framebufferTextureLayer(
            O.FRAMEBUFFER,
            O.COLOR_ATTACHMENT0,
            Se.__webglTexture,
            B || 0,
            Ie
          );
        }
        E = -1;
      }),
      (this.readRenderTargetPixels = function (T, N, B, z, U, se, de) {
        if (!(T && T.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let xe = Ae.get(T).__webglFramebuffer;
        if ((T.isWebGLCubeRenderTarget && de !== void 0 && (xe = xe[de]), xe)) {
          be.bindFramebuffer(O.FRAMEBUFFER, xe);
          try {
            const Se = T.texture,
              Ie = Se.format,
              Fe = Se.type;
            if (!Ke.textureFormatReadable(Ie)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!Ke.textureTypeReadable(Fe)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            N >= 0 &&
              N <= T.width - z &&
              B >= 0 &&
              B <= T.height - U &&
              O.readPixels(N, B, z, U, ze.convert(Ie), ze.convert(Fe), se);
          } finally {
            const Se = A !== null ? Ae.get(A).__webglFramebuffer : null;
            be.bindFramebuffer(O.FRAMEBUFFER, Se);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        T,
        N,
        B,
        z,
        U,
        se,
        de
      ) {
        if (!(T && T.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let xe = Ae.get(T).__webglFramebuffer;
        if ((T.isWebGLCubeRenderTarget && de !== void 0 && (xe = xe[de]), xe)) {
          const Se = T.texture,
            Ie = Se.format,
            Fe = Se.type;
          if (!Ke.textureFormatReadable(Ie))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
            );
          if (!Ke.textureTypeReadable(Fe))
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          if (N >= 0 && N <= T.width - z && B >= 0 && B <= T.height - U) {
            be.bindFramebuffer(O.FRAMEBUFFER, xe);
            const Me = O.createBuffer();
            O.bindBuffer(O.PIXEL_PACK_BUFFER, Me),
              O.bufferData(O.PIXEL_PACK_BUFFER, se.byteLength, O.STREAM_READ),
              O.readPixels(N, B, z, U, ze.convert(Ie), ze.convert(Fe), 0);
            const Je = A !== null ? Ae.get(A).__webglFramebuffer : null;
            be.bindFramebuffer(O.FRAMEBUFFER, Je);
            const ut = O.fenceSync(O.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              O.flush(),
              await YA(O, ut, 4),
              O.bindBuffer(O.PIXEL_PACK_BUFFER, Me),
              O.getBufferSubData(O.PIXEL_PACK_BUFFER, 0, se),
              O.deleteBuffer(Me),
              O.deleteSync(ut),
              se
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
        }
      }),
      (this.copyFramebufferToTexture = function (T, N = null, B = 0) {
        T.isTexture !== !0 &&
          (ua(
            "WebGLRenderer: copyFramebufferToTexture function signature has changed."
          ),
          (N = arguments[0] || null),
          (T = arguments[1]));
        const z = Math.pow(2, -B),
          U = Math.floor(T.image.width * z),
          se = Math.floor(T.image.height * z),
          de = N !== null ? N.x : 0,
          xe = N !== null ? N.y : 0;
        b.setTexture2D(T, 0),
          O.copyTexSubImage2D(O.TEXTURE_2D, B, 0, 0, de, xe, U, se),
          be.unbindTexture();
      }),
      (this.copyTextureToTexture = function (T, N, B = null, z = null, U = 0) {
        T.isTexture !== !0 &&
          (ua(
            "WebGLRenderer: copyTextureToTexture function signature has changed."
          ),
          (z = arguments[0] || null),
          (T = arguments[1]),
          (N = arguments[2]),
          (U = arguments[3] || 0),
          (B = null));
        let se, de, xe, Se, Ie, Fe, Me, Je, ut;
        const ht = T.isCompressedTexture ? T.mipmaps[U] : T.image;
        B !== null
          ? ((se = B.max.x - B.min.x),
            (de = B.max.y - B.min.y),
            (xe = B.isBox3 ? B.max.z - B.min.z : 1),
            (Se = B.min.x),
            (Ie = B.min.y),
            (Fe = B.isBox3 ? B.min.z : 0))
          : ((se = ht.width),
            (de = ht.height),
            (xe = ht.depth || 1),
            (Se = 0),
            (Ie = 0),
            (Fe = 0)),
          z !== null
            ? ((Me = z.x), (Je = z.y), (ut = z.z))
            : ((Me = 0), (Je = 0), (ut = 0));
        const dn = ze.convert(N.format),
          tt = ze.convert(N.type);
        let we;
        N.isData3DTexture
          ? (b.setTexture3D(N, 0), (we = O.TEXTURE_3D))
          : N.isDataArrayTexture || N.isCompressedArrayTexture
          ? (b.setTexture2DArray(N, 0), (we = O.TEXTURE_2D_ARRAY))
          : (b.setTexture2D(N, 0), (we = O.TEXTURE_2D)),
          O.pixelStorei(O.UNPACK_FLIP_Y_WEBGL, N.flipY),
          O.pixelStorei(O.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
          O.pixelStorei(O.UNPACK_ALIGNMENT, N.unpackAlignment);
        const wi = O.getParameter(O.UNPACK_ROW_LENGTH),
          nt = O.getParameter(O.UNPACK_IMAGE_HEIGHT),
          Wn = O.getParameter(O.UNPACK_SKIP_PIXELS),
          Ss = O.getParameter(O.UNPACK_SKIP_ROWS),
          Sn = O.getParameter(O.UNPACK_SKIP_IMAGES);
        O.pixelStorei(O.UNPACK_ROW_LENGTH, ht.width),
          O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, ht.height),
          O.pixelStorei(O.UNPACK_SKIP_PIXELS, Se),
          O.pixelStorei(O.UNPACK_SKIP_ROWS, Ie),
          O.pixelStorei(O.UNPACK_SKIP_IMAGES, Fe);
        const Bo = T.isDataArrayTexture || T.isData3DTexture,
          pt = N.isDataArrayTexture || N.isData3DTexture;
        if (T.isRenderTargetTexture || T.isDepthTexture) {
          const ri = Ae.get(T),
            zo = Ae.get(N),
            Dn = Ae.get(ri.__renderTarget),
            nr = Ae.get(zo.__renderTarget);
          be.bindFramebuffer(O.READ_FRAMEBUFFER, Dn.__webglFramebuffer),
            be.bindFramebuffer(O.DRAW_FRAMEBUFFER, nr.__webglFramebuffer);
          for (let ir = 0; ir < xe; ir++)
            Bo &&
              O.framebufferTextureLayer(
                O.READ_FRAMEBUFFER,
                O.COLOR_ATTACHMENT0,
                Ae.get(T).__webglTexture,
                U,
                Fe + ir
              ),
              T.isDepthTexture
                ? (pt &&
                    O.framebufferTextureLayer(
                      O.DRAW_FRAMEBUFFER,
                      O.COLOR_ATTACHMENT0,
                      Ae.get(N).__webglTexture,
                      U,
                      ut + ir
                    ),
                  O.blitFramebuffer(
                    Se,
                    Ie,
                    se,
                    de,
                    Me,
                    Je,
                    se,
                    de,
                    O.DEPTH_BUFFER_BIT,
                    O.NEAREST
                  ))
                : pt
                ? O.copyTexSubImage3D(we, U, Me, Je, ut + ir, Se, Ie, se, de)
                : O.copyTexSubImage2D(we, U, Me, Je, ut + ir, Se, Ie, se, de);
          be.bindFramebuffer(O.READ_FRAMEBUFFER, null),
            be.bindFramebuffer(O.DRAW_FRAMEBUFFER, null);
        } else
          pt
            ? T.isDataTexture || T.isData3DTexture
              ? O.texSubImage3D(we, U, Me, Je, ut, se, de, xe, dn, tt, ht.data)
              : N.isCompressedArrayTexture
              ? O.compressedTexSubImage3D(
                  we,
                  U,
                  Me,
                  Je,
                  ut,
                  se,
                  de,
                  xe,
                  dn,
                  ht.data
                )
              : O.texSubImage3D(we, U, Me, Je, ut, se, de, xe, dn, tt, ht)
            : T.isDataTexture
            ? O.texSubImage2D(O.TEXTURE_2D, U, Me, Je, se, de, dn, tt, ht.data)
            : T.isCompressedTexture
            ? O.compressedTexSubImage2D(
                O.TEXTURE_2D,
                U,
                Me,
                Je,
                ht.width,
                ht.height,
                dn,
                ht.data
              )
            : O.texSubImage2D(O.TEXTURE_2D, U, Me, Je, se, de, dn, tt, ht);
        O.pixelStorei(O.UNPACK_ROW_LENGTH, wi),
          O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, nt),
          O.pixelStorei(O.UNPACK_SKIP_PIXELS, Wn),
          O.pixelStorei(O.UNPACK_SKIP_ROWS, Ss),
          O.pixelStorei(O.UNPACK_SKIP_IMAGES, Sn),
          U === 0 && N.generateMipmaps && O.generateMipmap(we),
          be.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (
        T,
        N,
        B = null,
        z = null,
        U = 0
      ) {
        return (
          T.isTexture !== !0 &&
            (ua(
              "WebGLRenderer: copyTextureToTexture3D function signature has changed."
            ),
            (B = arguments[0] || null),
            (z = arguments[1] || null),
            (T = arguments[2]),
            (N = arguments[3]),
            (U = arguments[4] || 0)),
          ua(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(T, N, B, z, U)
        );
      }),
      (this.initRenderTarget = function (T) {
        Ae.get(T).__webglFramebuffer === void 0 && b.setupRenderTarget(T);
      }),
      (this.initTexture = function (T) {
        T.isCubeTexture
          ? b.setTextureCube(T, 0)
          : T.isData3DTexture
          ? b.setTexture3D(T, 0)
          : T.isDataArrayTexture || T.isCompressedArrayTexture
          ? b.setTexture2DArray(T, 0)
          : b.setTexture2D(T, 0),
          be.unbindTexture();
      }),
      (this.resetState = function () {
        (R = 0), (w = 0), (A = null), be.reset(), ct.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Hi;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    (n.drawingBufferColorspace = Xe._getDrawingBufferColorSpace(e)),
      (n.unpackColorSpace = Xe._getUnpackColorSpace());
  }
}
class lL extends Mt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new yi()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new yi()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.fog !== null && (n.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (n.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (n.object.backgroundIntensity = this.backgroundIntensity),
      (n.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (n.object.environmentIntensity = this.environmentIntensity),
      (n.object.environmentRotation = this.environmentRotation.toArray()),
      n
    );
  }
}
class cL {
  constructor(e, n) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.usage = Bh),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = ni());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, n, i) {
    (e *= this.stride), (i *= n.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = n.array[i + r];
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ni()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const n = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(n, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ni()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const nn = new D();
class cm {
  constructor(e, n, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = n),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.data.count; n < i; n++)
      nn.fromBufferAttribute(this, n),
        nn.applyMatrix4(e),
        this.setXYZ(n, nn.x, nn.y, nn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      nn.fromBufferAttribute(this, n),
        nn.applyNormalMatrix(e),
        this.setXYZ(n, nn.x, nn.y, nn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      nn.fromBufferAttribute(this, n),
        nn.transformDirection(e),
        this.setXYZ(n, nn.x, nn.y, nn.z);
    return this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.data.stride + this.offset + n];
    return this.normalized && (i = Qn(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return (
      this.normalized && (i = rt(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + n] = i),
      this
    );
  }
  setX(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = n),
      this
    );
  }
  setY(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = n),
      this
    );
  }
  setZ(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = n),
      this
    );
  }
  setW(e, n) {
    return (
      this.normalized && (n = rt(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = n),
      this
    );
  }
  getX(e) {
    let n = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  getY(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  getZ(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  getW(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (n = Qn(n, this.array)), n;
  }
  setXY(e, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((n = rt(n, this.array)), (i = rt(i, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, n, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = rt(n, this.array)),
        (i = rt(i, this.array)),
        (r = rt(r, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, n, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = rt(n, this.array)),
        (i = rt(i, this.array)),
        (r = rt(r, this.array)),
        (s = rt(s, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[r + s]);
      }
      return new cn(
        new this.array.constructor(n),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new cm(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: n,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const _0 = new D(),
  v0 = new et(),
  y0 = new et(),
  uL = new D(),
  x0 = new Be(),
  Kl = new D(),
  Uf = new xi(),
  S0 = new Be(),
  Of = new nl();
class fL extends An {
  constructor(e, n) {
    super(e, n),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = y_),
      (this.bindMatrix = new Be()),
      (this.bindMatrixInverse = new Be()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new tr()),
      this.boundingBox.makeEmpty();
    const n = e.getAttribute("position");
    for (let i = 0; i < n.count; i++)
      this.getVertexPosition(i, Kl), this.boundingBox.expandByPoint(Kl);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new xi()),
      this.boundingSphere.makeEmpty();
    const n = e.getAttribute("position");
    for (let i = 0; i < n.count; i++)
      this.getVertexPosition(i, Kl), this.boundingSphere.expandByPoint(Kl);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, n) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      Uf.copy(this.boundingSphere),
      Uf.applyMatrix4(r),
      e.ray.intersectsSphere(Uf) !== !1 &&
        (S0.copy(r).invert(),
        Of.copy(e.ray).applyMatrix4(S0),
        !(
          this.boundingBox !== null && Of.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, n, Of)));
  }
  getVertexPosition(e, n) {
    return super.getVertexPosition(e, n), this.applyBoneTransform(e, n), n;
  }
  bind(e, n) {
    (this.skeleton = e),
      n === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (n = this.matrixWorld)),
      this.bindMatrix.copy(n),
      this.bindMatrixInverse.copy(n).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new et(),
      n = this.geometry.attributes.skinWeight;
    for (let i = 0, r = n.count; i < r; i++) {
      e.fromBufferAttribute(n, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        n.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === y_
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === _A
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, n) {
    const i = this.skeleton,
      r = this.geometry;
    v0.fromBufferAttribute(r.attributes.skinIndex, e),
      y0.fromBufferAttribute(r.attributes.skinWeight, e),
      _0.copy(n).applyMatrix4(this.bindMatrix),
      n.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = y0.getComponent(s);
      if (o !== 0) {
        const a = v0.getComponent(s);
        x0.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          n.addScaledVector(uL.copy(_0).applyMatrix4(x0), o);
      }
    }
    return n.applyMatrix4(this.bindMatrixInverse);
  }
}
class xS extends Mt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class um extends zt {
  constructor(e = null, n = 1, i = 1, r, s, o, a, l, c = ln, u = ln, f, d) {
    super(null, o, a, l, c, u, r, s, f, d),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: n, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const M0 = new Be(),
  dL = new Be();
class fm {
  constructor(e = [], n = []) {
    (this.uuid = ni()),
      (this.bones = e.slice(0)),
      (this.boneInverses = n),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      n = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), n.length === 0))
      this.calculateInverses();
    else if (e.length !== n.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new Be());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const i = new Be();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      n = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : dL;
      M0.multiplyMatrices(a, n[s]), M0.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new fm(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4);
    n.set(this.boneMatrices);
    const i = new um(n, e, e, Bn, gn);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = n),
      (this.boneTexture = i),
      this
    );
  }
  getBoneByName(e) {
    for (let n = 0, i = this.bones.length; n < i; n++) {
      const r = this.bones[n];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, n) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = n[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new xS())),
        this.bones.push(o),
        this.boneInverses.push(new Be().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const n = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = n.length; r < s; r++) {
      const o = n[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Hh extends cn {
  constructor(e, n, i, r = 1) {
    super(e, n, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Fs = new Be(),
  E0 = new Be(),
  ql = [],
  T0 = new tr(),
  hL = new Be(),
  Jo = new An(),
  ea = new xi();
class pL extends An {
  constructor(e, n, i) {
    super(e, n),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Hh(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, hL);
  }
  computeBoundingBox() {
    const e = this.geometry,
      n = this.count;
    this.boundingBox === null && (this.boundingBox = new tr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < n; i++)
      this.getMatrixAt(i, Fs),
        T0.copy(e.boundingBox).applyMatrix4(Fs),
        this.boundingBox.union(T0);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      n = this.count;
    this.boundingSphere === null && (this.boundingSphere = new xi()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < n; i++)
      this.getMatrixAt(i, Fs),
        ea.copy(e.boundingSphere).applyMatrix4(Fs),
        this.boundingSphere.union(ea);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, n) {
    n.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, n) {
    n.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, n) {
    const i = n.morphTargetInfluences,
      r = this.morphTexture.source.data.data,
      s = i.length + 1,
      o = e * s + 1;
    for (let a = 0; a < i.length; a++) i[a] = r[o + a];
  }
  raycast(e, n) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((Jo.geometry = this.geometry),
      (Jo.material = this.material),
      Jo.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        ea.copy(this.boundingSphere),
        ea.applyMatrix4(i),
        e.ray.intersectsSphere(ea) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, Fs),
          E0.multiplyMatrices(i, Fs),
          (Jo.matrixWorld = E0),
          Jo.raycast(e, ql);
        for (let o = 0, a = ql.length; o < a; o++) {
          const l = ql[o];
          (l.instanceId = s), (l.object = this), n.push(l);
        }
        ql.length = 0;
      }
  }
  setColorAt(e, n) {
    this.instanceColor === null &&
      (this.instanceColor = new Hh(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      n.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, n) {
    n.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, n) {
    const i = n.morphTargetInfluences,
      r = i.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new um(
        new Float32Array(r * this.count),
        r,
        this.count,
        tm,
        gn
      ));
    const s = this.morphTexture.source.data.data;
    let o = 0;
    for (let c = 0; c < i.length; c++) o += i[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = r * e;
    (s[l] = a), s.set(i, l + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
class SS extends _i {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.color = new De(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Jc = new D(),
  eu = new D(),
  w0 = new Be(),
  ta = new nl(),
  $l = new xi(),
  Ff = new D(),
  A0 = new D();
class dm extends Mt {
  constructor(e = new Si(), n = new SS()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        i = [0];
      for (let r = 1, s = n.count; r < s; r++)
        Jc.fromBufferAttribute(n, r - 1),
          eu.fromBufferAttribute(n, r),
          (i[r] = i[r - 1]),
          (i[r] += Jc.distanceTo(eu));
      e.setAttribute("lineDistance", new Wi(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, n) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      $l.copy(i.boundingSphere),
      $l.applyMatrix4(r),
      ($l.radius += s),
      e.ray.intersectsSphere($l) === !1)
    )
      return;
    w0.copy(r).invert(), ta.copy(e.ray).applyMatrix4(w0);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = this.isLineSegments ? 2 : 1,
      u = i.index,
      d = i.attributes.position;
    if (u !== null) {
      const p = Math.max(0, o.start),
        g = Math.min(u.count, o.start + o.count);
      for (let v = p, m = g - 1; v < m; v += c) {
        const h = u.getX(v),
          _ = u.getX(v + 1),
          y = Zl(this, e, ta, l, h, _);
        y && n.push(y);
      }
      if (this.isLineLoop) {
        const v = u.getX(g - 1),
          m = u.getX(p),
          h = Zl(this, e, ta, l, v, m);
        h && n.push(h);
      }
    } else {
      const p = Math.max(0, o.start),
        g = Math.min(d.count, o.start + o.count);
      for (let v = p, m = g - 1; v < m; v += c) {
        const h = Zl(this, e, ta, l, v, v + 1);
        h && n.push(h);
      }
      if (this.isLineLoop) {
        const v = Zl(this, e, ta, l, g - 1, p);
        v && n.push(v);
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function Zl(t, e, n, i, r, s) {
  const o = t.geometry.attributes.position;
  if (
    (Jc.fromBufferAttribute(o, r),
    eu.fromBufferAttribute(o, s),
    n.distanceSqToSegment(Jc, eu, Ff, A0) > i)
  )
    return;
  Ff.applyMatrix4(t.matrixWorld);
  const l = e.ray.origin.distanceTo(Ff);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      point: A0.clone().applyMatrix4(t.matrixWorld),
      index: r,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: t,
    };
}
const b0 = new D(),
  R0 = new D();
class mL extends dm {
  constructor(e, n) {
    super(e, n), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        i = [];
      for (let r = 0, s = n.count; r < s; r += 2)
        b0.fromBufferAttribute(n, r),
          R0.fromBufferAttribute(n, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + b0.distanceTo(R0));
      e.setAttribute("lineDistance", new Wi(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class gL extends dm {
  constructor(e, n) {
    super(e, n), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class MS extends _i {
  static get type() {
    return "PointsMaterial";
  }
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.color = new De(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const C0 = new Be(),
  Vh = new nl(),
  Ql = new xi(),
  Jl = new D();
class _L extends Mt {
  constructor(e = new Si(), n = new MS()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, n) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Ql.copy(i.boundingSphere),
      Ql.applyMatrix4(r),
      (Ql.radius += s),
      e.ray.intersectsSphere(Ql) === !1)
    )
      return;
    C0.copy(r).invert(), Vh.copy(e.ray).applyMatrix4(C0);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = i.index,
      f = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, o.start),
        p = Math.min(c.count, o.start + o.count);
      for (let g = d, v = p; g < v; g++) {
        const m = c.getX(g);
        Jl.fromBufferAttribute(f, m), P0(Jl, m, l, r, e, n, this);
      }
    } else {
      const d = Math.max(0, o.start),
        p = Math.min(f.count, o.start + o.count);
      for (let g = d, v = p; g < v; g++)
        Jl.fromBufferAttribute(f, g), P0(Jl, g, l, r, e, n, this);
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function P0(t, e, n, i, r, s, o) {
  const a = Vh.distanceSqToPoint(t);
  if (a < n) {
    const l = new D();
    Vh.closestPointToPoint(t, l), l.applyMatrix4(i);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    });
  }
}
class hm extends _i {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.color = new De(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new De(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = tS),
      (this.normalScale = new Le(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new yi()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Mi extends hm {
  static get type() {
    return "MeshPhysicalMaterial";
  }
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Le(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Ft((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (n) {
          this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new De(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new De(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new De(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function ec(t, e, n) {
  return !t || (!n && t.constructor === e)
    ? t
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(t)
    : Array.prototype.slice.call(t);
}
function vL(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function yL(t) {
  function e(r, s) {
    return t[r] - t[s];
  }
  const n = t.length,
    i = new Array(n);
  for (let r = 0; r !== n; ++r) i[r] = r;
  return i.sort(e), i;
}
function L0(t, e, n) {
  const i = t.length,
    r = new t.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = n[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = t[a + l];
  }
  return r;
}
function ES(t, e, n, i) {
  let r = 1,
    s = t[0];
  for (; s !== void 0 && s[i] === void 0; ) s = t[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), n.push.apply(n, o)),
          (s = t[r++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(n, n.length)),
          (s = t[r++]);
      while (s !== void 0);
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), n.push(o)), (s = t[r++]);
      while (s !== void 0);
}
class rl {
  constructor(e, n, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new n.constructor(i)),
      (this.sampleValues = n),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const n = this.parameterPositions;
    let i = this._cachedIndex,
      r = n[i],
      s = n[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = n.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = n[++i]), e < r)) break t;
            }
            o = n.length;
            break n;
          }
          if (!(e >= s)) {
            const a = n[1];
            e < a && ((i = 2), (s = a));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === l) break;
              if (((r = s), (s = n[--i - 1]), e >= s)) break t;
            }
            (o = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < n[a] ? (o = a) : (i = a + 1);
        }
        if (((r = n[i]), (s = n[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = n.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const n = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) n[o] = i[s + o];
    return n;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class xL extends rl {
  constructor(e, n, i, r) {
    super(e, n, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: x_, endingEnd: x_ });
  }
  intervalChanged_(e, n, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case S_:
          (s = e), (a = 2 * n - i);
          break;
        case M_:
          (s = r.length - 2), (a = n + r[s] - r[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case S_:
          (o = e), (l = 2 * i - n);
          break;
        case M_:
          (o = 1), (l = i + r[1] - r[0]);
          break;
        default:
          (o = e - 1), (l = n);
      }
    const c = (i - n) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (n - a)),
      (this._weightNext = c / (l - i)),
      (this._offsetPrev = s * u),
      (this._offsetNext = o * u);
  }
  interpolate_(e, n, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = this._offsetPrev,
      f = this._offsetNext,
      d = this._weightPrev,
      p = this._weightNext,
      g = (i - n) / (r - n),
      v = g * g,
      m = v * g,
      h = -d * m + 2 * d * v - d * g,
      _ = (1 + d) * m + (-1.5 - 2 * d) * v + (-0.5 + d) * g + 1,
      y = (-1 - p) * m + (1.5 + p) * v + 0.5 * g,
      x = p * m - p * v;
    for (let C = 0; C !== a; ++C)
      s[C] = h * o[u + C] + _ * o[c + C] + y * o[l + C] + x * o[f + C];
    return s;
  }
}
class SL extends rl {
  constructor(e, n, i, r) {
    super(e, n, i, r);
  }
  interpolate_(e, n, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = (i - n) / (r - n),
      f = 1 - u;
    for (let d = 0; d !== a; ++d) s[d] = o[c + d] * f + o[l + d] * u;
    return s;
  }
}
class ML extends rl {
  constructor(e, n, i, r) {
    super(e, n, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Ei {
  constructor(e, n, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (n === void 0 || n.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = ec(n, this.TimeBufferType)),
      (this.values = ec(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const n = e.constructor;
    let i;
    if (n.toJSON !== this.toJSON) i = n.toJSON(e);
    else {
      i = {
        name: e.name,
        times: ec(e.times, Array),
        values: ec(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new ML(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new SL(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new xL(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let n;
    switch (e) {
      case Xa:
        n = this.InterpolantFactoryMethodDiscrete;
        break;
      case Ya:
        n = this.InterpolantFactoryMethodLinear;
        break;
      case af:
        n = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (n === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = n), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Xa;
      case this.InterpolantFactoryMethodLinear:
        return Ya;
      case this.InterpolantFactoryMethodSmooth:
        return af;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const n = this.times;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const n = this.times;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] *= e;
    }
    return this;
  }
  trim(e, n) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > n; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = i.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const n = this.getValueSize();
    n - Math.floor(n) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (r !== void 0 && vL(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      n = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === af,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a],
        u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (r) l = !0;
        else {
          const f = a * i,
            d = f - i,
            p = f + i;
          for (let g = 0; g !== i; ++g) {
            const v = n[f + g];
            if (v !== n[d + g] || v !== n[p + g]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const f = a * i,
            d = o * i;
          for (let p = 0; p !== i; ++p) n[d + p] = n[f + p];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, c = 0; c !== i; ++c) n[l + c] = n[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = n.slice(0, o * i)))
        : ((this.times = e), (this.values = n)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      n = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, n);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
Ei.prototype.TimeBufferType = Float32Array;
Ei.prototype.ValueBufferType = Float32Array;
Ei.prototype.DefaultInterpolation = Ya;
class Fo extends Ei {
  constructor(e, n, i) {
    super(e, n, i);
  }
}
Fo.prototype.ValueTypeName = "bool";
Fo.prototype.ValueBufferType = Array;
Fo.prototype.DefaultInterpolation = Xa;
Fo.prototype.InterpolantFactoryMethodLinear = void 0;
Fo.prototype.InterpolantFactoryMethodSmooth = void 0;
class TS extends Ei {}
TS.prototype.ValueTypeName = "color";
class Co extends Ei {}
Co.prototype.ValueTypeName = "number";
class EL extends rl {
  constructor(e, n, i, r) {
    super(e, n, i, r);
  }
  interpolate_(e, n, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - n) / (r - n);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4) vi.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
}
class Po extends Ei {
  InterpolantFactoryMethodLinear(e) {
    return new EL(this.times, this.values, this.getValueSize(), e);
  }
}
Po.prototype.ValueTypeName = "quaternion";
Po.prototype.InterpolantFactoryMethodSmooth = void 0;
class ko extends Ei {
  constructor(e, n, i) {
    super(e, n, i);
  }
}
ko.prototype.ValueTypeName = "string";
ko.prototype.ValueBufferType = Array;
ko.prototype.DefaultInterpolation = Xa;
ko.prototype.InterpolantFactoryMethodLinear = void 0;
ko.prototype.InterpolantFactoryMethodSmooth = void 0;
class Lo extends Ei {}
Lo.prototype.ValueTypeName = "vector";
class TL {
  constructor(e = "", n = -1, i = [], r = vA) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = n),
      (this.blendMode = r),
      (this.uuid = ni()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const n = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) n.push(AL(i[o]).scale(r));
    const s = new this(e.name, e.duration, n, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const n = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: n,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) n.push(Ei.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, n, i, r) {
    const s = n.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        c = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
      const u = yL(l);
      (l = L0(l, 1, u)),
        (c = L0(c, 1, u)),
        !r && l[0] === 0 && (l.push(s), c.push(c[0])),
        o.push(
          new Co(".morphTargetInfluences[" + n[a].name + "]", l, c).scale(1 / i)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, n) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === n) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, n, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = c.name.match(s);
      if (u && u.length > 1) {
        const f = u[1];
        let d = r[f];
        d || (r[f] = d = []), d.push(c);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], n, i));
    return o;
  }
  static parseAnimation(e, n) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (f, d, p, g, v) {
        if (p.length !== 0) {
          const m = [],
            h = [];
          ES(p, m, h, g), m.length !== 0 && v.push(new f(d, m, h));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let f = 0; f < c.length; f++) {
      const d = c[f].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const p = {};
          let g;
          for (g = 0; g < d.length; g++)
            if (d[g].morphTargets)
              for (let v = 0; v < d[g].morphTargets.length; v++)
                p[d[g].morphTargets[v]] = -1;
          for (const v in p) {
            const m = [],
              h = [];
            for (let _ = 0; _ !== d[g].morphTargets.length; ++_) {
              const y = d[g];
              m.push(y.time), h.push(y.morphTarget === v ? 1 : 0);
            }
            r.push(new Co(".morphTargetInfluence[" + v + "]", m, h));
          }
          l = p.length * o;
        } else {
          const p = ".bones[" + n[f].name + "]";
          i(Lo, p + ".position", d, "pos", r),
            i(Po, p + ".quaternion", d, "rot", r),
            i(Lo, p + ".scale", d, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let n = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      n = Math.max(n, s.times[s.times.length - 1]);
    }
    return (this.duration = n), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let n = 0; n < this.tracks.length; n++)
      e = e && this.tracks[n].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function wL(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Co;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Lo;
    case "color":
      return TS;
    case "quaternion":
      return Po;
    case "bool":
    case "boolean":
      return Fo;
    case "string":
      return ko;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function AL(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = wL(t.type);
  if (t.times === void 0) {
    const n = [],
      i = [];
    ES(t.keys, n, i, "value"), (t.times = n), (t.values = i);
  }
  return e.parse !== void 0
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation);
}
const Sr = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function (t) {
    if (this.enabled !== !1) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  },
};
class bL {
  constructor(e, n, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = n),
      (this.onError = i),
      (this.itemStart = function (u) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(u, o, a), (s = !0);
      }),
      (this.itemEnd = function (u) {
        o++,
          r.onProgress !== void 0 && r.onProgress(u, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (u) {
        r.onError !== void 0 && r.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, f) {
        return c.push(u, f), this;
      }),
      (this.removeHandler = function (u) {
        const f = c.indexOf(u);
        return f !== -1 && c.splice(f, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let f = 0, d = c.length; f < d; f += 2) {
          const p = c[f],
            g = c[f + 1];
          if ((p.global && (p.lastIndex = 0), p.test(u))) return g;
        }
        return null;
      });
  }
}
const RL = new bL();
class xs {
  constructor(e) {
    (this.manager = e !== void 0 ? e : RL),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, n) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, n, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
xs.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Li = {};
class CL extends Error {
  constructor(e, n) {
    super(e), (this.response = n);
  }
}
class pm extends xs {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Sr.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          n && n(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (Li[e] !== void 0) {
      Li[e].push({ onLoad: n, onProgress: i, onError: r });
      return;
    }
    (Li[e] = []), Li[e].push({ onLoad: n, onProgress: i, onError: r });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = Li[e],
            f = c.body.getReader(),
            d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
            p = d ? parseInt(d) : 0,
            g = p !== 0;
          let v = 0;
          const m = new ReadableStream({
            start(h) {
              _();
              function _() {
                f.read().then(
                  ({ done: y, value: x }) => {
                    if (y) h.close();
                    else {
                      v += x.byteLength;
                      const C = new ProgressEvent("progress", {
                        lengthComputable: g,
                        loaded: v,
                        total: p,
                      });
                      for (let R = 0, w = u.length; R < w; R++) {
                        const A = u[R];
                        A.onProgress && A.onProgress(C);
                      }
                      h.enqueue(x), _();
                    }
                  },
                  (y) => {
                    h.error(y);
                  }
                );
              }
            },
          });
          return new Response(m);
        } else
          throw new CL(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const f = /charset="?([^;"\s]*)"?/i.exec(a),
                d = f && f[1] ? f[1].toLowerCase() : void 0,
                p = new TextDecoder(d);
              return c.arrayBuffer().then((g) => p.decode(g));
            }
        }
      })
      .then((c) => {
        Sr.add(e, c);
        const u = Li[e];
        delete Li[e];
        for (let f = 0, d = u.length; f < d; f++) {
          const p = u[f];
          p.onLoad && p.onLoad(c);
        }
      })
      .catch((c) => {
        const u = Li[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete Li[e];
        for (let f = 0, d = u.length; f < d; f++) {
          const p = u[f];
          p.onError && p.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class PL extends xs {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Sr.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          n && n(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = Ka("img");
    function l() {
      u(), Sr.add(e, this), n && n(this), s.manager.itemEnd(e);
    }
    function c(f) {
      u(), r && r(f), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class LL extends xs {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    const s = this,
      o = new um(),
      a = new pm(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          let c;
          try {
            c = s.parse(l);
          } catch (u) {
            if (r !== void 0) r(u);
            else {
              console.error(u);
              return;
            }
          }
          c.image !== void 0
            ? (o.image = c.image)
            : c.data !== void 0 &&
              ((o.image.width = c.width),
              (o.image.height = c.height),
              (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : hi),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : hi),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : kt),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : kt),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = pi)),
            c.mipmapCount === 1 && (o.minFilter = kt),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            n && n(o, c);
        },
        i,
        r
      ),
      o
    );
  }
}
class IL extends xs {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    const s = new zt(),
      o = new PL(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), n !== void 0 && n(s);
        },
        i,
        r
      ),
      s
    );
  }
}
class mm extends Mt {
  constructor(e, n = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new De(e)),
      (this.intensity = n);
  }
  dispose() {}
  copy(e, n) {
    return (
      super.copy(e, n),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.color = this.color.getHex()),
      (n.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (n.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (n.object.distance = this.distance),
      this.angle !== void 0 && (n.object.angle = this.angle),
      this.decay !== void 0 && (n.object.decay = this.decay),
      this.penumbra !== void 0 && (n.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (n.object.target = this.target.uuid),
      n
    );
  }
}
const kf = new Be(),
  I0 = new D(),
  D0 = new D();
class gm {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Le(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Be()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new om()),
      (this._frameExtents = new Le(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new et(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera,
      i = this.matrix;
    I0.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(I0),
      D0.setFromMatrixPosition(e.target.matrixWorld),
      n.lookAt(D0),
      n.updateMatrixWorld(),
      kf.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(kf),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(kf);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class DL extends gm {
  constructor() {
    super(new on(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const n = this.camera,
      i = bo * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || n.far;
    (i !== n.fov || r !== n.aspect || s !== n.far) &&
      ((n.fov = i), (n.aspect = r), (n.far = s), n.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class NL extends mm {
  constructor(e, n, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, n),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Mt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Mt()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new DL());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const N0 = new Be(),
  na = new D(),
  Bf = new D();
class UL extends gm {
  constructor() {
    super(new on(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Le(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new et(2, 1, 1, 1),
        new et(0, 1, 1, 1),
        new et(3, 1, 1, 1),
        new et(1, 1, 1, 1),
        new et(3, 0, 1, 1),
        new et(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new D(1, 0, 0),
        new D(-1, 0, 0),
        new D(0, 0, 1),
        new D(0, 0, -1),
        new D(0, 1, 0),
        new D(0, -1, 0),
      ]),
      (this._cubeUps = [
        new D(0, 1, 0),
        new D(0, 1, 0),
        new D(0, 1, 0),
        new D(0, 1, 0),
        new D(0, 0, 1),
        new D(0, 0, -1),
      ]);
  }
  updateMatrices(e, n = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      na.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(na),
      Bf.copy(i.position),
      Bf.add(this._cubeDirections[n]),
      i.up.copy(this._cubeUps[n]),
      i.lookAt(Bf),
      i.updateMatrixWorld(),
      r.makeTranslation(-na.x, -na.y, -na.z),
      N0.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(N0);
  }
}
class OL extends mm {
  constructor(e, n, i = 0, r = 2) {
    super(e, n),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new UL());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class FL extends gm {
  constructor() {
    super(new am(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class wS extends mm {
  constructor(e, n) {
    super(e, n),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Mt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Mt()),
      (this.shadow = new FL());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class wa {
  static decodeText(e) {
    if (
      (console.warn(
        "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
      ),
      typeof TextDecoder < "u")
    )
      return new TextDecoder().decode(e);
    let n = "";
    for (let i = 0, r = e.length; i < r; i++) n += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(n));
    } catch {
      return n;
    }
  }
  static extractUrlBase(e) {
    const n = e.lastIndexOf("/");
    return n === -1 ? "./" : e.slice(0, n + 1);
  }
  static resolveURL(e, n) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(n) &&
          /^\//.test(e) &&
          (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : n + e);
  }
}
class kL extends xs {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, n, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Sr.get(e);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((c) => {
          n && n(c), s.manager.itemEnd(e);
        }).catch((c) => {
          r && r(c);
        });
        return;
      }
      return (
        setTimeout(function () {
          n && n(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const l = fetch(e, a)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(s.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (c) {
        return Sr.add(e, c), n && n(c), s.manager.itemEnd(e), c;
      })
      .catch(function (c) {
        r && r(c), Sr.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
      });
    Sr.add(e, l), s.manager.itemStart(e);
  }
}
const _m = "\\[\\]\\.:\\/",
  BL = new RegExp("[" + _m + "]", "g"),
  vm = "[^" + _m + "]",
  zL = "[^" + _m.replace("\\.", "") + "]",
  HL = /((?:WC+[\/:])*)/.source.replace("WC", vm),
  VL = /(WCOD+)?/.source.replace("WCOD", zL),
  GL = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", vm),
  WL = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", vm),
  jL = new RegExp("^" + HL + VL + GL + WL + "$"),
  XL = ["material", "materials", "bones", "map"];
class YL {
  constructor(e, n, i) {
    const r = i || st.parseTrackName(n);
    (this._targetGroup = e), (this._bindings = e.subscribe_(n, r));
  }
  getValue(e, n) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, n);
  }
  setValue(e, n) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, n);
  }
  bind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, i = e.length; n !== i; ++n)
      e[n].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, i = e.length; n !== i; ++n)
      e[n].unbind();
  }
}
class st {
  constructor(e, n, i) {
    (this.path = n),
      (this.parsedPath = i || st.parseTrackName(n)),
      (this.node = st.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, n, i) {
    return e && e.isAnimationObjectGroup
      ? new st.Composite(e, n, i)
      : new st(e, n, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(BL, "");
  }
  static parseTrackName(e) {
    const n = jL.exec(e);
    if (n === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: n[2],
        objectName: n[3],
        objectIndex: n[4],
        propertyName: n[5],
        propertyIndex: n[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      XL.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, n) {
    if (
      n === void 0 ||
      n === "" ||
      n === "." ||
      n === -1 ||
      n === e.name ||
      n === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(n);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === n || a.uuid === n) return a;
            const l = i(a.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, n) {
    e[n] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, n) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[n++] = i[r];
  }
  _getValue_arrayElement(e, n) {
    e[n] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, n) {
    this.resolvedProperty.toArray(e, n);
  }
  _setValue_direct(e, n) {
    this.targetObject[this.propertyName] = e[n];
  }
  _setValue_direct_setNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, n) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[n++];
  }
  _setValue_array_setNeedsUpdate(e, n) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[n++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[n++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n];
  }
  _setValue_arrayElement_setNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, n) {
    this.resolvedProperty.fromArray(e, n);
  }
  _setValue_fromArray_setNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, n) {
    this.bind(), this.getValue(e, n);
  }
  _setValue_unbound(e, n) {
    this.bind(), this.setValue(e, n);
  }
  bind() {
    let e = this.node;
    const n = this.parsedPath,
      i = n.objectName,
      r = n.propertyName;
    let s = n.propertyIndex;
    if (
      (e || ((e = st.findNode(this.rootNode, n.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (i) {
      let c = n.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const c = n.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
st.Composite = YL;
st.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
st.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
st.prototype.GetterByBindingType = [
  st.prototype._getValue_direct,
  st.prototype._getValue_array,
  st.prototype._getValue_arrayElement,
  st.prototype._getValue_toArray,
];
st.prototype.SetterByBindingTypeAndVersioning = [
  [
    st.prototype._setValue_direct,
    st.prototype._setValue_direct_setNeedsUpdate,
    st.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    st.prototype._setValue_array,
    st.prototype._setValue_array_setNeedsUpdate,
    st.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    st.prototype._setValue_arrayElement,
    st.prototype._setValue_arrayElement_setNeedsUpdate,
    st.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    st.prototype._setValue_fromArray,
    st.prototype._setValue_fromArray_setNeedsUpdate,
    st.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class U0 {
  constructor(e = 1, n = 0, i = 0) {
    return (this.radius = e), (this.phi = n), (this.theta = i), this;
  }
  set(e, n, i) {
    return (this.radius = e), (this.phi = n), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, i) {
    return (
      (this.radius = Math.sqrt(e * e + n * n + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(Ft(n / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class KL extends ys {
  constructor(e, n = null) {
    super(),
      (this.object = e),
      (this.domElement = n),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Zp } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Zp));
const O0 = { type: "change" },
  ym = { type: "start" },
  AS = { type: "end" },
  tc = new nl(),
  F0 = new mr(),
  qL = Math.cos(70 * iS.DEG2RAD),
  Pt = new D(),
  hn = 2 * Math.PI,
  lt = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6,
  },
  zf = 1e-6;
class $L extends KL {
  constructor(e, n = null) {
    super(e, n),
      (this.state = lt.NONE),
      (this.enabled = !0),
      (this.target = new D()),
      (this.cursor = new D()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minTargetRadius = 0),
      (this.maxTargetRadius = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: ao.ROTATE,
        MIDDLE: ao.DOLLY,
        RIGHT: ao.PAN,
      }),
      (this.touches = { ONE: Qs.ROTATE, TWO: Qs.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this._lastPosition = new D()),
      (this._lastQuaternion = new vi()),
      (this._lastTargetPosition = new D()),
      (this._quat = new vi().setFromUnitVectors(e.up, new D(0, 1, 0))),
      (this._quatInverse = this._quat.clone().invert()),
      (this._spherical = new U0()),
      (this._sphericalDelta = new U0()),
      (this._scale = 1),
      (this._panOffset = new D()),
      (this._rotateStart = new Le()),
      (this._rotateEnd = new Le()),
      (this._rotateDelta = new Le()),
      (this._panStart = new Le()),
      (this._panEnd = new Le()),
      (this._panDelta = new Le()),
      (this._dollyStart = new Le()),
      (this._dollyEnd = new Le()),
      (this._dollyDelta = new Le()),
      (this._dollyDirection = new D()),
      (this._mouse = new Le()),
      (this._performCursorZoom = !1),
      (this._pointers = []),
      (this._pointerPositions = {}),
      (this._controlActive = !1),
      (this._onPointerMove = QL.bind(this)),
      (this._onPointerDown = ZL.bind(this)),
      (this._onPointerUp = JL.bind(this)),
      (this._onContextMenu = oI.bind(this)),
      (this._onMouseWheel = nI.bind(this)),
      (this._onKeyDown = iI.bind(this)),
      (this._onTouchStart = rI.bind(this)),
      (this._onTouchMove = sI.bind(this)),
      (this._onMouseDown = eI.bind(this)),
      (this._onMouseMove = tI.bind(this)),
      (this._interceptControlDown = aI.bind(this)),
      (this._interceptControlUp = lI.bind(this)),
      this.domElement !== null && this.connect(),
      this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown),
      this.domElement.addEventListener("pointercancel", this._onPointerUp),
      this.domElement.addEventListener("contextmenu", this._onContextMenu),
      this.domElement.addEventListener("wheel", this._onMouseWheel, {
        passive: !1,
      }),
      this.domElement
        .getRootNode()
        .addEventListener("keydown", this._interceptControlDown, {
          passive: !0,
          capture: !0,
        }),
      (this.domElement.style.touchAction = "none");
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown),
      this.domElement.removeEventListener("pointermove", this._onPointerMove),
      this.domElement.removeEventListener("pointerup", this._onPointerUp),
      this.domElement.removeEventListener("pointercancel", this._onPointerUp),
      this.domElement.removeEventListener("wheel", this._onMouseWheel),
      this.domElement.removeEventListener("contextmenu", this._onContextMenu),
      this.stopListenToKeyEvents(),
      this.domElement
        .getRootNode()
        .removeEventListener("keydown", this._interceptControlDown, {
          capture: !0,
        }),
      (this.domElement.style.touchAction = "auto");
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown),
      (this._domElementKeyEvents = e);
  }
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null &&
      (this._domElementKeyEvents.removeEventListener(
        "keydown",
        this._onKeyDown
      ),
      (this._domElementKeyEvents = null));
  }
  saveState() {
    this.target0.copy(this.target),
      this.position0.copy(this.object.position),
      (this.zoom0 = this.object.zoom);
  }
  reset() {
    this.target.copy(this.target0),
      this.object.position.copy(this.position0),
      (this.object.zoom = this.zoom0),
      this.object.updateProjectionMatrix(),
      this.dispatchEvent(O0),
      this.update(),
      (this.state = lt.NONE);
  }
  update(e = null) {
    const n = this.object.position;
    Pt.copy(n).sub(this.target),
      Pt.applyQuaternion(this._quat),
      this._spherical.setFromVector3(Pt),
      this.autoRotate &&
        this.state === lt.NONE &&
        this._rotateLeft(this._getAutoRotationAngle(e)),
      this.enableDamping
        ? ((this._spherical.theta +=
            this._sphericalDelta.theta * this.dampingFactor),
          (this._spherical.phi +=
            this._sphericalDelta.phi * this.dampingFactor))
        : ((this._spherical.theta += this._sphericalDelta.theta),
          (this._spherical.phi += this._sphericalDelta.phi));
    let i = this.minAzimuthAngle,
      r = this.maxAzimuthAngle;
    isFinite(i) &&
      isFinite(r) &&
      (i < -Math.PI ? (i += hn) : i > Math.PI && (i -= hn),
      r < -Math.PI ? (r += hn) : r > Math.PI && (r -= hn),
      i <= r
        ? (this._spherical.theta = Math.max(
            i,
            Math.min(r, this._spherical.theta)
          ))
        : (this._spherical.theta =
            this._spherical.theta > (i + r) / 2
              ? Math.max(i, this._spherical.theta)
              : Math.min(r, this._spherical.theta))),
      (this._spherical.phi = Math.max(
        this.minPolarAngle,
        Math.min(this.maxPolarAngle, this._spherical.phi)
      )),
      this._spherical.makeSafe(),
      this.enableDamping === !0
        ? this.target.addScaledVector(this._panOffset, this.dampingFactor)
        : this.target.add(this._panOffset),
      this.target.sub(this.cursor),
      this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
      this.target.add(this.cursor);
    let s = !1;
    if (
      (this.zoomToCursor && this._performCursorZoom) ||
      this.object.isOrthographicCamera
    )
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      (this._spherical.radius = this._clampDistance(
        this._spherical.radius * this._scale
      )),
        (s = o != this._spherical.radius);
    }
    if (
      (Pt.setFromSpherical(this._spherical),
      Pt.applyQuaternion(this._quatInverse),
      n.copy(this.target).add(Pt),
      this.object.lookAt(this.target),
      this.enableDamping === !0
        ? ((this._sphericalDelta.theta *= 1 - this.dampingFactor),
          (this._sphericalDelta.phi *= 1 - this.dampingFactor),
          this._panOffset.multiplyScalar(1 - this.dampingFactor))
        : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)),
      this.zoomToCursor && this._performCursorZoom)
    ) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const a = Pt.length();
        o = this._clampDistance(a * this._scale);
        const l = a - o;
        this.object.position.addScaledVector(this._dollyDirection, l),
          this.object.updateMatrixWorld(),
          (s = !!l);
      } else if (this.object.isOrthographicCamera) {
        const a = new D(this._mouse.x, this._mouse.y, 0);
        a.unproject(this.object);
        const l = this.object.zoom;
        (this.object.zoom = Math.max(
          this.minZoom,
          Math.min(this.maxZoom, this.object.zoom / this._scale)
        )),
          this.object.updateProjectionMatrix(),
          (s = l !== this.object.zoom);
        const c = new D(this._mouse.x, this._mouse.y, 0);
        c.unproject(this.object),
          this.object.position.sub(c).add(a),
          this.object.updateMatrixWorld(),
          (o = Pt.length());
      } else
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
        ),
          (this.zoomToCursor = !1);
      o !== null &&
        (this.screenSpacePanning
          ? this.target
              .set(0, 0, -1)
              .transformDirection(this.object.matrix)
              .multiplyScalar(o)
              .add(this.object.position)
          : (tc.origin.copy(this.object.position),
            tc.direction.set(0, 0, -1).transformDirection(this.object.matrix),
            Math.abs(this.object.up.dot(tc.direction)) < qL
              ? this.object.lookAt(this.target)
              : (F0.setFromNormalAndCoplanarPoint(this.object.up, this.target),
                tc.intersectPlane(F0, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      (this.object.zoom = Math.max(
        this.minZoom,
        Math.min(this.maxZoom, this.object.zoom / this._scale)
      )),
        o !== this.object.zoom &&
          (this.object.updateProjectionMatrix(), (s = !0));
    }
    return (
      (this._scale = 1),
      (this._performCursorZoom = !1),
      s ||
      this._lastPosition.distanceToSquared(this.object.position) > zf ||
      8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > zf ||
      this._lastTargetPosition.distanceToSquared(this.target) > zf
        ? (this.dispatchEvent(O0),
          this._lastPosition.copy(this.object.position),
          this._lastQuaternion.copy(this.object.quaternion),
          this._lastTargetPosition.copy(this.target),
          !0)
        : !1
    );
  }
  _getAutoRotationAngle(e) {
    return e !== null
      ? (hn / 60) * this.autoRotateSpeed * e
      : (hn / 60 / 60) * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const n = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * n);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, n) {
    Pt.setFromMatrixColumn(n, 0),
      Pt.multiplyScalar(-e),
      this._panOffset.add(Pt);
  }
  _panUp(e, n) {
    this.screenSpacePanning === !0
      ? Pt.setFromMatrixColumn(n, 1)
      : (Pt.setFromMatrixColumn(n, 0), Pt.crossVectors(this.object.up, Pt)),
      Pt.multiplyScalar(e),
      this._panOffset.add(Pt);
  }
  _pan(e, n) {
    const i = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const r = this.object.position;
      Pt.copy(r).sub(this.target);
      let s = Pt.length();
      (s *= Math.tan(((this.object.fov / 2) * Math.PI) / 180)),
        this._panLeft((2 * e * s) / i.clientHeight, this.object.matrix),
        this._panUp((2 * n * s) / i.clientHeight, this.object.matrix);
    } else
      this.object.isOrthographicCamera
        ? (this._panLeft(
            (e * (this.object.right - this.object.left)) /
              this.object.zoom /
              i.clientWidth,
            this.object.matrix
          ),
          this._panUp(
            (n * (this.object.top - this.object.bottom)) /
              this.object.zoom /
              i.clientHeight,
            this.object.matrix
          ))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
          ),
          (this.enablePan = !1));
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale /= e)
      : (console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
        ),
        (this.enableZoom = !1));
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera
      ? (this._scale *= e)
      : (console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
        ),
        (this.enableZoom = !1));
  }
  _updateZoomParameters(e, n) {
    if (!this.zoomToCursor) return;
    this._performCursorZoom = !0;
    const i = this.domElement.getBoundingClientRect(),
      r = e - i.left,
      s = n - i.top,
      o = i.width,
      a = i.height;
    (this._mouse.x = (r / o) * 2 - 1),
      (this._mouse.y = -(s / a) * 2 + 1),
      this._dollyDirection
        .set(this._mouse.x, this._mouse.y, 1)
        .unproject(this.object)
        .sub(this.object.position)
        .normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX),
      this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY),
      this._rotateDelta
        .subVectors(this._rotateEnd, this._rotateStart)
        .multiplyScalar(this.rotateSpeed);
    const n = this.domElement;
    this._rotateLeft((hn * this._rotateDelta.x) / n.clientHeight),
      this._rotateUp((hn * this._rotateDelta.y) / n.clientHeight),
      this._rotateStart.copy(this._rotateEnd),
      this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY),
      this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
      this._dollyDelta.y > 0
        ? this._dollyOut(this._getZoomScale(this._dollyDelta.y))
        : this._dollyDelta.y < 0 &&
          this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
      this._dollyStart.copy(this._dollyEnd),
      this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY),
      this._panDelta
        .subVectors(this._panEnd, this._panStart)
        .multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd),
      this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY),
      e.deltaY < 0
        ? this._dollyIn(this._getZoomScale(e.deltaY))
        : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)),
      this.update();
  }
  _handleKeyDown(e) {
    let n = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateUp(
              (hn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(0, this.keyPanSpeed),
          (n = !0);
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateUp(
              (-hn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(0, -this.keyPanSpeed),
          (n = !0);
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateLeft(
              (hn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(this.keyPanSpeed, 0),
          (n = !0);
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey
          ? this._rotateLeft(
              (-hn * this.rotateSpeed) / this.domElement.clientHeight
            )
          : this._pan(-this.keyPanSpeed, 0),
          (n = !0);
        break;
    }
    n && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1) this._rotateStart.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e),
        i = 0.5 * (e.pageX + n.x),
        r = 0.5 * (e.pageY + n.y);
      this._rotateStart.set(i, r);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1) this._panStart.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e),
        i = 0.5 * (e.pageX + n.x),
        r = 0.5 * (e.pageY + n.y);
      this._panStart.set(i, r);
    }
  }
  _handleTouchStartDolly(e) {
    const n = this._getSecondPointerPosition(e),
      i = e.pageX - n.x,
      r = e.pageY - n.y,
      s = Math.sqrt(i * i + r * r);
    this._dollyStart.set(0, s);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e),
      this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e),
      this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1) this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const i = this._getSecondPointerPosition(e),
        r = 0.5 * (e.pageX + i.x),
        s = 0.5 * (e.pageY + i.y);
      this._rotateEnd.set(r, s);
    }
    this._rotateDelta
      .subVectors(this._rotateEnd, this._rotateStart)
      .multiplyScalar(this.rotateSpeed);
    const n = this.domElement;
    this._rotateLeft((hn * this._rotateDelta.x) / n.clientHeight),
      this._rotateUp((hn * this._rotateDelta.y) / n.clientHeight),
      this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1) this._panEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e),
        i = 0.5 * (e.pageX + n.x),
        r = 0.5 * (e.pageY + n.y);
      this._panEnd.set(i, r);
    }
    this._panDelta
      .subVectors(this._panEnd, this._panStart)
      .multiplyScalar(this.panSpeed),
      this._pan(this._panDelta.x, this._panDelta.y),
      this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const n = this._getSecondPointerPosition(e),
      i = e.pageX - n.x,
      r = e.pageY - n.y,
      s = Math.sqrt(i * i + r * r);
    this._dollyEnd.set(0, s),
      this._dollyDelta.set(
        0,
        Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)
      ),
      this._dollyOut(this._dollyDelta.y),
      this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + n.x) * 0.5,
      a = (e.pageY + n.y) * 0.5;
    this._updateZoomParameters(o, a);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e),
      this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e),
      this.enableRotate && this._handleTouchMoveRotate(e);
  }
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let n = 0; n < this._pointers.length; n++)
      if (this._pointers[n] == e.pointerId) {
        this._pointers.splice(n, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let n = 0; n < this._pointers.length; n++)
      if (this._pointers[n] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let n = this._pointerPositions[e.pointerId];
    n === void 0 && ((n = new Le()), (this._pointerPositions[e.pointerId] = n)),
      n.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const n =
      e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[n];
  }
  _customWheelEvent(e) {
    const n = e.deltaMode,
      i = { clientX: e.clientX, clientY: e.clientY, deltaY: e.deltaY };
    switch (n) {
      case 1:
        i.deltaY *= 16;
        break;
      case 2:
        i.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
  }
}
function ZL(t) {
  this.enabled !== !1 &&
    (this._pointers.length === 0 &&
      (this.domElement.setPointerCapture(t.pointerId),
      this.domElement.addEventListener("pointermove", this._onPointerMove),
      this.domElement.addEventListener("pointerup", this._onPointerUp)),
    !this._isTrackingPointer(t) &&
      (this._addPointer(t),
      t.pointerType === "touch"
        ? this._onTouchStart(t)
        : this._onMouseDown(t)));
}
function QL(t) {
  this.enabled !== !1 &&
    (t.pointerType === "touch" ? this._onTouchMove(t) : this._onMouseMove(t));
}
function JL(t) {
  switch ((this._removePointer(t), this._pointers.length)) {
    case 0:
      this.domElement.releasePointerCapture(t.pointerId),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.dispatchEvent(AS),
        (this.state = lt.NONE);
      break;
    case 1:
      const e = this._pointers[0],
        n = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: n.x, pageY: n.y });
      break;
  }
}
function eI(t) {
  let e;
  switch (t.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case ao.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(t), (this.state = lt.DOLLY);
      break;
    case ao.ROTATE:
      if (t.ctrlKey || t.metaKey || t.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(t), (this.state = lt.PAN);
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(t), (this.state = lt.ROTATE);
      }
      break;
    case ao.PAN:
      if (t.ctrlKey || t.metaKey || t.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(t), (this.state = lt.ROTATE);
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(t), (this.state = lt.PAN);
      }
      break;
    default:
      this.state = lt.NONE;
  }
  this.state !== lt.NONE && this.dispatchEvent(ym);
}
function tI(t) {
  switch (this.state) {
    case lt.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(t);
      break;
    case lt.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(t);
      break;
    case lt.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(t);
      break;
  }
}
function nI(t) {
  this.enabled === !1 ||
    this.enableZoom === !1 ||
    this.state !== lt.NONE ||
    (t.preventDefault(),
    this.dispatchEvent(ym),
    this._handleMouseWheel(this._customWheelEvent(t)),
    this.dispatchEvent(AS));
}
function iI(t) {
  this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(t);
}
function rI(t) {
  switch ((this._trackPointer(t), this._pointers.length)) {
    case 1:
      switch (this.touches.ONE) {
        case Qs.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(t), (this.state = lt.TOUCH_ROTATE);
          break;
        case Qs.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(t), (this.state = lt.TOUCH_PAN);
          break;
        default:
          this.state = lt.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case Qs.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(t), (this.state = lt.TOUCH_DOLLY_PAN);
          break;
        case Qs.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(t),
            (this.state = lt.TOUCH_DOLLY_ROTATE);
          break;
        default:
          this.state = lt.NONE;
      }
      break;
    default:
      this.state = lt.NONE;
  }
  this.state !== lt.NONE && this.dispatchEvent(ym);
}
function sI(t) {
  switch ((this._trackPointer(t), this.state)) {
    case lt.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(t), this.update();
      break;
    case lt.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(t), this.update();
      break;
    case lt.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(t), this.update();
      break;
    case lt.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(t), this.update();
      break;
    default:
      this.state = lt.NONE;
  }
}
function oI(t) {
  this.enabled !== !1 && t.preventDefault();
}
function aI(t) {
  t.key === "Control" &&
    ((this._controlActive = !0),
    this.domElement
      .getRootNode()
      .addEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0,
      }));
}
function lI(t) {
  t.key === "Control" &&
    ((this._controlActive = !1),
    this.domElement
      .getRootNode()
      .removeEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0,
      }));
}
function k0(t, e) {
  if (e === yA)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      t
    );
  if (e === kh || e === eS) {
    let n = t.getIndex();
    if (n === null) {
      const o = [],
        a = t.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l);
        t.setIndex(o), (n = t.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          t
        );
    }
    const i = n.count - 2,
      r = [];
    if (e === kh)
      for (let o = 1; o <= i; o++)
        r.push(n.getX(0)), r.push(n.getX(o)), r.push(n.getX(o + 1));
    else
      for (let o = 0; o < i; o++)
        o % 2 === 0
          ? (r.push(n.getX(o)), r.push(n.getX(o + 1)), r.push(n.getX(o + 2)))
          : (r.push(n.getX(o + 2)), r.push(n.getX(o + 1)), r.push(n.getX(o)));
    r.length / 3 !== i &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = t.clone();
    return s.setIndex(r), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      t
    );
}
class cI extends xs {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (n) {
        return new pI(n);
      }),
      this.register(function (n) {
        return new mI(n);
      }),
      this.register(function (n) {
        return new TI(n);
      }),
      this.register(function (n) {
        return new wI(n);
      }),
      this.register(function (n) {
        return new AI(n);
      }),
      this.register(function (n) {
        return new _I(n);
      }),
      this.register(function (n) {
        return new vI(n);
      }),
      this.register(function (n) {
        return new yI(n);
      }),
      this.register(function (n) {
        return new xI(n);
      }),
      this.register(function (n) {
        return new hI(n);
      }),
      this.register(function (n) {
        return new SI(n);
      }),
      this.register(function (n) {
        return new gI(n);
      }),
      this.register(function (n) {
        return new EI(n);
      }),
      this.register(function (n) {
        return new MI(n);
      }),
      this.register(function (n) {
        return new fI(n);
      }),
      this.register(function (n) {
        return new bI(n);
      }),
      this.register(function (n) {
        return new RI(n);
      });
  }
  load(e, n, i, r) {
    const s = this;
    let o;
    if (this.resourcePath !== "") o = this.resourcePath;
    else if (this.path !== "") {
      const c = wa.extractUrlBase(e);
      o = wa.resolveURL(c, this.path);
    } else o = wa.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function (c) {
        r ? r(c) : console.error(c),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new pm(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            s.parse(
              c,
              o,
              function (u) {
                n(u), s.manager.itemEnd(e);
              },
              a
            );
          } catch (u) {
            a(u);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, n, i, r) {
    let s;
    const o = {},
      a = {},
      l = new TextDecoder();
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === bS) {
        try {
          o[We.KHR_BINARY_GLTF] = new CI(e);
        } catch (f) {
          r && r(f);
          return;
        }
        s = JSON.parse(o[We.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(l.decode(e));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new VI(s, {
      path: n || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const f = this.pluginCallbacks[u](c);
      f.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (a[f.name] = f),
        (o[f.name] = !0);
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const f = s.extensionsUsed[u],
          d = s.extensionsRequired || [];
        switch (f) {
          case We.KHR_MATERIALS_UNLIT:
            o[f] = new dI();
            break;
          case We.KHR_DRACO_MESH_COMPRESSION:
            o[f] = new PI(s, this.dracoLoader);
            break;
          case We.KHR_TEXTURE_TRANSFORM:
            o[f] = new LI();
            break;
          case We.KHR_MESH_QUANTIZATION:
            o[f] = new II();
            break;
          default:
            d.indexOf(f) >= 0 &&
              a[f] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
    c.setExtensions(o), c.setPlugins(a), c.parse(i, r);
  }
  parseAsync(e, n) {
    const i = this;
    return new Promise(function (r, s) {
      i.parse(e, n, r, s);
    });
  }
}
function uI() {
  let t = {};
  return {
    get: function (e) {
      return t[e];
    },
    add: function (e, n) {
      t[e] = n;
    },
    remove: function (e) {
      delete t[e];
    },
    removeAll: function () {
      t = {};
    },
  };
}
const We = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class fI {
  constructor(e) {
    (this.parser = e),
      (this.name = We.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      n = this.parser.json.nodes || [];
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const n = this.parser,
      i = "light:" + e;
    let r = n.cache.get(i);
    if (r) return r;
    const s = n.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const u = new De(16777215);
    l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], tn);
    const f = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new wS(u)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new OL(u)), (c.distance = f);
        break;
      case "spot":
        (c = new NL(u)),
          (c.distance = f),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      Ni(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = n.createUniqueName(l.name || "light_" + e)),
      (r = Promise.resolve(c)),
      n.cache.add(i, r),
      r
    );
  }
  getDependency(e, n) {
    if (e === "light") return this._loadLight(n);
  }
  createNodeAttachment(e) {
    const n = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(n.cache, a, l);
        });
  }
}
class dI {
  constructor() {
    this.name = We.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return rs;
  }
  extendParams(e, n, i) {
    const r = [];
    (e.color = new De(1, 1, 1)), (e.opacity = 1);
    const s = n.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], tn), (e.opacity = o[3]);
      }
      s.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", s.baseColorTexture, Gt));
    }
    return Promise.all(r);
  }
}
class hI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, n) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name].emissiveStrength;
    return s !== void 0 && (n.emissiveIntensity = s), Promise.resolve();
  }
}
class pI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (n.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(n, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (n.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            n,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(n, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      n.clearcoatNormalScale = new Le(a, a);
    }
    return Promise.all(s);
  }
}
class mI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (
      (n.dispersion = s.dispersion !== void 0 ? s.dispersion : 0),
      Promise.resolve()
    );
  }
}
class gI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (n.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(n, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (n.iridescenceIOR = o.iridescenceIor),
      n.iridescenceThicknessRange === void 0 &&
        (n.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (n.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (n.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            n,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class _I {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [];
    (n.sheenColor = new De(0, 0, 0)), (n.sheenRoughness = 0), (n.sheen = 1);
    const o = r.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      n.sheenColor.setRGB(a[0], a[1], a[2], tn);
    }
    return (
      o.sheenRoughnessFactor !== void 0 &&
        (n.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(n, "sheenColorMap", o.sheenColorTexture, Gt)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(n, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class vI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (n.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(n, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class yI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (n.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(n, "thicknessMap", o.thicknessTexture)),
      (n.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (
      (n.attenuationColor = new De().setRGB(a[0], a[1], a[2], tn)),
      Promise.all(s)
    );
  }
}
class xI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (n.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class SI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (n.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(n, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (n.specularColor = new De().setRGB(a[0], a[1], a[2], tn)),
      o.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(n, "specularColorMap", o.specularColorTexture, Gt)
        ),
      Promise.all(s)
    );
  }
}
class MI {
  constructor(e) {
    (this.parser = e), (this.name = We.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      (n.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1),
      o.bumpTexture !== void 0 &&
        s.push(i.assignTexture(n, "bumpMap", o.bumpTexture)),
      Promise.all(s)
    );
  }
}
class EI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Mi;
  }
  extendMaterialParams(e, n) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (n.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(i.assignTexture(n, "anisotropyMap", o.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class TI {
  constructor(e) {
    (this.parser = e), (this.name = We.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const n = this.parser,
      i = n.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const s = r.extensions[this.name],
      o = n.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return n.loadTextureImage(e, s.source, o);
  }
}
class wI {
  constructor(e) {
    (this.parser = e),
      (this.name = We.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const n = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[n]) return null;
    const o = s.extensions[n],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(n) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const n = new Image();
          (n.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (n.onload = n.onerror =
              function () {
                e(n.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class AI {
  constructor(e) {
    (this.parser = e),
      (this.name = We.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const n = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[n]) return null;
    const o = s.extensions[n],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(n) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const n = new Image();
          (n.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (n.onload = n.onerror =
              function () {
                e(n.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class bI {
  constructor(e) {
    (this.name = We.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const n = this.parser.json,
      i = n.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency("buffer", r.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          n.extensionsRequired &&
          n.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          c = r.byteLength || 0,
          u = r.count,
          f = r.byteStride,
          d = new Uint8Array(a, l, c);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(u, f, d, r.mode, r.filter)
              .then(function (p) {
                return p.buffer;
              })
          : o.ready.then(function () {
              const p = new ArrayBuffer(u * f);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(p),
                  u,
                  f,
                  d,
                  r.mode,
                  r.filter
                ),
                p
              );
            });
      });
    } else return null;
  }
}
class RI {
  constructor(e) {
    (this.name = We.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const n = this.parser.json,
      i = n.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const r = n.meshes[i.mesh];
    for (const c of r.primitives)
      if (
        c.mode !== Un.TRIANGLES &&
        c.mode !== Un.TRIANGLE_STRIP &&
        c.mode !== Un.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const o = i.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const c in o)
      a.push(
        this.parser
          .getDependency("accessor", o[c])
          .then((u) => ((l[c] = u), l[c]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((c) => {
          const u = c.pop(),
            f = u.isGroup ? u.children : [u],
            d = c[0].count,
            p = [];
          for (const g of f) {
            const v = new Be(),
              m = new D(),
              h = new vi(),
              _ = new D(1, 1, 1),
              y = new pL(g.geometry, g.material, d);
            for (let x = 0; x < d; x++)
              l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, x),
                l.ROTATION && h.fromBufferAttribute(l.ROTATION, x),
                l.SCALE && _.fromBufferAttribute(l.SCALE, x),
                y.setMatrixAt(x, v.compose(m, h, _));
            for (const x in l)
              if (x === "_COLOR_0") {
                const C = l[x];
                y.instanceColor = new Hh(C.array, C.itemSize, C.normalized);
              } else
                x !== "TRANSLATION" &&
                  x !== "ROTATION" &&
                  x !== "SCALE" &&
                  g.geometry.setAttribute(x, l[x]);
            Mt.prototype.copy.call(y, g),
              this.parser.assignFinalMaterial(y),
              p.push(y);
          }
          return u.isGroup ? (u.clear(), u.add(...p), u) : p[0];
        }));
  }
}
const bS = "glTF",
  ia = 12,
  B0 = { JSON: 1313821514, BIN: 5130562 };
class CI {
  constructor(e) {
    (this.name = We.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const n = new DataView(e, 0, ia),
      i = new TextDecoder();
    if (
      ((this.header = {
        magic: i.decode(new Uint8Array(e.slice(0, 4))),
        version: n.getUint32(4, !0),
        length: n.getUint32(8, !0),
      }),
      this.header.magic !== bS)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - ia,
      s = new DataView(e, ia);
    let o = 0;
    for (; o < r; ) {
      const a = s.getUint32(o, !0);
      o += 4;
      const l = s.getUint32(o, !0);
      if (((o += 4), l === B0.JSON)) {
        const c = new Uint8Array(e, ia + o, a);
        this.content = i.decode(c);
      } else if (l === B0.BIN) {
        const c = ia + o;
        this.body = e.slice(c, c + a);
      }
      o += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class PI {
  constructor(e, n) {
    if (!n)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = We.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = n),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, n) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      c = {};
    for (const u in o) {
      const f = Gh[u] || u.toLowerCase();
      a[f] = o[u];
    }
    for (const u in e.attributes) {
      const f = Gh[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = i.accessors[e.attributes[u]],
          p = fo[d.componentType];
        (c[f] = p.name), (l[f] = d.normalized === !0);
      }
    }
    return n.getDependency("bufferView", s).then(function (u) {
      return new Promise(function (f, d) {
        r.decodeDracoFile(
          u,
          function (p) {
            for (const g in p.attributes) {
              const v = p.attributes[g],
                m = l[g];
              m !== void 0 && (v.normalized = m);
            }
            f(p);
          },
          a,
          c,
          tn,
          d
        );
      });
    });
  }
}
class LI {
  constructor() {
    this.name = We.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, n) {
    return (
      ((n.texCoord === void 0 || n.texCoord === e.channel) &&
        n.offset === void 0 &&
        n.rotation === void 0 &&
        n.scale === void 0) ||
        ((e = e.clone()),
        n.texCoord !== void 0 && (e.channel = n.texCoord),
        n.offset !== void 0 && e.offset.fromArray(n.offset),
        n.rotation !== void 0 && (e.rotation = n.rotation),
        n.scale !== void 0 && e.repeat.fromArray(n.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class II {
  constructor() {
    this.name = We.KHR_MESH_QUANTIZATION;
  }
}
class RS extends rl {
  constructor(e, n, i, r) {
    super(e, n, i, r);
  }
  copySampleValue_(e) {
    const n = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r;
    for (let o = 0; o !== r; o++) n[o] = i[s + o];
    return n;
  }
  interpolate_(e, n, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      c = a * 3,
      u = r - n,
      f = (i - n) / u,
      d = f * f,
      p = d * f,
      g = e * c,
      v = g - c,
      m = -2 * p + 3 * d,
      h = p - d,
      _ = 1 - m,
      y = h - d + f;
    for (let x = 0; x !== a; x++) {
      const C = o[v + x + a],
        R = o[v + x + l] * u,
        w = o[g + x + a],
        A = o[g + x] * u;
      s[x] = _ * C + y * R + m * w + h * A;
    }
    return s;
  }
}
const DI = new vi();
class NI extends RS {
  interpolate_(e, n, i, r) {
    const s = super.interpolate_(e, n, i, r);
    return DI.fromArray(s).normalize().toArray(s), s;
  }
}
const Un = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  fo = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  z0 = { 9728: ln, 9729: kt, 9984: Wx, 9985: gc, 9986: ca, 9987: pi },
  H0 = { 33071: hi, 33648: Zc, 10497: To },
  Hf = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  Gh = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  dr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  UI = { CUBICSPLINE: void 0, LINEAR: Ya, STEP: Xa },
  Vf = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function OI(t) {
  return (
    t.DefaultMaterial === void 0 &&
      (t.DefaultMaterial = new hm({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Zi,
      })),
    t.DefaultMaterial
  );
}
function Kr(t, e, n) {
  for (const i in n.extensions)
    t[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = n.extensions[i]));
}
function Ni(t, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(t.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function FI(t, e, n) {
  let i = !1,
    r = !1,
    s = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const f = e[c];
    if (
      (f.POSITION !== void 0 && (i = !0),
      f.NORMAL !== void 0 && (r = !0),
      f.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break;
  }
  if (!i && !r && !s) return Promise.resolve(t);
  const o = [],
    a = [],
    l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const f = e[c];
    if (i) {
      const d =
        f.POSITION !== void 0
          ? n.getDependency("accessor", f.POSITION)
          : t.attributes.position;
      o.push(d);
    }
    if (r) {
      const d =
        f.NORMAL !== void 0
          ? n.getDependency("accessor", f.NORMAL)
          : t.attributes.normal;
      a.push(d);
    }
    if (s) {
      const d =
        f.COLOR_0 !== void 0
          ? n.getDependency("accessor", f.COLOR_0)
          : t.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (c) {
      const u = c[0],
        f = c[1],
        d = c[2];
      return (
        i && (t.morphAttributes.position = u),
        r && (t.morphAttributes.normal = f),
        s && (t.morphAttributes.color = d),
        (t.morphTargetsRelative = !0),
        t
      );
    }
  );
}
function kI(t, e) {
  if ((t.updateMorphTargets(), e.weights !== void 0))
    for (let n = 0, i = e.weights.length; n < i; n++)
      t.morphTargetInfluences[n] = e.weights[n];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const n = e.extras.targetNames;
    if (t.morphTargetInfluences.length === n.length) {
      t.morphTargetDictionary = {};
      for (let i = 0, r = n.length; i < r; i++)
        t.morphTargetDictionary[n[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function BI(t) {
  let e;
  const n = t.extensions && t.extensions[We.KHR_DRACO_MESH_COMPRESSION];
  if (
    (n
      ? (e = "draco:" + n.bufferView + ":" + n.indices + ":" + Gf(n.attributes))
      : (e = t.indices + ":" + Gf(t.attributes) + ":" + t.mode),
    t.targets !== void 0)
  )
    for (let i = 0, r = t.targets.length; i < r; i++)
      e += ":" + Gf(t.targets[i]);
  return e;
}
function Gf(t) {
  let e = "";
  const n = Object.keys(t).sort();
  for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
  return e;
}
function Wh(t) {
  switch (t) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function zI(t) {
  return t.search(/\.jpe?g($|\?)/i) > 0 || t.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : t.search(/\.webp($|\?)/i) > 0 || t.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : t.search(/\.ktx2($|\?)/i) > 0 || t.search(/^data\:image\/ktx2/) === 0
    ? "image/ktx2"
    : "image/png";
}
const HI = new Be();
class VI {
  constructor(e = {}, n = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = n),
      (this.cache = new uI()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      r = -1,
      s = !1,
      o = -1;
    if (typeof navigator < "u") {
      const a = navigator.userAgent;
      i = /^((?!chrome|android).)*safari/i.test(a) === !0;
      const l = a.match(/Version\/(\d+)/);
      (r = i && l ? parseInt(l[1], 10) : -1),
        (s = a.indexOf("Firefox") > -1),
        (o = s ? a.match(/Firefox\/([0-9]+)\./)[1] : -1);
    }
    typeof createImageBitmap > "u" || (i && r < 17) || (s && o < 98)
      ? (this.textureLoader = new IL(this.options.manager))
      : (this.textureLoader = new kL(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new pm(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, n) {
    const i = this,
      r = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          return (
            Kr(s, a, r),
            Ni(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              for (const l of a.scenes) l.updateMatrixWorld();
              e(a);
            })
          );
        })
        .catch(n);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      n = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, s = n.length; r < s; r++) {
      const o = n[r].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, n) {
    n !== void 0 &&
      (e.refs[n] === void 0 && (e.refs[n] = e.uses[n] = 0), e.refs[n]++);
  }
  _getNodeRef(e, n, i) {
    if (e.refs[n] <= 1) return i;
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [c, u] of o.children.entries()) s(u, a.children[c]);
      };
    return s(i, r), (r.name += "_instance_" + e.uses[n]++), r;
  }
  _invokeOne(e) {
    const n = Object.values(this.plugins);
    n.push(this);
    for (let i = 0; i < n.length; i++) {
      const r = e(n[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const n = Object.values(this.plugins);
    n.unshift(this);
    const i = [];
    for (let r = 0; r < n.length; r++) {
      const s = e(n[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, n) {
    const i = e + ":" + n;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(n);
          break;
        case "node":
          r = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(n);
          });
          break;
        case "mesh":
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(n);
          });
          break;
        case "accessor":
          r = this.loadAccessor(n);
          break;
        case "bufferView":
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(n);
          });
          break;
        case "buffer":
          r = this.loadBuffer(n);
          break;
        case "material":
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(n);
          });
          break;
        case "texture":
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(n);
          });
          break;
        case "skin":
          r = this.loadSkin(n);
          break;
        case "animation":
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(n);
          });
          break;
        case "camera":
          r = this.loadCamera(n);
          break;
        default:
          if (
            ((r = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, n);
            })),
            !r)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let n = this.cache.get(e);
    if (!n) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (n = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o);
        })
      )),
        this.cache.add(e, n);
    }
    return n;
  }
  loadBuffer(e) {
    const n = this.json.buffers[e],
      i = this.fileLoader;
    if (n.type && n.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + n.type + " buffer type is not supported."
      );
    if (n.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[We.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (s, o) {
      i.load(wa.resolveURL(n.uri, r.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + n.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const n = this.json.bufferViews[e];
    return this.getDependency("buffer", n.buffer).then(function (i) {
      const r = n.byteLength || 0,
        s = n.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const n = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const o = Hf[r.type],
        a = fo[r.componentType],
        l = r.normalized === !0,
        c = new a(r.count * o);
      return Promise.resolve(new cn(c, o, l));
    }
    const s = [];
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = Hf[r.type],
          c = fo[r.componentType],
          u = c.BYTES_PER_ELEMENT,
          f = u * l,
          d = r.byteOffset || 0,
          p =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          g = r.normalized === !0;
        let v, m;
        if (p && p !== f) {
          const h = Math.floor(d / p),
            _ =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              h +
              ":" +
              r.count;
          let y = n.cache.get(_);
          y ||
            ((v = new c(a, h * p, (r.count * p) / u)),
            (y = new cL(v, p / u)),
            n.cache.add(_, y)),
            (m = new cm(y, l, (d % p) / u, g));
        } else a === null ? (v = new c(r.count * l)) : (v = new c(a, d, r.count * l)), (m = new cn(v, l, g));
        if (r.sparse !== void 0) {
          const h = Hf.SCALAR,
            _ = fo[r.sparse.indices.componentType],
            y = r.sparse.indices.byteOffset || 0,
            x = r.sparse.values.byteOffset || 0,
            C = new _(o[1], y, r.sparse.count * h),
            R = new c(o[2], x, r.sparse.count * l);
          a !== null && (m = new cn(m.array.slice(), m.itemSize, m.normalized)),
            (m.normalized = !1);
          for (let w = 0, A = C.length; w < A; w++) {
            const E = C[w];
            if (
              (m.setX(E, R[w * l]),
              l >= 2 && m.setY(E, R[w * l + 1]),
              l >= 3 && m.setZ(E, R[w * l + 2]),
              l >= 4 && m.setW(E, R[w * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
          m.normalized = g;
        }
        return m;
      })
    );
  }
  loadTexture(e) {
    const n = this.json,
      i = this.options,
      s = n.textures[e].source,
      o = n.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, n, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[n],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(n, i)
      .then(function (u) {
        (u.flipY = !1),
          (u.name = o.name || a.name || ""),
          u.name === "" &&
            typeof a.uri == "string" &&
            a.uri.startsWith("data:image/") === !1 &&
            (u.name = a.uri);
        const d = (s.samplers || {})[o.sampler] || {};
        return (
          (u.magFilter = z0[d.magFilter] || kt),
          (u.minFilter = z0[d.minFilter] || pi),
          (u.wrapS = H0[d.wrapS] || To),
          (u.wrapT = H0[d.wrapT] || To),
          (u.generateMipmaps =
            !u.isCompressedTexture && u.minFilter !== ln && u.minFilter !== kt),
          r.associations.set(u, { textures: e }),
          u
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, n) {
    const i = this,
      r = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((f) => f.clone());
    const o = r.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      c = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function (f) {
        c = !0;
        const d = new Blob([f], { type: o.mimeType });
        return (l = a.createObjectURL(d)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const u = Promise.resolve(l)
      .then(function (f) {
        return new Promise(function (d, p) {
          let g = d;
          n.isImageBitmapLoader === !0 &&
            (g = function (v) {
              const m = new zt(v);
              (m.needsUpdate = !0), d(m);
            }),
            n.load(wa.resolveURL(f, s.path), g, void 0, p);
        });
      })
      .then(function (f) {
        return (
          c === !0 && a.revokeObjectURL(l),
          Ni(f, o),
          (f.userData.mimeType = o.mimeType || zI(o.uri)),
          f
        );
      })
      .catch(function (f) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), f);
      });
    return (this.sourceCache[e] = u), u;
  }
  assignTexture(e, n, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (o) {
      if (!o) return null;
      if (
        (i.texCoord !== void 0 &&
          i.texCoord > 0 &&
          ((o = o.clone()), (o.channel = i.texCoord)),
        s.extensions[We.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[We.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          (o = s.extensions[We.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l);
        }
      }
      return r !== void 0 && (o.colorSpace = r), (e[n] = o), o;
    });
  }
  assignFinalMaterial(e) {
    const n = e.geometry;
    let i = e.material;
    const r = n.attributes.tangent === void 0,
      s = n.attributes.color !== void 0,
      o = n.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new MS()),
        _i.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new SS()),
        _i.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        this.cache.add(a, l)),
        (i = l);
    }
    if (r || s || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      r && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l);
    }
    e.material = i;
  }
  getMaterialType() {
    return hm;
  }
  loadMaterial(e) {
    const n = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      c = [];
    if (l[We.KHR_MATERIALS_UNLIT]) {
      const f = r[We.KHR_MATERIALS_UNLIT];
      (o = f.getMaterialType()), c.push(f.extendParams(a, s, n));
    } else {
      const f = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new De(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(f.baseColorFactor))
      ) {
        const d = f.baseColorFactor;
        a.color.setRGB(d[0], d[1], d[2], tn), (a.opacity = d[3]);
      }
      f.baseColorTexture !== void 0 &&
        c.push(n.assignTexture(a, "map", f.baseColorTexture, Gt)),
        (a.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1),
        (a.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1),
        f.metallicRoughnessTexture !== void 0 &&
          (c.push(
            n.assignTexture(a, "metalnessMap", f.metallicRoughnessTexture)
          ),
          c.push(
            n.assignTexture(a, "roughnessMap", f.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (d) {
          return d.getMaterialType && d.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (d) {
              return d.extendMaterialParams && d.extendMaterialParams(e, a);
            })
          )
        );
    }
    s.doubleSided === !0 && (a.side = ui);
    const u = s.alphaMode || Vf.OPAQUE;
    if (
      (u === Vf.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          u === Vf.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== rs &&
        (c.push(n.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new Le(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const f = s.normalTexture.scale;
      a.normalScale.set(f, f);
    }
    if (
      (s.occlusionTexture !== void 0 &&
        o !== rs &&
        (c.push(n.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && o !== rs)
    ) {
      const f = s.emissiveFactor;
      a.emissive = new De().setRGB(f[0], f[1], f[2], tn);
    }
    return (
      s.emissiveTexture !== void 0 &&
        o !== rs &&
        c.push(n.assignTexture(a, "emissiveMap", s.emissiveTexture, Gt)),
      Promise.all(c).then(function () {
        const f = new o(a);
        return (
          s.name && (f.name = s.name),
          Ni(f, s),
          n.associations.set(f, { materials: e }),
          s.extensions && Kr(r, f, s),
          f
        );
      })
    );
  }
  createUniqueName(e) {
    const n = st.sanitizeNodeName(e || "");
    return n in this.nodeNamesUsed
      ? n + "_" + ++this.nodeNamesUsed[n]
      : ((this.nodeNamesUsed[n] = 0), n);
  }
  loadGeometries(e) {
    const n = this,
      i = this.extensions,
      r = this.primitiveCache;
    function s(a) {
      return i[We.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, n)
        .then(function (l) {
          return V0(l, a, n);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = BI(c),
        f = r[u];
      if (f) o.push(f.promise);
      else {
        let d;
        c.extensions && c.extensions[We.KHR_DRACO_MESH_COMPRESSION]
          ? (d = s(c))
          : (d = V0(new Si(), c, n)),
          (r[u] = { primitive: c, promise: d }),
          o.push(d);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const n = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const u =
        o[l].material === void 0
          ? OI(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(u);
    }
    return (
      a.push(n.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const c = l.slice(0, l.length - 1),
          u = l[l.length - 1],
          f = [];
        for (let p = 0, g = u.length; p < g; p++) {
          const v = u[p],
            m = o[p];
          let h;
          const _ = c[p];
          if (
            m.mode === Un.TRIANGLES ||
            m.mode === Un.TRIANGLE_STRIP ||
            m.mode === Un.TRIANGLE_FAN ||
            m.mode === void 0
          )
            (h = s.isSkinnedMesh === !0 ? new fL(v, _) : new An(v, _)),
              h.isSkinnedMesh === !0 && h.normalizeSkinWeights(),
              m.mode === Un.TRIANGLE_STRIP
                ? (h.geometry = k0(h.geometry, eS))
                : m.mode === Un.TRIANGLE_FAN &&
                  (h.geometry = k0(h.geometry, kh));
          else if (m.mode === Un.LINES) h = new mL(v, _);
          else if (m.mode === Un.LINE_STRIP) h = new dm(v, _);
          else if (m.mode === Un.LINE_LOOP) h = new gL(v, _);
          else if (m.mode === Un.POINTS) h = new _L(v, _);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + m.mode
            );
          Object.keys(h.geometry.morphAttributes).length > 0 && kI(h, s),
            (h.name = n.createUniqueName(s.name || "mesh_" + e)),
            Ni(h, s),
            m.extensions && Kr(r, h, m),
            n.assignFinalMaterial(h),
            f.push(h);
        }
        for (let p = 0, g = f.length; p < g; p++)
          n.associations.set(f[p], { meshes: e, primitives: p });
        if (f.length === 1) return s.extensions && Kr(r, f[0], s), f[0];
        const d = new ss();
        s.extensions && Kr(r, d, s), n.associations.set(d, { meshes: e });
        for (let p = 0, g = f.length; p < g; p++) d.add(f[p]);
        return d;
      })
    );
  }
  loadCamera(e) {
    let n;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (n = new on(
            iS.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (n = new am(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (n.name = this.createUniqueName(i.name)),
      Ni(n, i),
      Promise.resolve(n)
    );
  }
  loadSkin(e) {
    const n = this.json.skins[e],
      i = [];
    for (let r = 0, s = n.joints.length; r < s; r++)
      i.push(this._loadNodeShallow(n.joints[r]));
    return (
      n.inverseBindMatrices !== void 0
        ? i.push(this.getDependency("accessor", n.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (r) {
        const s = r.pop(),
          o = r,
          a = [],
          l = [];
        for (let c = 0, u = o.length; c < u; c++) {
          const f = o[c];
          if (f) {
            a.push(f);
            const d = new Be();
            s !== null && d.fromArray(s.array, c * 16), l.push(d);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              n.joints[c]
            );
        }
        return new fm(a, l);
      })
    );
  }
  loadAnimation(e) {
    const n = this.json,
      i = this,
      r = n.animations[e],
      s = r.name ? r.name : "animation_" + e,
      o = [],
      a = [],
      l = [],
      c = [],
      u = [];
    for (let f = 0, d = r.channels.length; f < d; f++) {
      const p = r.channels[f],
        g = r.samplers[p.sampler],
        v = p.target,
        m = v.node,
        h = r.parameters !== void 0 ? r.parameters[g.input] : g.input,
        _ = r.parameters !== void 0 ? r.parameters[g.output] : g.output;
      v.node !== void 0 &&
        (o.push(this.getDependency("node", m)),
        a.push(this.getDependency("accessor", h)),
        l.push(this.getDependency("accessor", _)),
        c.push(g),
        u.push(v));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(u),
    ]).then(function (f) {
      const d = f[0],
        p = f[1],
        g = f[2],
        v = f[3],
        m = f[4],
        h = [];
      for (let _ = 0, y = d.length; _ < y; _++) {
        const x = d[_],
          C = p[_],
          R = g[_],
          w = v[_],
          A = m[_];
        if (x === void 0) continue;
        x.updateMatrix && x.updateMatrix();
        const E = i._createAnimationTracks(x, C, R, w, A);
        if (E) for (let S = 0; S < E.length; S++) h.push(E[S]);
      }
      return new TL(s, void 0, h);
    });
  }
  createNodeMesh(e) {
    const n = this.json,
      i = this,
      r = n.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s);
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, c = r.weights.length; l < c; l++)
                    a.morphTargetInfluences[l] = r.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const n = this.json,
      i = this,
      r = n.nodes[e],
      s = i._loadNodeShallow(e),
      o = [],
      a = r.children || [];
    for (let c = 0, u = a.length; c < u; c++)
      o.push(i.getDependency("node", a[c]));
    const l =
      r.skin === void 0
        ? Promise.resolve(null)
        : i.getDependency("skin", r.skin);
    return Promise.all([s, Promise.all(o), l]).then(function (c) {
      const u = c[0],
        f = c[1],
        d = c[2];
      d !== null &&
        u.traverse(function (p) {
          p.isSkinnedMesh && p.bind(d, HI);
        });
      for (let p = 0, g = f.length; p < g; p++) u.add(f[p]);
      return u;
    });
  }
  _loadNodeShallow(e) {
    const n = this.json,
      i = this.extensions,
      r = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = n.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : "",
      a = [],
      l = r._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
    return (
      l && a.push(l),
      s.camera !== void 0 &&
        a.push(
          r.getDependency("camera", s.camera).then(function (c) {
            return r._getNodeRef(r.cameraCache, s.camera, c);
          })
        ),
      r
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        })
        .forEach(function (c) {
          a.push(c);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (c) {
        let u;
        if (
          (s.isBone === !0
            ? (u = new xS())
            : c.length > 1
            ? (u = new ss())
            : c.length === 1
            ? (u = c[0])
            : (u = new Mt()),
          u !== c[0])
        )
          for (let f = 0, d = c.length; f < d; f++) u.add(c[f]);
        if (
          (s.name && ((u.userData.name = s.name), (u.name = o)),
          Ni(u, s),
          s.extensions && Kr(i, u, s),
          s.matrix !== void 0)
        ) {
          const f = new Be();
          f.fromArray(s.matrix), u.applyMatrix4(f);
        } else s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
        return (
          r.associations.has(u) || r.associations.set(u, {}),
          (r.associations.get(u).nodes = e),
          u
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const n = this.extensions,
      i = this.json.scenes[e],
      r = this,
      s = new ss();
    i.name && (s.name = r.createUniqueName(i.name)),
      Ni(s, i),
      i.extensions && Kr(n, s, i);
    const o = i.nodes || [],
      a = [];
    for (let l = 0, c = o.length; l < c; l++)
      a.push(r.getDependency("node", o[l]));
    return Promise.all(a).then(function (l) {
      for (let u = 0, f = l.length; u < f; u++) s.add(l[u]);
      const c = (u) => {
        const f = new Map();
        for (const [d, p] of r.associations)
          (d instanceof _i || d instanceof zt) && f.set(d, p);
        return (
          u.traverse((d) => {
            const p = r.associations.get(d);
            p != null && f.set(d, p);
          }),
          f
        );
      };
      return (r.associations = c(s)), s;
    });
  }
  _createAnimationTracks(e, n, i, r, s) {
    const o = [],
      a = e.name ? e.name : e.uuid,
      l = [];
    dr[s.path] === dr.weights
      ? e.traverse(function (d) {
          d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
        })
      : l.push(a);
    let c;
    switch (dr[s.path]) {
      case dr.weights:
        c = Co;
        break;
      case dr.rotation:
        c = Po;
        break;
      case dr.position:
      case dr.scale:
        c = Lo;
        break;
      default:
        switch (i.itemSize) {
          case 1:
            c = Co;
            break;
          case 2:
          case 3:
          default:
            c = Lo;
            break;
        }
        break;
    }
    const u = r.interpolation !== void 0 ? UI[r.interpolation] : Ya,
      f = this._getArrayFromAccessor(i);
    for (let d = 0, p = l.length; d < p; d++) {
      const g = new c(l[d] + "." + dr[s.path], n.array, f, u);
      r.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(g),
        o.push(g);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let n = e.array;
    if (e.normalized) {
      const i = Wh(n.constructor),
        r = new Float32Array(n.length);
      for (let s = 0, o = n.length; s < o; s++) r[s] = n[s] * i;
      n = r;
    }
    return n;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (i) {
      const r = this instanceof Po ? NI : RS;
      return new r(this.times, this.values, this.getValueSize() / 3, i);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function GI(t, e, n) {
  const i = e.attributes,
    r = new tr();
  if (i.POSITION !== void 0) {
    const a = n.json.accessors[i.POSITION],
      l = a.min,
      c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (r.set(new D(l[0], l[1], l[2]), new D(c[0], c[1], c[2])), a.normalized)
      ) {
        const u = Wh(fo[a.componentType]);
        r.min.multiplyScalar(u), r.max.multiplyScalar(u);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new D(),
      l = new D();
    for (let c = 0, u = s.length; c < u; c++) {
      const f = s[c];
      if (f.POSITION !== void 0) {
        const d = n.json.accessors[f.POSITION],
          p = d.min,
          g = d.max;
        if (p !== void 0 && g !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(p[0]), Math.abs(g[0]))),
            l.setY(Math.max(Math.abs(p[1]), Math.abs(g[1]))),
            l.setZ(Math.max(Math.abs(p[2]), Math.abs(g[2]))),
            d.normalized)
          ) {
            const v = Wh(fo[d.componentType]);
            l.multiplyScalar(v);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    r.expandByVector(a);
  }
  t.boundingBox = r;
  const o = new xi();
  r.getCenter(o.center),
    (o.radius = r.min.distanceTo(r.max) / 2),
    (t.boundingSphere = o);
}
function V0(t, e, n) {
  const i = e.attributes,
    r = [];
  function s(o, a) {
    return n.getDependency("accessor", o).then(function (l) {
      t.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = Gh[o] || o.toLowerCase();
    a in t.attributes || r.push(s(i[o], a));
  }
  if (e.indices !== void 0 && !t.index) {
    const o = n.getDependency("accessor", e.indices).then(function (a) {
      t.setIndex(a);
    });
    r.push(o);
  }
  return (
    Xe.workingColorSpace !== tn &&
      "COLOR_0" in i &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Xe.workingColorSpace}" not supported.`
      ),
    Ni(t, e),
    GI(t, e, n),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? FI(t, e.targets, n) : t;
    })
  );
}
class WI extends LL {
  constructor(e) {
    super(e), (this.type = zi);
  }
  parse(e) {
    const o = function (A, E) {
        switch (A) {
          case 1:
            throw new Error("THREE.RGBELoader: Read Error: " + (E || ""));
          case 2:
            throw new Error("THREE.RGBELoader: Write Error: " + (E || ""));
          case 3:
            throw new Error("THREE.RGBELoader: Bad File Format: " + (E || ""));
          default:
          case 4:
            throw new Error("THREE.RGBELoader: Memory Error: " + (E || ""));
        }
      },
      u = `
`,
      f = function (A, E, S) {
        E = E || 1024;
        let G = A.pos,
          F = -1,
          H = 0,
          X = "",
          V = String.fromCharCode.apply(
            null,
            new Uint16Array(A.subarray(G, G + 128))
          );
        for (; 0 > (F = V.indexOf(u)) && H < E && G < A.byteLength; )
          (X += V),
            (H += V.length),
            (G += 128),
            (V += String.fromCharCode.apply(
              null,
              new Uint16Array(A.subarray(G, G + 128))
            ));
        return -1 < F ? ((A.pos += H + F + 1), X + V.slice(0, F)) : !1;
      },
      d = function (A) {
        const E = /^#\?(\S+)/,
          S = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          P = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          G = /^\s*FORMAT=(\S+)\s*$/,
          F = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          H = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let X, V;
        for (
          (A.pos >= A.byteLength || !(X = f(A))) && o(1, "no header found"),
            (V = X.match(E)) || o(3, "bad initial token"),
            H.valid |= 1,
            H.programtype = V[1],
            H.string +=
              X +
              `
`;
          (X = f(A)), X !== !1;

        ) {
          if (
            ((H.string +=
              X +
              `
`),
            X.charAt(0) === "#")
          ) {
            H.comments +=
              X +
              `
`;
            continue;
          }
          if (
            ((V = X.match(S)) && (H.gamma = parseFloat(V[1])),
            (V = X.match(P)) && (H.exposure = parseFloat(V[1])),
            (V = X.match(G)) && ((H.valid |= 2), (H.format = V[1])),
            (V = X.match(F)) &&
              ((H.valid |= 4),
              (H.height = parseInt(V[1], 10)),
              (H.width = parseInt(V[2], 10))),
            H.valid & 2 && H.valid & 4)
          )
            break;
        }
        return (
          H.valid & 2 || o(3, "missing format specifier"),
          H.valid & 4 || o(3, "missing image size specifier"),
          H
        );
      },
      p = function (A, E, S) {
        const P = E;
        if (P < 8 || P > 32767 || A[0] !== 2 || A[1] !== 2 || A[2] & 128)
          return new Uint8Array(A);
        P !== ((A[2] << 8) | A[3]) && o(3, "wrong scanline width");
        const G = new Uint8Array(4 * E * S);
        G.length || o(4, "unable to allocate buffer space");
        let F = 0,
          H = 0;
        const X = 4 * P,
          V = new Uint8Array(4),
          Z = new Uint8Array(X);
        let L = S;
        for (; L > 0 && H < A.byteLength; ) {
          H + 4 > A.byteLength && o(1),
            (V[0] = A[H++]),
            (V[1] = A[H++]),
            (V[2] = A[H++]),
            (V[3] = A[H++]),
            (V[0] != 2 || V[1] != 2 || ((V[2] << 8) | V[3]) != P) &&
              o(3, "bad rgbe scanline format");
          let Y = 0,
            q;
          for (; Y < X && H < A.byteLength; ) {
            q = A[H++];
            const pe = q > 128;
            if (
              (pe && (q -= 128),
              (q === 0 || Y + q > X) && o(3, "bad scanline data"),
              pe)
            ) {
              const Ne = A[H++];
              for (let j = 0; j < q; j++) Z[Y++] = Ne;
            } else Z.set(A.subarray(H, H + q), Y), (Y += q), (H += q);
          }
          const oe = P;
          for (let pe = 0; pe < oe; pe++) {
            let Ne = 0;
            (G[F] = Z[pe + Ne]),
              (Ne += P),
              (G[F + 1] = Z[pe + Ne]),
              (Ne += P),
              (G[F + 2] = Z[pe + Ne]),
              (Ne += P),
              (G[F + 3] = Z[pe + Ne]),
              (F += 4);
          }
          L--;
        }
        return G;
      },
      g = function (A, E, S, P) {
        const G = A[E + 3],
          F = Math.pow(2, G - 128) / 255;
        (S[P + 0] = A[E + 0] * F),
          (S[P + 1] = A[E + 1] * F),
          (S[P + 2] = A[E + 2] * F),
          (S[P + 3] = 1);
      },
      v = function (A, E, S, P) {
        const G = A[E + 3],
          F = Math.pow(2, G - 128) / 255;
        (S[P + 0] = Ul.toHalfFloat(Math.min(A[E + 0] * F, 65504))),
          (S[P + 1] = Ul.toHalfFloat(Math.min(A[E + 1] * F, 65504))),
          (S[P + 2] = Ul.toHalfFloat(Math.min(A[E + 2] * F, 65504))),
          (S[P + 3] = Ul.toHalfFloat(1));
      },
      m = new Uint8Array(e);
    m.pos = 0;
    const h = d(m),
      _ = h.width,
      y = h.height,
      x = p(m.subarray(m.pos), _, y);
    let C, R, w;
    switch (this.type) {
      case gn:
        w = x.length / 4;
        const A = new Float32Array(w * 4);
        for (let S = 0; S < w; S++) g(x, S * 4, A, S * 4);
        (C = A), (R = gn);
        break;
      case zi:
        w = x.length / 4;
        const E = new Uint16Array(w * 4);
        for (let S = 0; S < w; S++) v(x, S * 4, E, S * 4);
        (C = E), (R = zi);
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: _,
      height: y,
      data: C,
      header: h.string,
      gamma: h.gamma,
      exposure: h.exposure,
      type: R,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, n, i, r) {
    function s(o, a) {
      switch (o.type) {
        case gn:
        case zi:
          (o.colorSpace = tn),
            (o.minFilter = kt),
            (o.magFilter = kt),
            (o.generateMipmaps = !1),
            (o.flipY = !0);
          break;
      }
      n && n(o, a);
    }
    return super.load(e, s, i, r);
  }
}
function jI() {
  const t = Qt.useRef(null);
  return (
    Qt.useEffect(() => {
      const e = new lL();
      new WI().load("../src/blender/360view.hdr", function (c) {
        (c.mapping = $c), (e.environment = c), (e.background = c);
      });
      const i = new on(40, 16 / 9, 0.2, 1e3);
      i.position.set(-12, -6, 20);
      const r = new aL({ alpha: !1 });
      r.setSize(window.innerWidth, window.innerHeight),
        t.current.appendChild(r.domElement);
      const s = new $L(i, r.domElement);
      (s.enableDamping = !0),
        (s.dampingFactor = 0.05),
        new cI().load(
          "../src/blender/Gecko coin 2.gltf",
          function (c) {
            const u = c.scene;
            u.scale.set(3, 3, 3),
              (u.rotation.y = 1.5),
              u.traverse((f) => {
                f.isMesh &&
                  f.material &&
                  ((f.material.metalness = 1), (f.material.roughness = 0.2));
              }),
              e.add(u);
          },
          void 0,
          function (c) {
            console.error(c);
          }
        );
      const a = new wS(16777215, 10);
      a.position.set(0, 30, 100), (a.castShadow = !0), e.add(a);
      function l() {
        requestAnimationFrame(l), s.update(), r.render(e, i);
      }
      return (
        l(),
        () => {
          t.current && t.current.removeChild(r.domElement),
            r.dispose(),
            s.dispose();
        }
      );
    }, []),
    K.jsx("div", {
      className: "containerTV",
      children: K.jsx("div", {
        className: "TV",
        children: K.jsx("div", { ref: t, id: "container3D" }),
      }),
    })
  );
}
function XI() {
  const [t, e] = Qt.useState(""),
    n = (i) => {
      e(i);
    };
  return K.jsxs(K.Fragment, {
    children: [
      K.jsx(o1, { onSearch: n }),
      K.jsx(a1, {}),
      K.jsx(Lw, {}),
      K.jsx(jI, {}),
      K.jsx(s1, { searchedCoin: t }),
      K.jsx(zw, {}),
    ],
  });
}
const YI = Wf.createRoot(document.getElementById("root"));
YI.render(K.jsx(qh.StrictMode, { children: K.jsx(XI, {}) }));
